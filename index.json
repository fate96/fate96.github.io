[{"categories":["算法"],"content":"前言 若要寻找两个节点路径最小权重，最为常用的方法是 Dijkstra， 当一个图各个节点的权重只有 0 和 1 （k）时，则可以使用 0-1 BFS 进行搜索 ","date":"2022-06-02","objectID":"/posts/0-1-bfs.html/:1:0","tags":["BFS"],"title":"0-1 BFS","uri":"/posts/0-1-bfs.html/"},{"categories":["算法"],"content":"算法思想 0-1 BFS 算法是通过 BFS 搜索，当节点的权重为 0 时，则放置在队头，若为 1 时，则放置在队尾。初始时，默认从源节点到各个节点路径权重为无穷大，开始将源节点放置队列，并将权重置为 0。BFS 搜索节点，若节点路径权重发生改变时，则按上述规则入队，否则搜索队列的下一个节点，直到队列为空时，搜索结束，此时路径权重收缩至最小值。时间复杂度为 $O(m*N)$ ","date":"2022-06-02","objectID":"/posts/0-1-bfs.html/:2:0","tags":["BFS"],"title":"0-1 BFS","uri":"/posts/0-1-bfs.html/"},{"categories":["算法"],"content":"代码实现 2290. 到达角落需要移除障碍物的最小数目 给你一个下标从 0 开始的二维整数数组 grid ，数组大小为 m x n 。每个单元格都是两个值之一： 0 表示一个 空 单元格， 1 表示一个可以移除的 障碍物 。 你可以向上、下、左、右移动，从一个空单元格移动到另一个空单元格。 现在你需要从左上角 (0, 0) 移动到右下角 (m - 1, n - 1) ，返回需要移除的障碍物的 最小 数目。 class Solution { final static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; public int minimumObstacles(int[][] grid) { int m = grid.length, n = grid[0].length; var dis = new int[m][n]; for (var i = 0; i \u003c m; i++) Arrays.fill(dis[i], Integer.MAX_VALUE); dis[0][0] = 0; var q = new ArrayDeque\u003cint[]\u003e(); q.addFirst(new int[]{0, 0}); while (!q.isEmpty()) { var p = q.pollFirst(); int x = p[0], y = p[1]; for (var d : dirs) { int nx = x + d[0], ny = y + d[1]; if (0 \u003c= nx \u0026\u0026 nx \u003c m \u0026\u0026 0 \u003c= ny \u0026\u0026 ny \u003c n) { var g = grid[nx][ny]; if (dis[x][y] + g \u003c dis[nx][ny]) { dis[nx][ny] = dis[x][y] + g; if (g == 0) q.addFirst(new int[]{nx, ny}); else q.addLast(new int[]{nx, ny}); } } } } return dis[m - 1][n - 1]; } } ","date":"2022-06-02","objectID":"/posts/0-1-bfs.html/:3:0","tags":["BFS"],"title":"0-1 BFS","uri":"/posts/0-1-bfs.html/"},{"categories":["算法"],"content":"参考资料 0-1 BFS 0-1 BFS Tutorial ","date":"2022-06-02","objectID":"/posts/0-1-bfs.html/:4:0","tags":["BFS"],"title":"0-1 BFS","uri":"/posts/0-1-bfs.html/"},{"categories":["Pytorch"],"content":"前言 记录深度学习中使用 pytorch 的常用技巧 ","date":"2022-05-29","objectID":"/posts/pytorch-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/:1:0","tags":["pytorch"],"title":"Pytorch 基本使用","uri":"/posts/pytorch-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/"},{"categories":["Pytorch"],"content":"内容 ","date":"2022-05-29","objectID":"/posts/pytorch-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/:2:0","tags":["pytorch"],"title":"Pytorch 基本使用","uri":"/posts/pytorch-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/"},{"categories":["Pytorch"],"content":"就地函数 在 pytorch 中，使用带有下标 _ 表示的就地改变数据，而不需要使用变量接受改变后的值，比如 fill_ 函数。 x = torch.Tensor(2, 3) x.fill_(5) # tensor([[5., 5., 5.], # [5., 5., 5.]]) ","date":"2022-05-29","objectID":"/posts/pytorch-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/:2:1","tags":["pytorch"],"title":"Pytorch 基本使用","uri":"/posts/pytorch-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/"},{"categories":["Pytorch"],"content":"numypy 转 Tensor numpy 转 Tensor后，Tensor 的类型为 DoubleTensor，而不是默认的 FloatTensor，这对应于 numpy 的 float64。 ","date":"2022-05-29","objectID":"/posts/pytorch-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/:2:2","tags":["pytorch"],"title":"Pytorch 基本使用","uri":"/posts/pytorch-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/"},{"categories":["Pytorch"],"content":"torch.Tensor 和 torch.tensor 区别 Tensor 是类，而 tenosr 是函数，Tensor 返回的是 FloatTensor，而 tensor 则根据提供的数据返回的 LongTensor、 FloatTensor 和 DoubleTensor 等类型。 ","date":"2022-05-29","objectID":"/posts/pytorch-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/:2:3","tags":["pytorch"],"title":"Pytorch 基本使用","uri":"/posts/pytorch-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/"},{"categories":["Mybatis"],"content":"前言 总结一些在使用 Mybatis 的一些注意事项 ","date":"2022-05-24","objectID":"/posts/mybatis-%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93.html/:1:0","tags":["Java","Mybatis"],"title":"Mybatis 常用总结","uri":"/posts/mybatis-%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93.html/"},{"categories":["Mybatis"],"content":"内容 ","date":"2022-05-24","objectID":"/posts/mybatis-%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93.html/:2:0","tags":["Java","Mybatis"],"title":"Mybatis 常用总结","uri":"/posts/mybatis-%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93.html/"},{"categories":["Mybatis"],"content":"使用 like 进行模糊批评 当使用 sql 语句进行模糊查询时，由于模糊查询需要使用 % 符号表示模糊查询，所以在查询的过程中需要传入 % 字符。 两种使用方式 like “%”#{XX}\"%\" ：手动拼接，因为 #{} 作为占位符，会被单引号的字符串直接替换，所以 % 需要使用双引号的字符串 使用concat()函数连接参数形式：like concat(’’%’, #{xx},’%') Mybatis 参数拼接 #{} 和 ${} ","date":"2022-05-24","objectID":"/posts/mybatis-%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93.html/:2:1","tags":["Java","Mybatis"],"title":"Mybatis 常用总结","uri":"/posts/mybatis-%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93.html/"},{"categories":["算法"],"content":"前言 极值和最值不一样，极值是由区间范围所决定的，最值是由整个区间所决定的，当求极值的一个区间的影响范围时，由于涉及多个区间，如果直接暴力求，则需要 $O(n^2)$ 时间复杂度，而使用单调栈进行求解，时间复杂度为 $O(n)$ 。 shiro 工作流程 ","date":"2022-05-24","objectID":"/posts/%E5%8D%95%E8%B0%83%E6%A0%88.html/:1:0","tags":["单调栈","区间极值"],"title":"单调栈","uri":"/posts/%E5%8D%95%E8%B0%83%E6%A0%88.html/"},{"categories":["算法"],"content":"算法思想 单调栈是指一个栈的值顺序是自增或自减的，比如求值最小值所影响的区间范围是，则使用单调递增的栈。从左至右遍历数组 $arr$，当遍历当数组元素 $a_i$ 时，栈中第一个小于数组元素的值即为当前元素 $a_i$ 作为最小值的左区间，若栈空或者栈中无元素小于当前元素，则左区间表示整个区间的左端。同理，也可以从右至左求该元素的最为最小值的右区间。 至此，数组的每个元素作为最值的影响范围都已经求出 ","date":"2022-05-24","objectID":"/posts/%E5%8D%95%E8%B0%83%E6%A0%88.html/:2:0","tags":["单调栈","区间极值"],"title":"单调栈","uri":"/posts/%E5%8D%95%E8%B0%83%E6%A0%88.html/"},{"categories":["算法"],"content":"代码实现 ","date":"2022-05-24","objectID":"/posts/%E5%8D%95%E8%B0%83%E6%A0%88.html/:3:0","tags":["单调栈","区间极值"],"title":"单调栈","uri":"/posts/%E5%8D%95%E8%B0%83%E6%A0%88.html/"},{"categories":["算法"],"content":"1856. 子数组最小乘积的最大值 一个数组的 最小乘积 定义为这个数组中 最小值 乘以 数组的 和 。 比方说，数组 [3,2,5] （最小值是 2）的最小乘积为 2 * (3+2+5) = 2 * 10 = 20 。 给你一个正整数数组 nums ，请你返回 nums 任意 非空子数组 的最小乘积 的 最大值 。由于答案可能很大，请你返回答案对 109 + 7 取余 的结果。 请注意，最小乘积的最大值考虑的是取余操作 之前 的结果。题目保证最小乘积的最大值在 不取余 的情况下可以用 64 位有符号整数 保存。 子数组 定义为一个数组的 连续 部分。 由于题目需要求最大值，所以区间范围应该为极值的最大影响范围，这与单调栈解决的方向完美契合，而区间和可以通过前缀和解决，因此该题是前缀和 + 单调栈的模板题目。 class Solution { public int maxSumMinProduct(int[] nums) { final int mod = (int) (1e9 + 7); int n = nums.length; int[] left = new int[n]; int[] right = new int[n]; ArrayDeque\u003cInteger\u003e st = new ArrayDeque\u003c\u003e(); left[0] = 0; right[n-1] = n; st.push(0); for (int i = 1; i \u003c n; i++) { while (!st.isEmpty() \u0026\u0026 nums[st.peek()] \u003e= nums[i]){ st.pop(); } left[i] = st.isEmpty() ? 0 : st.peek() + 1; st.push(i); } st = new ArrayDeque\u003c\u003e(); st.push(n-1); for (int i = n - 2; i \u003e= 0; i--) { while (!st.isEmpty() \u0026\u0026 nums[st.peek()] \u003e= nums[i]){ st.pop(); } right[i] = st.isEmpty() ? n: st.peek(); st.push(i); } long[] prefix = new long[n+1]; for (int i = 0; i \u003c n; i++) { prefix[i+1] = prefix[i] + nums[i]; } long max = 0; for (int i = 0; i \u003c n; i++) { long product = nums[i] * (prefix[right[i]] - prefix[left[i]]) ; max = Math.max(max, product); } return (int) (max % mod); } } 单调栈求左右区间范围时，可以通过一次遍历实现同时求左右区间，当一次遍历求左右区间范围时，需要初始化默认左右区间值，上题默认左区间范围为 $0$，默认右区间范围为 $n-1$ 。 class Solution { public int maxSumMinProduct(int[] nums) { final int mod = (int) (1e9 + 7); int n = nums.length; int[] left = new int[n]; int[] right = new int[n]; ArrayDeque\u003cInteger\u003e st = new ArrayDeque\u003c\u003e(); left[0] = 0; Arrays.fill(right, n-1); for (int i = 0; i \u003c n; i++) { while (!st.isEmpty() \u0026\u0026 nums[st.peek()] \u003e= nums[i]) { right[st.pop()] = i - 1; } if (!st.isEmpty()) { left[i] = st.peek() + 1; } st.push(i); } long[] prefix = new long[n + 1]; for (int i = 0; i \u003c n; i++) { prefix[i + 1] = prefix[i] + nums[i]; } long max = 0; for (int i = 0; i \u003c n; i++) { long product = nums[i] * (prefix[right[i] + 1] - prefix[left[i]]); max = Math.max(max, product); } return (int) (max % mod); } } ","date":"2022-05-24","objectID":"/posts/%E5%8D%95%E8%B0%83%E6%A0%88.html/:3:1","tags":["单调栈","区间极值"],"title":"单调栈","uri":"/posts/%E5%8D%95%E8%B0%83%E6%A0%88.html/"},{"categories":["算法"],"content":"2281. 巫师的总力量和 作为国王的统治者，你有一支巫师军队听你指挥。 给你一个下标从 0 开始的整数数组 strength ，其中 strength[i] 表示第 i 位巫师的力量值。对于连续的一组巫师（也就是这些巫师的力量值是 strength 的 子数组），总力量 定义为以下两个值的 乘积 ： 1. 巫师中 最弱 的能力值。 2. 组中所有巫师的个人力量值 之和 。 请你返回 所有 巫师组的 总 力量之和。由于答案可能很大，请将答案对 109 + 7 取余 后返回。 子数组 是一个数组里 非空 连续子序列。 连续的一组巫师代表的就是一个连续区间范围，最弱的值则为极小值，因此该题目求的是极值影响的范围区间的所有包含该极值的子区间和与该极值的乘积的和。区间的范围可以通过单调栈求解，包含极值的子区间可以通过前缀和实现，而所有包含该极值的子区间的和与该极值乘积的和，通过公式求和，确认为前缀和的前缀和。 在范围 [L,R][L,R] 内的所有子数组的元素和的和可以表示为 $$\\sum_{r=i+1}^{R+1}\\sum_{l=L}^{i}s[r] - s[l]$$ 通过变化求和可得 $$(i - L + 1)\\sum_{r=i+1}^{R+1}s[r] - (R- i +1)\\sum_{l=L}^is[l]$$ class Solution { public int totalStrength(int[] strength) { final var mod = (int) 1e9 + 7; var n = strength.length; var left = new int[n]; // left[i] 为左侧严格小于 strength[i] 的最近元素位置（不存在时为 -1） var right = new int[n]; // right[i] 为右侧小于等于 strength[i] 的最近元素位置（不存在时为 n） Arrays.fill(right, n); var st = new ArrayDeque\u003cInteger\u003e(); for (var i = 0; i \u003c n; i++) { while (!st.isEmpty() \u0026\u0026 strength[st.peek()] \u003e= strength[i]) right[st.pop()] = i; left[i] = st.isEmpty() ? -1 : st.peek(); st.push(i); } var s = 0L; // 前缀和 var ss = new int[n + 2]; // 前缀和的前缀和 for (var i = 1; i \u003c= n; ++i) { s += strength[i - 1]; ss[i + 1] = (int) ((ss[i] + s) % mod); // 注意取模后，下面计算两个 ss 相减，结果可能为负 } var ans = 0L; for (var i = 0; i \u003c n; ++i) { int l = left[i] + 1, r = right[i] - 1; // [l,r] 左闭右闭 var tot = ((long) (i - l + 1) * (ss[r + 2] - ss[i + 1]) - (long) (r - i + 1) * (ss[i + 1] - ss[l])) % mod; ans = (ans + strength[i] * tot) % mod; // 累加贡献 } return (int) (ans + mod) % mod; // 防止算出负数 } } ","date":"2022-05-24","objectID":"/posts/%E5%8D%95%E8%B0%83%E6%A0%88.html/:3:2","tags":["单调栈","区间极值"],"title":"单调栈","uri":"/posts/%E5%8D%95%E8%B0%83%E6%A0%88.html/"},{"categories":["算法"],"content":"参考资料 1856. 子数组最小乘积的最大值 2281. 巫师的总力量和 单调栈 + 前缀和的前缀和（Python/Java/C++/Go） 【灵茶山艾府】第 294 场力扣周赛讲题 + 算法练习方法 ","date":"2022-05-24","objectID":"/posts/%E5%8D%95%E8%B0%83%E6%A0%88.html/:4:0","tags":["单调栈","区间极值"],"title":"单调栈","uri":"/posts/%E5%8D%95%E8%B0%83%E6%A0%88.html/"},{"categories":["linux"],"content":"前言 由于课题组的服务器处于校园网内网，正常情况外网是无法通过 ssh 连接，常用解决方法有如下几种： 通过向日葵等远程软件：利用远程桌面访问校园网 frp 等内网穿透工具：将内网服务器的端口暴露至外网服务器，通过公网服务器访问 ssh 端口转发：通过 ssh 远程端口转发，建立内网与外网的 ssh 连接。 其中 ssh 端口转发相比内网穿透更为简单，而远程桌面通常太卡使用上不如终端体验。 ","date":"2022-05-20","objectID":"/posts/ssh-%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.html/:1:0","tags":["ssh"],"title":"SSH 本地端口转发和远程端口转发","uri":"/posts/ssh-%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.html/"},{"categories":["linux"],"content":"ssh 两种端口转发模式 两种转发模式都是利用跳板机进行 ssh 连接 ","date":"2022-05-20","objectID":"/posts/ssh-%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.html/:2:0","tags":["ssh"],"title":"SSH 本地端口转发和远程端口转发","uri":"/posts/ssh-%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.html/"},{"categories":["linux"],"content":"本地端口转发 本地端口转发主要用在同一个网络的情况下。比如 host1 与 host2 不能直接连接，但是 host3 可以与 host1 和 host2 连接，因此 host3 可以作为跳板机将 host1 与 host2 连接起来，在 host1 使用如下指令既可以连接至 host2 ssh -L localport:host2:targetport host3 localport 指的是本地服务器的端口，而 targetport 指的是目的服务器的端口。 具体如下： ssh -L 2233:10.51.19.11:22 username@hostname 上述指令是通过 username@hostname 跳板机，从本地端口 2233 连接至远程服务器 10.51.19.11:22 。因此该情况需要外部机器可以 ssh 连接至跳板机 ","date":"2022-05-20","objectID":"/posts/ssh-%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.html/:2:1","tags":["ssh"],"title":"SSH 本地端口转发和远程端口转发","uri":"/posts/ssh-%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.html/"},{"categories":["linux"],"content":"远程端口转发 外部端口转发实现步骤，是先将内网的端口与外网端口进行绑定，此时外网直接访问对应端口即可以访问至内网。在跳板机上 host2 输入如下指令 ssh -R host1port:host2:22 host1 上述指令将跳板机 host2 端口 22 绑定至外网端口 host1port ，此时则可以在 host1 机器则可以通过对应端口直接访问跳板机 host2 具体指令如下： ssh -R 2233:localhost:22 ubuntu@1234.1234.1234.1234 上述指令将跳板机端口 22 绑定至服务器 ubuntu@1234.1234.1234.1234 端口，并建立了 ssh 连接。此时服务器可以通过访问本地 2233 端口访问至跳板机上。 ## 远程服务器 ssh -p 2233 ubuntu@localhost 因为服务器与跳板机需要维持 ssh 连接，因此这两台机器上必须都要有 ssh 和 sshd 。 ","date":"2022-05-20","objectID":"/posts/ssh-%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.html/:2:2","tags":["ssh"],"title":"SSH 本地端口转发和远程端口转发","uri":"/posts/ssh-%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.html/"},{"categories":["linux"],"content":"ssh 其他参数 N参数，表示只连接远程主机，不打开远程shell；T参数，表示不为这个连接分配TTY。这个两个参数可以放在一起用，代表这个SSH连接只用来传数据，不执行远程操作。 f参数，表示SSH连接成功后，转入后台运行。这样一来，你就可以在不中断SSH连接的情况下，在本地shell中执行其他操作。 ","date":"2022-05-20","objectID":"/posts/ssh-%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.html/:2:3","tags":["ssh"],"title":"SSH 本地端口转发和远程端口转发","uri":"/posts/ssh-%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.html/"},{"categories":["linux"],"content":"校园网连接方式 处于校园网的内部网络中，外部机器是无法 ssh 连接至校园网的内部机器，因此本地端口转发无法实现该需求，需通过远程端口转发实现。 首先在跳板机上输入指令，将跳板机端口绑定至外网机器。 ssh -fNTR 2233:localhost:22 ubuntu@39.108.XXX.XXX 接着 ssh 连接至外部服务器，在外部服务器输入指令，连接至跳板机。username 不是服务器的用户名，而是跳板机的用户名。 ssh -p 2233 username@localhost 此时即在外网服务器已经连接上了跳板机。后续可以通过跳板机再连接至课题组的目标服务器。 当然，也可以将课题组的服务器将端口绑定至外网服务器，即忽略跳板机的存在，直接连接至课题组的服务器。 ","date":"2022-05-20","objectID":"/posts/ssh-%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.html/:3:0","tags":["ssh"],"title":"SSH 本地端口转发和远程端口转发","uri":"/posts/ssh-%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.html/"},{"categories":["linux"],"content":"参考资料 SSH原理与运用（二）：远程操作与端口转发 彻底搞懂SSH端口转发命令 SSH 端口转发 SSH 端口转发简明教程 ","date":"2022-05-20","objectID":"/posts/ssh-%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.html/:4:0","tags":["ssh"],"title":"SSH 本地端口转发和远程端口转发","uri":"/posts/ssh-%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.html/"},{"categories":["算法"],"content":"前言 差分是前缀和的相对操作，前缀和主要是用在不改变数组的情况下，相反，差分主要用在需要多次改变数组的情况下/ ","date":"2022-05-19","objectID":"/posts/%E5%B7%AE%E5%88%86.html/:1:0","tags":["差分"],"title":"差分","uri":"/posts/%E5%B7%AE%E5%88%86.html/"},{"categories":["算法"],"content":"算法基本思想 计算数组两两元素之间的差，构成差分数组，其中第一个元素取数组第一个元素的值。 $$b_i = a_i - a_{i-1}$$ 且后续可以通过差分数组的前缀和恢复数组 $$a_i = \\sum_1^i b_i$$ 当需要对某个区间的元素统一进行操作时，比如对区间 $[c, d]$的所有元素增加 k，则只需要进行如下操作： $$b_c = b_c + k$$ $$b_d = b_d - k$$ 即可以完成对区间内所有元素操作。将 $O(k)$ 的操作的时间复杂度降低至 $O(1)$ 。若存在频繁的更改区间操作时，则可以大幅降低时间复杂度。 可以将差分数组转换为前缀和数组 $$sum = \\sum_i^na_i = \\sum_{i=1}^n\\sum_{j=1}^ib_j=\\sum_{i=1}^n(n-i+1)*b_i$$ ","date":"2022-05-19","objectID":"/posts/%E5%B7%AE%E5%88%86.html/:2:0","tags":["差分"],"title":"差分","uri":"/posts/%E5%B7%AE%E5%88%86.html/"},{"categories":["算法"],"content":"代码 ","date":"2022-05-19","objectID":"/posts/%E5%B7%AE%E5%88%86.html/:3:0","tags":["差分"],"title":"差分","uri":"/posts/%E5%B7%AE%E5%88%86.html/"},{"categories":["算法"],"content":"例题一 731. 我的日程安排表 II 每次预定一个时间段，意味着那个时间段的访问次数 $+1$ ，所以判断三重预定，则只需要将该区间段 $+1$ 再统计所有区间是否有次数超过三次的，有则预定失败，删除，否则返回 $true$ 。利用 java 的 $TreeMap$ 顺序遍历既可以实现上述要求。 class MyCalendarTwo { TreeMap\u003cInteger, Integer\u003e delta; public MyCalendarTwo() { delta = new TreeMap(); } public boolean book(int start, int end) { delta.put(start, delta.getOrDefault(start, 0) + 1); delta.put(end, delta.getOrDefault(end, 0) - 1); int active = 0; for (int d: delta.values()) { active += d; if (active \u003e= 3) { delta.put(start, delta.get(start) - 1); delta.put(end, delta.get(end) + 1); // if (delta.get(start) == 0) // delta.remove(start); return false; } } return true; } } ","date":"2022-05-19","objectID":"/posts/%E5%B7%AE%E5%88%86.html/:3:1","tags":["差分"],"title":"差分","uri":"/posts/%E5%B7%AE%E5%88%86.html/"},{"categories":["算法"],"content":"例题二 732. 我的日程安排表 III 和上题类似，由于不需要判断是否成功，所以只需要将所给的区间段 $+1$ ，在顺序统计区间段的最大的访问次数。 class MyCalendarThree { TreeMap\u003cInteger, Integer\u003e map; int max = 0; public MyCalendarThree() { map = new TreeMap\u003c\u003e(); } public int book(int start, int end) { map.put(start, map.getOrDefault(start, 0) + 1); map.put(end, map.getOrDefault(end, 0) - 1); int count = 0; for (Integer value : map.values()) { count += value; max = Math.max(count , max); } return max; } } ","date":"2022-05-19","objectID":"/posts/%E5%B7%AE%E5%88%86.html/:3:2","tags":["差分"],"title":"差分","uri":"/posts/%E5%B7%AE%E5%88%86.html/"},{"categories":["算法"],"content":"上述题目的线段树解法 差分和线段树都是应用于区间更改操作的数据结构，因此也可以使用线段树解决。但题目给的范围过大，直接初始化线段树内存会爆，因此可以采用动态开点的线段树。上述两题的线段树代码如下： 例题一的线段树解法： class MyCalendarTwo { class Node { int ls, rs, add, max; } int N = (int)1e9, M = 120010, cnt = 1; Node[] tr = new Node[M]; void update(int u, int lc, int rc, int l, int r, int v) { if (l \u003c= lc \u0026\u0026 rc \u003c= r) { tr[u].add += v; tr[u].max += v; return ; } lazyCreate(u); pushdown(u); int mid = lc + rc \u003e\u003e 1; if (l \u003c= mid) update(tr[u].ls, lc, mid, l, r, v); if (r \u003e mid) update(tr[u].rs, mid + 1, rc, l, r, v); pushup(u); } int query(int u, int lc, int rc, int l, int r) { if (l \u003c= lc \u0026\u0026 rc \u003c= r) return tr[u].max; lazyCreate(u); pushdown(u); int mid = lc + rc \u003e\u003e 1, ans = 0; if (l \u003c= mid) ans = Math.max(ans, query(tr[u].ls, lc, mid, l, r)); if (r \u003e mid) ans = Math.max(ans, query(tr[u].rs, mid + 1, rc, l, r)); return ans; } void lazyCreate(int u) { if (tr[u] == null) tr[u] = new Node(); if (tr[u].ls == 0) { tr[u].ls = ++cnt; tr[tr[u].ls] = new Node(); } if (tr[u].rs == 0) { tr[u].rs = ++cnt; tr[tr[u].rs] = new Node(); } } void pushup(int u) { tr[u].max = Math.max(tr[tr[u].ls].max, tr[tr[u].rs].max); } void pushdown(int u) { tr[tr[u].ls].add += tr[u].add; tr[tr[u].rs].add += tr[u].add; tr[tr[u].ls].max += tr[u].add; tr[tr[u].rs].max += tr[u].add; tr[u].add = 0; } public boolean book(int start, int end) { if (query(1, 1, N + 1, start + 1, end) \u003e= 2) return false; update(1, 1, N + 1, start + 1, end, 1); return true; } } 例题二的线段树解法： class MyCalendarThree { class Node { int ls, rs, add, max; } int N = (int)1e9, M = 4 * 400 * 20, cnt = 1; Node[] tr = new Node[M]; void update(int u, int lc, int rc, int l, int r, int v) { if (l \u003c= lc \u0026\u0026 rc \u003c= r) { tr[u].add += v; tr[u].max += v; return ; } lazyCreate(u); pushdown(u); int mid = lc + rc \u003e\u003e 1; if (l \u003c= mid) update(tr[u].ls, lc, mid, l, r, v); if (r \u003e mid) update(tr[u].rs, mid + 1, rc, l, r, v); pushup(u); } int query(int u, int lc, int rc, int l, int r) { if (l \u003c= lc \u0026\u0026 rc \u003c= r) return tr[u].max; lazyCreate(u); pushdown(u); int mid = lc + rc \u003e\u003e 1, ans = 0; if (l \u003c= mid) ans = Math.max(ans, query(tr[u].ls, lc, mid, l, r)); if (r \u003e mid) ans = Math.max(ans, query(tr[u].rs, mid + 1, rc, l, r)); return ans; } void lazyCreate(int u) { if (tr[u] == null) tr[u] = new Node(); if (tr[u].ls == 0) { tr[u].ls = ++cnt; tr[tr[u].ls] = new Node(); } if (tr[u].rs == 0) { tr[u].rs = ++cnt; tr[tr[u].rs] = new Node(); } } void pushdown(int u) { tr[tr[u].ls].add += tr[u].add; tr[tr[u].rs].add += tr[u].add; tr[tr[u].ls].max += tr[u].add; tr[tr[u].rs].max += tr[u].add; tr[u].add = 0; } void pushup(int u) { tr[u].max = Math.max(tr[tr[u].ls].max, tr[tr[u].rs].max); } public int book(int start, int end) { update(1, 1, N + 1, start + 1, end, 1); return query(1, 1, N + 1, 1, N + 1); } } ","date":"2022-05-19","objectID":"/posts/%E5%B7%AE%E5%88%86.html/:3:3","tags":["差分"],"title":"差分","uri":"/posts/%E5%B7%AE%E5%88%86.html/"},{"categories":["算法"],"content":"总结 差分的适用情况与线段树、柱状数组情况类似，但代码更加简洁。差分难点主要在和其他算法一起结合使用，而不是单独的使用差分思想。 ","date":"2022-05-19","objectID":"/posts/%E5%B7%AE%E5%88%86.html/:4:0","tags":["差分"],"title":"差分","uri":"/posts/%E5%B7%AE%E5%88%86.html/"},{"categories":["算法"],"content":"参考资料 前缀和 \u0026 差分 浅谈差分和树上差分算法的基本应用 小而美的算法技巧：差分数组 731. 我的日程安排表 II 732. 我的日程安排表 III 【宫水三叶】线段树（动态开点）运用题 【宫水三叶】线段树（动态开点）运用题 ","date":"2022-05-19","objectID":"/posts/%E5%B7%AE%E5%88%86.html/:5:0","tags":["差分"],"title":"差分","uri":"/posts/%E5%B7%AE%E5%88%86.html/"},{"categories":["算法"],"content":"前言 二分查找一般是用来在有序序列中查找某个范围的数据，通过不断缩小范围来求解，但也可以搭配其他算法来求解其他问题。 ","date":"2022-05-18","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html/:1:0","tags":["二分查找"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html/"},{"categories":["算法"],"content":"二分搜索问题 这是学习二分查找时，解决的最基本的问题。求解有序数组小于等于 target 的最大值 public int binarySearch(int[] nums, int left, int right, int taget){ while(left \u003c right){ int mid = (left + right) / 2; if(nums[mid] \u003e= target){ right = mid; }else{ left = mid+1; } } return left; } ","date":"2022-05-18","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html/:2:0","tags":["二分查找"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html/"},{"categories":["算法"],"content":"其他问题 ","date":"2022-05-18","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html/:3:0","tags":["二分查找"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html/"},{"categories":["算法"],"content":"k 值的问题 668. 乘法表中第k小的数 题目中，需要求解乘法表中第 k 大的值。由于乘法表的数据范围过大，直接使用数组存储的化，会导致内存溢出，而计算一个数大于等于乘法表的数字的数量则相对简单，因此可以通过二分查找进行搜索。 乘法表中的某一行数据小于等于该数个个数为：$min(\\frac{x}{i}, n)$ ，其中 $i$ 表示行数，且第 $i$ 行都是 $i$ 的倍数。 有由于当 $i \u003c \\frac{x}{n}$ 时，$\\frac{x}{i} \u003e n$ ，故可以得到如下计算公式 $$\\lfloor\\frac{x}{n}\\rfloor*n + \\sum_{\\frac{x}{n} + 1}^{m}\\lfloor\\frac{x}{i}\\rfloor$$ class Solution { public int findKthNumber(int m, int n, int k) { int left = 1, right = m * n; while (left \u003c right) { int x = left + (right - left) / 2; int count = x / n * n; for (int i = x / n + 1; i \u003c= m; ++i) { count += x / i; } if (count \u003e= k) { right = x; } else { left = x + 1; } } return left; } } ","date":"2022-05-18","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html/:3:1","tags":["二分查找"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html/"},{"categories":["算法"],"content":"可行性问题 Cable master 有 N 条绳子，他们的长度分为 L_i。如果从中切割出 K 条长度相同的绳子的话，则 K 条绳子的每条最长能多长。 该问题看似与二分查找无关。但从最后的结果来看，若长度越长，则必然导致 K 条数量不够，因此可以通过二分查找来判断长度 $l$ 是否可以满足获取 K 条长度相同的绳子。 public void solve(int[] lengths, int k){ int max = lengths[0]; for(int len: lengths){ max = Math.max(max, len); } int left = 0; int right = max; while(left \u003c right){ int mid = (left + right) / 2; int count = 0; for(int len : lengths){ count += len / mid; } if(count \u003e= k){ left = mid; }else{ right= mid + 1; } } return left; } ","date":"2022-05-18","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html/:3:2","tags":["二分查找"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html/"},{"categories":["算法"],"content":"总结 以上问题可以使用二分查找来解决问题，通常都是其解都是 ”单向“ 的。这个单向指的是解的结果影响的方向。比如对于 k 值问题，若解增大时，则必然导致小于等于该数的数量非严格递增。而对于可行性问题来说，若解的结果越大，则获取的绳子的数量必然是非严格递减。 ","date":"2022-05-18","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html/:4:0","tags":["二分查找"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html/"},{"categories":["算法"],"content":"参考资料 668. 乘法表中第k小的数 Cable master ","date":"2022-05-18","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html/:5:0","tags":["二分查找"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html/"},{"categories":["Java"],"content":"前言 排序算法是算法中的基础，也是集合和数组中最为常用的操作之一 ","date":"2022-05-16","objectID":"/posts/java-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.html/:1:0","tags":["排序","算法"],"title":"Java 排序算法底层实现解析","uri":"/posts/java-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.html/"},{"categories":["Java"],"content":"Arrays.sort 排序算法 ","date":"2022-05-16","objectID":"/posts/java-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.html/:2:0","tags":["排序","算法"],"title":"Java 排序算法底层实现解析","uri":"/posts/java-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.html/"},{"categories":["Java"],"content":"基本数据类型 对于基本数据类型来说，底层实现都是通过双轴快速排序类的排序实现。虽然类叫双轴快速排序，但根据数组的长度，分别使用不同的排序算法。 当 int、long 类型数组长度小于 INSERTION_SORT_THRESHOLD (47) 长度时，使用插入排序，大于 47 但小于 QUICKSORT_THRESHOLD (286) 长度时，使用双轴快速排序。当长度大于 286 时，则根据数组情况判断是否进行双轴快速排序还是 TimeSort 归并排序。 byte、short、char 他们的取值范围有限，使用计数排序占用的空间也不过256/65536个单位，只要排序的数量不是特别少（有一个计数排序阈值，低于这个阈值的话就没有不要用空间换时间了），都应使用计数排序 float double 则还需要根据数值情况进行数据选择 引用类型 若是引用类型，包括包装类型，都采用 ComparableTimSort.sort 排序（如果配置了 Arrays.LegacyMergeSort.userRequested 则使用传统的归并排序）。 ComparableTimSort.sort 排序数组长如小于 32 时，则使用二分查找优化版的插入排序 binarySort ，否则则使用插入排序和归并排序（优化版的归并排序）的结合体 TimeSort 排序，二者算法都可以保证排序是稳定的。 ","date":"2022-05-16","objectID":"/posts/java-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.html/:2:1","tags":["排序","算法"],"title":"Java 排序算法底层实现解析","uri":"/posts/java-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.html/"},{"categories":["Java"],"content":"Collection.sort(Comparator\u003c? super E\u003e c) 集合都继承并实现了 sort 方法，因为集合存储的元素都是引用类型，故需要提供比较方法进行排序。 该方法首先将集合通过 toArray(T[]) 将集合转换为数组，在调用 Arrays.sort 进行排序，最后将排序好的数据t通过迭代器一一复制给集合。 ","date":"2022-05-16","objectID":"/posts/java-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.html/:3:0","tags":["排序","算法"],"title":"Java 排序算法底层实现解析","uri":"/posts/java-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.html/"},{"categories":["Java"],"content":"为什么采用多种排序算法 对于基本数据类型，稳定性没有意义，所以它可以使用不稳定的快排（当然它也使用了归并排序） 而对于对象类型，稳定性是比较重要的，因为对象相等的判断比较复杂，我们无法寄希望于每个程序员都会重写准确的equal方法，故而稳妥起见，最好相等对象尽量保持排序前的顺序，故而我们使用都是稳定算法的归并排序和插入排序结合而成的TimSort算法。 另外一个原因是归并排序的比较次数比快排少，移动（对象引用的移动）次数比快排多，而对于对象来说，比较是相对耗时的操作，所以它不适合使用快排。 ","date":"2022-05-16","objectID":"/posts/java-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.html/:4:0","tags":["排序","算法"],"title":"Java 排序算法底层实现解析","uri":"/posts/java-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.html/"},{"categories":["Java"],"content":"参考资料 让面试官满意的排序算法（图文解析） Collections.sort()源码分析(基于JAVA8) JAVA内置排序Arrays.sort实现简述 ","date":"2022-05-16","objectID":"/posts/java-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.html/:5:0","tags":["排序","算法"],"title":"Java 排序算法底层实现解析","uri":"/posts/java-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.html/"},{"categories":["算法"],"content":"前言 查找数组中的重复数据，是非常经典的算法题。故总结一下查找重复数据的各种算法实现。 ","date":"2022-05-08","objectID":"/posts/%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE.html/:1:0","tags":["leetcode"],"title":"重复数据查找","uri":"/posts/%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE.html/"},{"categories":["算法"],"content":"算法 ","date":"2022-05-08","objectID":"/posts/%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE.html/:2:0","tags":["leetcode"],"title":"重复数据查找","uri":"/posts/%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE.html/"},{"categories":["算法"],"content":"题型一 题目：在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 方法一 利用位，因为其他数字都出现三次，故对应的位上 $1$ 的个数都是 $3$ 的倍数，而出现一次的数字，则对 $3$ 取余结果为 $1$ 。 class Solution { public int singleNumber(int[] nums) { int ans = 0; for (int i = 0; i \u003c 32; ++i) { int total = 0; for (int num: nums) { total += ((num \u003e\u003e i) \u0026 1); } if (total % 3 != 0) { ans |= (1 \u003c\u003c i); } } return ans; } } 方法二 方法一过程优化，根据位运算结果进行优化 class Solution { public int singleNumber(int[] nums) { int a = 0, b = 0; for (int num : nums) { int aNext = (~a \u0026 b \u0026 num) | (a \u0026 ~b \u0026 ~num), bNext = ~a \u0026 (b ^ num); a = aNext; b = bNext; } return b; } } 方法三 方法二再优化 class Solution { public int singleNumber(int[] nums) { int a = 0, b = 0; for (int num : nums) { b = ~a \u0026 (b ^ num); a = ~b \u0026 (a ^ num); } return b; } } ","date":"2022-05-08","objectID":"/posts/%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE.html/:2:1","tags":["leetcode"],"title":"重复数据查找","uri":"/posts/%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE.html/"},{"categories":["算法"],"content":"题型二 给你一个长度为 $n$ 的整数数组 nums ，其中 nums 的所有整数都在范围 $[1, n]$ 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回。 方法一 利用交换，将数据元素交换至索引对应的位置。后遍历数组，若索引对应的元素不是该值，则表面元素出现重复。 class Solution { public List\u003cInteger\u003e findDuplicates(int[] nums) { int n = nums.length; for (int i = 0; i \u003c n; ++i) { while (nums[i] != nums[nums[i] - 1]) { swap(nums, i, nums[i] - 1); } } List\u003cInteger\u003e ans = new ArrayList\u003cInteger\u003e(); for (int i = 0; i \u003c n; ++i) { if (nums[i] - 1 != i) { ans.add(nums[i]); } } return ans; } } 方法二 利用取反映射，因为数组元素固定范围，将元素值对应的索引位置进行取反，相同的元素对应的索引位置相同，若对应索引数据是正的，则是第一次映射，反之，则彼岸面已经映射过一次，即为重复元素对应的索引位置。 class Solution { public List\u003cInteger\u003e findDuplicates(int[] nums) { int n = nums.length; List\u003cInteger\u003e ans = new ArrayList\u003cInteger\u003e(); for (int i = 0; i \u003c n; ++i) { int x = Math.abs(nums[i]); if (nums[x - 1] \u003e 0) { nums[x - 1] = -nums[x - 1]; } else { ans.add(x); } } return ans; } } ","date":"2022-05-08","objectID":"/posts/%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE.html/:2:2","tags":["leetcode"],"title":"重复数据查找","uri":"/posts/%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE.html/"},{"categories":["算法"],"content":"参考 剑指 Offer 56 - II. 数组中数字出现的次数 II 442. 数组中重复的数据 ","date":"2022-05-08","objectID":"/posts/%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE.html/:3:0","tags":["leetcode"],"title":"重复数据查找","uri":"/posts/%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE.html/"},{"categories":["Python"],"content":"前言 使用 python 刷算法时，记录一些常用的数据结构 ","date":"2022-05-06","objectID":"/posts/python-%E4%B8%AD%E5%B8%B8%E7%94%A8%E8%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:1:0","tags":["数据结构","Python"],"title":"Python 中常用而数据结构","uri":"/posts/python-%E4%B8%AD%E5%B8%B8%E7%94%A8%E8%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Python"],"content":"数据结构 ","date":"2022-05-06","objectID":"/posts/python-%E4%B8%AD%E5%B8%B8%E7%94%A8%E8%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:2:0","tags":["数据结构","Python"],"title":"Python 中常用而数据结构","uri":"/posts/python-%E4%B8%AD%E5%B8%B8%E7%94%A8%E8%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Python"],"content":"Array-Like(List/Tuple) python 内置没有 array 数组（有一个array 模块，存在一个 array 类），但提供了 list 列表和 tuple 元组，二者底层都是通过数组实现。list 为长度可变数组，而 tuple 为长度固定的数组，一般来说 list 更加常用。列表 没有 isempty 判空方法，通过 if list: 语句直接判断即可，若存在元素则返回 True ，否则返回 False。 列表/数组的内置方法： append(val) ： 在列表末尾出添加元素 clear() ： 清空列表 copy() ： 数组复制 count(val) ：统计列表中 val 出现的次数 extend(iterable) : 将可迭代的对象逐一添加至列表末尾 index(val) : 返回列表中 val 第一次出现的索引，不存在则抛出异常 insert(index, val) : 在指定索引 index 位置插入val pop(index) : 移除 index 位置的元素，默认索引为 0 remove(val) : 移除列表中 val 第一次出现的元素，若不存在，则抛出异常 reverse() : 列表反转，原地反转 sort() : 列表自然排序，原地排序 ","date":"2022-05-06","objectID":"/posts/python-%E4%B8%AD%E5%B8%B8%E7%94%A8%E8%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:2:1","tags":["数据结构","Python"],"title":"Python 中常用而数据结构","uri":"/posts/python-%E4%B8%AD%E5%B8%B8%E7%94%A8%E8%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Python"],"content":"LinkedList-Like(Deque) python 内置的 LinkedList 链表有 Deque 双端队列。Deque 的底层实现为链表，属于 collections 模块下的类，双端队列没有 isempty 判空方法，通过 if deque: 语句直接判断即可，若存在元素则返回 True ，否则返回 False。 双端队列的常用方法： append(val) : 添加到双端列表的末端 appendleft(val) : 添加到双端队列的头部 clear() ： 清除双端队列 copy() : 拷贝双端队列，浅拷贝 count(val) : 统计双端队列 val 元素出现的次数 extend(iterable) : 将可迭代的对象逐一添加至双端队列的末尾 extendleft(iterable) : 将可迭代的对象逐一添加至双端队列的头部 index(val) : 返回双端列表从头部至尾部第一次出现 val 的索引，不存在则抛出异常 insert(index, val) : 在索引位置出插入元素 pop() : 删除双端队列的尾部的一个元素，队列为空则抛出异常 popleft() 删除双端队列头部的一个元素，队列为空则抛出异常 remove(val) ： 从头部至尾部删除双端队列 val 第一次出现的元素，不存在则抛出异常 reverse() : 原地逆序 rotate() : 右循环 n 步，即删除尾部元素，添加至头部 ","date":"2022-05-06","objectID":"/posts/python-%E4%B8%AD%E5%B8%B8%E7%94%A8%E8%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:2:2","tags":["数据结构","Python"],"title":"Python 中常用而数据结构","uri":"/posts/python-%E4%B8%AD%E5%B8%B8%E7%94%A8%E8%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Python"],"content":"Set python 内置 set 集合，属于无序集合，创建集合可以使用花括号或者 set()，但是创建空集合不可以使用花括号，空的花括号表示字典。集合 没有 isempty 判空方法，通过 if deque: 语句直接判断即可，若存在元素则返回 True ，否则返回 False。 集合常用方法： copy() : 集合拷贝，浅拷贝 issubset(other) ：判断集合元素是否都在 other 之中 isdisjoint(other) : 判断集合与 other 是否有交集 add(val) ： 将 val 元素添加至集合当中 remove(val) ：删除集合中 val 元素，不存在则抛出异常 pop() : 返回集合中的任意一个元素，为集合为空，则抛出异常 clear() : 清空集合 ","date":"2022-05-06","objectID":"/posts/python-%E4%B8%AD%E5%B8%B8%E7%94%A8%E8%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:2:3","tags":["数据结构","Python"],"title":"Python 中常用而数据结构","uri":"/posts/python-%E4%B8%AD%E5%B8%B8%E7%94%A8%E8%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Python"],"content":"HashTable(Dict) python 内置字典为哈希表，为无序哈希表。字典 没有 isempty 判空方法，通过 if deque: 语句直接判断即可，若存在元素则返回 True ，否则返回 False。 字典常用方法： del dict[key] : 删除字典中 key 对应的键值对，不存在 key 在抛出异常 keys() : 返回字典 key 的新视图 item() ： 返回字典 key-val 的新视图 values(): 返回字典 values 的新视图 pop(key[, default]) : 删除字典的中 key 的键值对，否则返回 default，没有指定 default 则抛出异常 reversed(dict) : 逆序获取字典的健的迭代器， 这是 reversed(d.keys()) 的快捷方式。 ","date":"2022-05-06","objectID":"/posts/python-%E4%B8%AD%E5%B8%B8%E7%94%A8%E8%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:2:4","tags":["数据结构","Python"],"title":"Python 中常用而数据结构","uri":"/posts/python-%E4%B8%AD%E5%B8%B8%E7%94%A8%E8%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["算法"],"content":"前言 阿橋问题（有时也称为约瑟夫斯置换），是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。 人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，处刑下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。 ","date":"2022-05-04","objectID":"/posts/%E7%BA%A6%E7%91%9F%E7%8E%AF.html/:1:0","tags":["约瑟环"],"title":"约瑟环","uri":"/posts/%E7%BA%A6%E7%91%9F%E7%8E%AF.html/"},{"categories":["算法"],"content":"算法 ","date":"2022-05-04","objectID":"/posts/%E7%BA%A6%E7%91%9F%E7%8E%AF.html/:2:0","tags":["约瑟环"],"title":"约瑟环","uri":"/posts/%E7%BA%A6%E7%91%9F%E7%8E%AF.html/"},{"categories":["算法"],"content":"基本内容 用 $f(n, k)$ 表示 $n$ 个人，每 $k$ 个淘汰一人，则可以得到如下递归式 $$f(n, k) = (f(n - 1, k) + k - 1) \\mod n + 1$$ 当 n = 1 时，显然 1 获胜 当 n = k 时，则在一个人 $k^{}$ 离开之后，剩下 n - 1 个人，且从 $（k + 1）^{}$ 之后开始计数。所以可以递推可得$f(n, k) = (f(n - 1, k) + k - 1) \\mod n + 1$ 。其中最后 $+1$ 表示获胜的顺序的下一位（编号从 1 开始） ","date":"2022-05-04","objectID":"/posts/%E7%BA%A6%E7%91%9F%E7%8E%AF.html/:2:1","tags":["约瑟环"],"title":"约瑟环","uri":"/posts/%E7%BA%A6%E7%91%9F%E7%8E%AF.html/"},{"categories":["算法"],"content":"代码 1823. 找出游戏的获胜者 class Solution { public int findTheWinner(int n, int k) { int ans = 1; int i = 2; while(i \u003c= n){ ans = (ans + k - 1) % i + 1; i += 1; } return ans; } } ","date":"2022-05-04","objectID":"/posts/%E7%BA%A6%E7%91%9F%E7%8E%AF.html/:2:2","tags":["约瑟环"],"title":"约瑟环","uri":"/posts/%E7%BA%A6%E7%91%9F%E7%8E%AF.html/"},{"categories":["算法"],"content":"参考 阿橋问题 约瑟夫环——公式法（递推公式 ","date":"2022-05-04","objectID":"/posts/%E7%BA%A6%E7%91%9F%E7%8E%AF.html/:3:0","tags":["约瑟环"],"title":"约瑟环","uri":"/posts/%E7%BA%A6%E7%91%9F%E7%8E%AF.html/"},{"categories":["Java"],"content":"前言 java 8 增加的一个重大特性，就是 lambda 表达式了。lambda 作为 java 的语法糖，提供了更加简洁的语法书写，减少了使用匿名类带来的代码冗余性。 在 java 8 之前，如果需要使用一个功能函数接口，必须通过类来实现，因为，在 java 当中，方法是依托于类存在的，这也导致 java 不能实现函数式编程。而在 java 8 ，之后，引入了函数式接口、lambda 表达式和方法引用，在一定程度上，将函数上升为 “一等公民”。 ","date":"2022-05-01","objectID":"/posts/lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F.html/:1:0","tags":["lambda"],"title":"lambda 表达式","uri":"/posts/lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F.html/"},{"categories":["Java"],"content":"基本使用 java 的 lambda 表达式必须结合函数式接口来使用。函数式接口是指该接口只有一个抽象方法（可以有多个方法，但必须有一个为实现，因为 java 8 接口中的方法可以使用默认实现），且该接口最好使用 @FunctionalInterface 注解标注。 lambda 表达式的基本书写形式如下： (T param1, T param2) -\u003e {operator(param1, param2)} lambda 表达式使用样例 interface Description { String brief(); } interface Body { String detailed(String head); } interface Multi { String twoArg(String head, Double d); } public class LambdaExpressions { static Body bod = h -\u003e h + \" No Parens!\"; // [1] static Body bod2 = (h) -\u003e h + \" More details\"; // [2] static Description desc = () -\u003e \"Short info\"; // [3] static Multi mult = (h, n) -\u003e h + n; // [4] static Description moreLines = () -\u003e { // [5] System.out.println(\"moreLines()\"); return \"from moreLines()\"; }; public static void main(String[] args) { System.out.println(bod.detailed(\"Oh!\")); System.out.println(bod2.detailed(\"Hi!\")); System.out.println(desc.brief()); System.out.println(mult.twoArg(\"Pi! \", 3.14159)); System.out.println(moreLines.brief()); } } 937. 重新排列日志文件 解题代码使用 lambda 表达式 class Solution { public String[] reorderLogFiles(String[] logs) { Arrays.sort(logs, (log1, log2)-\u003e{ String[] split1 = log1.split(\" \",2); String[] split2 = log2.split(\" \",2); boolean isDigit1 = Character.isDigit(split1[1].charAt(0)); boolean isDigit2 = Character.isDigit(split2[1].charAt(0)); if (!isDigit1 \u0026\u0026 !isDigit2){ int cmp = split1[1].compareTo(split2[1]); if (cmp !=0) return cmp; return split1[0].compareTo(split2[0]); } return isDigit1 ? (isDigit2 ? 0:1) : -1; }); return logs; } } 函数调用的 lambda 表达式 class Solution { public String[] reorderLogFiles(String[] logs) { int length = logs.length; Pair[] arr = new Pair[length]; for (int i = 0; i \u003c length; i++) { arr[i] = new Pair(logs[i], i); } Arrays.sort(arr, (a, b) -\u003e logCompare(a, b)); String[] reordered = new String[length]; for (int i = 0; i \u003c length; i++) { reordered[i] = arr[i].log; } return reordered; } public int logCompare(Pair pair1, Pair pair2) { String log1 = pair1.log, log2 = pair2.log; int index1 = pair1.index, index2 = pair2.index; String[] split1 = log1.split(\" \", 2); String[] split2 = log2.split(\" \", 2); boolean isDigit1 = Character.isDigit(split1[1].charAt(0)); boolean isDigit2 = Character.isDigit(split2[1].charAt(0)); if (isDigit1 \u0026\u0026 isDigit2) { return index1 - index2; } if (!isDigit1 \u0026\u0026 !isDigit2) { int sc = split1[1].compareTo(split2[1]); if (sc != 0) { return sc; } return split1[0].compareTo(split2[0]); } return isDigit1 ? 1 : -1; } } class Pair { String log; int index; public Pair(String log, int index) { this.log = log; this.index = index; } } ","date":"2022-05-01","objectID":"/posts/lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F.html/:2:0","tags":["lambda"],"title":"lambda 表达式","uri":"/posts/lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F.html/"},{"categories":["Java"],"content":"注意事项 如果编译器可以根据接口类型推断出参数类型，则 lambda 表达式可以省略参数的类型。所以 lambda 表达式是运行时才确认的，故 lambda 表达式使用的数据必须是不可以变更的（final 类型），即是闭包的。 lambda 表达式如果只有一个参数时，可以省略参数的括号（不建议）。 在 lambda 表达式中使用的关键字 this ，表示创建 lambda 表达式方法的 this 参数。 lambda 表达式内如果存在分支返回值时，则另外的分支必须也存在返回值，否则不合法。 尽量将 lambda 表达式看作为一个函数，而不是一个对象。 如果只有一条语句， 则大括号可以省略，且不需要 return 关键字，编译器会自动返回表达式值。如果使用大括号，则必须使用 return 返回表达式的值。返回值也函数式接口返回类型相同 lambda 表达式后半段可以使用函数调用代替大括号内容 ","date":"2022-05-01","objectID":"/posts/lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F.html/:3:0","tags":["lambda"],"title":"lambda 表达式","uri":"/posts/lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F.html/"},{"categories":["Java"],"content":"参考资料 高阶函数和Java的Lambda Java中的函数式编程（三）lambda表达式 第十三章 函数式编程 937. 重新排列日志文件 ","date":"2022-05-01","objectID":"/posts/lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F.html/:4:0","tags":["lambda"],"title":"lambda 表达式","uri":"/posts/lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F.html/"},{"categories":["Java"],"content":"前言 Stream 是 java 8 增加的新特性。流提供了一种可以让我们在更高的概念级别上指定计算任务的数据视图，通过流可以说明我们想要完成什么任务，而不是说明如何去实现它，操作的实现调度由具体实现解决。 +--------------------+ +------+ +------+ +---+ +-------+ | stream of elements +-----\u003e |filter+-\u003e |sorted+-\u003e |map+-\u003e |collect| +--------------------+ +------+ +------+ +---+ +-------+ ","date":"2022-04-30","objectID":"/posts/java-stream.html/:1:0","tags":["Stream"],"title":"Java Stream","uri":"/posts/java-stream.html/"},{"categories":["Java"],"content":"基本使用 ","date":"2022-04-30","objectID":"/posts/java-stream.html/:2:0","tags":["Stream"],"title":"Java Stream","uri":"/posts/java-stream.html/"},{"categories":["Java"],"content":"流的创建 集合可以通过 Collection 接口中的 stram 或者 parallelStram 方法中创建，前者是串行流，后者是并行流。 list.stream(); set.paralletStream(); 数组可以通过 Steam 类中的静态方法 Stream.of 方法创建。注意，和 Array.asList 方法一样，如果使用基本类型数组创建的流的类型为基本类型数组类型，使用包装类数组转换的流的类型为包装类 int[] arr = {1, 2}; Stream\u003cint[]\u003e stream1 = Stream.of(arr); Integer arr2 = {1, 2}; Stream\u003cInteger\u003e stream1 = Stream.of(arr2); ","date":"2022-04-30","objectID":"/posts/java-stream.html/:2:1","tags":["Stream"],"title":"Java Stream","uri":"/posts/java-stream.html/"},{"categories":["Java"],"content":"过滤 使用 filter 方法对了流中的元素进行过滤，filter 方法的引元是 Predicate\u003cT\u003e ，即从 T 到 boolean 的函数。 list.stream().filter(num -\u003e num \u003e 1); ","date":"2022-04-30","objectID":"/posts/java-stream.html/:2:2","tags":["Stream"],"title":"Java Stream","uri":"/posts/java-stream.html/"},{"categories":["Java"],"content":"映射 通过 map 方法将原有元素按照映射规则映射到需要的值。即通过函数进行元素转换，可以通过函数引用或者 lambda 表达式完成。 ","date":"2022-04-30","objectID":"/posts/java-stream.html/:2:3","tags":["Stream"],"title":"Java Stream","uri":"/posts/java-stream.html/"},{"categories":["Java"],"content":"部分抽取 抽取前段部分 通过 limit 方法抽取前 n 个元素，如果流长度小于 n，则提前终止。 list.stream().limit(100) 抽取后段部分 通过 skip 方法跳过前 n 个元素，获取后段部分流元素 list.stream().skip(100) 抽取满足条件的元素 通过 takeWhile 方法，获取满足条件的元素 list.stream().takeWhile(s -\u003e \"1234567890\".contains(s)); 丢弃满足条件的元素 通过 dropWhile 方法，丢弃满足条件的元素 list.stream().dropWhile(s -\u003e \"1234567890\".contains(s)); ","date":"2022-04-30","objectID":"/posts/java-stream.html/:2:4","tags":["Stream"],"title":"Java Stream","uri":"/posts/java-stream.html/"},{"categories":["Java"],"content":"排序 stream 提供了 sorted 方法进行排序，有默认提供的排序的方法（流中的元素必须是 Comparable），也可以提供一个 Comparator 进行排序。排序会产生一个新的流。 list.stream.sorted(Comparator.comparing(String::length).reversed()); ","date":"2022-04-30","objectID":"/posts/java-stream.html/:2:5","tags":["Stream"],"title":"Java Stream","uri":"/posts/java-stream.html/"},{"categories":["Java"],"content":"遍历 stream 提供了 forEach 方法对流的元素进行遍历。 list.steam.forEach(System.out::println) ","date":"2022-04-30","objectID":"/posts/java-stream.html/:2:6","tags":["Stream"],"title":"Java Stream","uri":"/posts/java-stream.html/"},{"categories":["Java"],"content":"简单约简 上述的基本操作只是对流进行转换和操作，最终需要获取想要的答案，则需要进行简单约简，即终结操作，将流转换为非流值。 计数 使用 count 方法统计流中的元素个数 list.stream().count(); 最值获取 max 和 min 方法它们主要用于int、double、long等基本类型上。 int max = Arrays.stream(nums).max().getAsInt(); int min = Arrays.stream(nums).min().getAsInt(); 同时也可以使用 Int(Long/Double)SummaryStatistics 类中的方法实现更多的功能。 List\u003cInteger\u003e numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); IntSummaryStatistics stats = numbers.stream().mapToInt((x) -\u003e x).summaryStatistics(); System.out.println(\"列表中最大的数 : \" + stats.getMax()); System.out.println(\"列表中最小的数 : \" + stats.getMin()); System.out.println(\"所有数之和 : \" + stats.getSum()); System.out.println(\"平均数 : \" + stats.getAverage()); ","date":"2022-04-30","objectID":"/posts/java-stream.html/:2:7","tags":["Stream"],"title":"Java Stream","uri":"/posts/java-stream.html/"},{"categories":["Java"],"content":"参考资料 Java 8 Stream ","date":"2022-04-30","objectID":"/posts/java-stream.html/:3:0","tags":["Stream"],"title":"Java Stream","uri":"/posts/java-stream.html/"},{"categories":["算法"],"content":"前言 确定有限状态自动机或确定有限自动机（英语：deterministic finite automaton, DFA）是一个能实现状态转移的自动机。对于一个给定的属于该自动机的状态和一个属于该自动机字母表的字符，它都能根据事先给定的转移函数转移到下一个状态（这个状态可以是先前那个状态)。 需要注意的是，自动机只是一个 数学模型，而 不是算法，也 不是数据结构，自动机的结构就是一张有向图。实现同一个自动机的方法有很多种，可能会有不一样的时空复杂度。 常用的自动机有 字典树，KMP 自动机，后缀自动机，回文自动机 和 序列自动机 等等 ","date":"2022-04-29","objectID":"/posts/%E8%87%AA%E5%8A%A8%E6%9C%BA.html/:1:0","tags":["自动机","算法"],"title":"自动机","uri":"/posts/%E8%87%AA%E5%8A%A8%E6%9C%BA.html/"},{"categories":["算法"],"content":"序列自动机 字符串转换整数 (atoi) 题目中要求将字符串序列转换为整数，但由于边界条件多，如果使用 if-else 完成的话，则代码过于复杂，因此可以通自动机实现 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 函数 myAtoi(string s) 的算法如下： 读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，\"123\" -\u003e 123， \"0032\" -\u003e 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−2_31, 2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2_31 的整数应该被固定为 −2_31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。 返回整数作为最终结果。 注意： 本题中的空白字符只包括空格字符 ' ' 。 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符 题目状态图如下： ","date":"2022-04-29","objectID":"/posts/%E8%87%AA%E5%8A%A8%E6%9C%BA.html/:2:0","tags":["自动机","算法"],"title":"自动机","uri":"/posts/%E8%87%AA%E5%8A%A8%E6%9C%BA.html/"},{"categories":["算法"],"content":"代码 class Solution { public int myAtoi(String str) { Automaton automaton = new Automaton(); int length = str.length(); for (int i = 0; i \u003c length; ++i) { automaton.get(str.charAt(i)); } return (int) (automaton.sign * automaton.ans); } } class Automaton { public int sign = 1; public long ans = 0; private String state = \"start\"; private Map\u003cString, String[]\u003e table = new HashMap\u003cString, String[]\u003e() {{ put(\"start\", new String[]{\"start\", \"signed\", \"in_number\", \"end\"}); put(\"signed\", new String[]{\"end\", \"end\", \"in_number\", \"end\"}); put(\"in_number\", new String[]{\"end\", \"end\", \"in_number\", \"end\"}); put(\"end\", new String[]{\"end\", \"end\", \"end\", \"end\"}); }}; public void get(char c) { state = table.get(state)[get_col(c)]; if (\"in_number\".equals(state)) { ans = ans * 10 + c - '0'; ans = sign == 1 ? Math.min(ans, (long) Integer.MAX_VALUE) : Math.min(ans, -(long) Integer.MIN_VALUE); } else if (\"signed\".equals(state)) { sign = c == '+' ? 1 : -1; } } private int get_col(char c) { if (c == ' ') { return 0; } if (c == '+' || c == '-') { return 1; } if (Character.isDigit(c)) { return 2; } return 3; } } ","date":"2022-04-29","objectID":"/posts/%E8%87%AA%E5%8A%A8%E6%9C%BA.html/:2:1","tags":["自动机","算法"],"title":"自动机","uri":"/posts/%E8%87%AA%E5%8A%A8%E6%9C%BA.html/"},{"categories":["算法"],"content":"参考资料 自动机 字符串转换整数 (atoi) Basics of Automata Theory ","date":"2022-04-29","objectID":"/posts/%E8%87%AA%E5%8A%A8%E6%9C%BA.html/:3:0","tags":["自动机","算法"],"title":"自动机","uri":"/posts/%E8%87%AA%E5%8A%A8%E6%9C%BA.html/"},{"categories":["算法"],"content":"前言 回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标，但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 回溯法简单来说就是按照深度优先的顺序，穷举所有可能性的算法，但是回溯算法比暴力穷举法更高明的地方就是回溯算法可以随时判断当前状态是否符合问题的条件，所以根据这类问题，我们有一些优化剪枝策略以及启发式搜索策略。 ","date":"2022-04-26","objectID":"/posts/%E5%9B%9E%E6%BA%AF%E6%B3%95.html/:1:0","tags":["回溯法"],"title":"回溯法","uri":"/posts/%E5%9B%9E%E6%BA%AF%E6%B3%95.html/"},{"categories":["算法"],"content":"算法实现 算法基本步骤如下： 确定终止条件。回溯法的本质就是递归，所以需要确定递归的终止条件，防止死循环。 循环回溯。循环回溯是回溯法的主要部分，该部分进行迭代-\u003e回溯，以此实现穷举，在迭代过程中可以根据需求，对部分路径进行剪枝。 17. 电话号码的字母组合 代码实现 class Solution { public List\u003cString\u003e letterCombinations(String digits) { ArrayList\u003cString\u003e ans = new ArrayList\u003c\u003e(); if(digits.length() == 0){ return ans; } ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"abc\"); list.add(\"def\"); list.add(\"ghi\"); list.add(\"jkl\"); list.add(\"mno\"); list.add(\"pqrs\"); list.add(\"tuv\"); list.add(\"wxyz\"); int size = list.size(); StringBuilder sb = new StringBuilder(); backtrack(digits, list, ans, 0, sb); return ans; } private void backtrack(String digits, ArrayList\u003cString\u003e list, ArrayList\u003cString\u003e ans, int i, StringBuilder sb) { // 终止条件 if (i == digits.length()) { ans.add(sb.toString()); return; }else{ int idx = Integer.parseInt(String.valueOf(digits.charAt(i))); String s = list.get(idx - 2); int len = s.length(); // 循环迭代 for (int j = 0; j \u003c len; j++) { sb.append(s.charAt(j)); // 迭代 backtrack(digits, list, ans, i + 1, sb); // 回溯 sb.deleteCharAt(sb.length() - 1); } } } } 39. 组合总和 代码实现 class Solution { public List\u003cList\u003cInteger\u003e\u003e combinationSum(int[] candidates, int target) { List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); int min = candidates[0]; List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); backtrack(ans, list, candidates, target, 0); return ans; } public void backtrack(List\u003cList\u003cInteger\u003e\u003e ans, List\u003cInteger\u003e list, int[] candidates, int target, int idx){ if(idx == candidates.length){ return; } if(target == 0){ ans.add(new ArrayList\u003c\u003e(list)); return; } // 查找单元素集合 backtrack(ans, list, candidates, target, idx + 1); // 查找多元素集合 if(target - candidates[idx] \u003e= 0){ list.add(candidates[idx]); backtrack(ans, list, candidates, target - candidates[idx], idx); list.remove(list.size() - 1); } } } ","date":"2022-04-26","objectID":"/posts/%E5%9B%9E%E6%BA%AF%E6%B3%95.html/:2:0","tags":["回溯法"],"title":"回溯法","uri":"/posts/%E5%9B%9E%E6%BA%AF%E6%B3%95.html/"},{"categories":["算法"],"content":"回溯法 + 去重 在某些算法的要求下，需要对结果进行去重，简单粗暴的方法就是通过 HashSet 去重，但是时间复杂度高，因为结果需要对比。也可以通过循环，对某些条件进行剪枝。 剑指 Offer II 082. 含有重复元素集合的组合 回溯法 + 循环剪枝去重 class Solution { public List\u003cList\u003cInteger\u003e\u003e combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003c\u003e(); backtrack(candidates, ans, new ArrayList\u003cInteger\u003e(), target, 0); return ans; } public void backtrack(int[] candidates, List\u003cList\u003cInteger\u003e\u003e ans, List\u003cInteger\u003e list, int target, int idx) { if (target == 0) { ans.add(new ArrayList\u003c\u003e(list)); return; } for (int i = idx; i \u003c candidates.length; i++) { if (candidates[i] \u003e target) { return; } if (i \u003e idx \u0026\u0026 candidates[i] == candidates[i - 1]) { continue; } list.add(candidates[i]); backtrack(candidates, ans, list, target - candidates[i], i + 1); list.remove(list.size() - 1); } } } ","date":"2022-04-26","objectID":"/posts/%E5%9B%9E%E6%BA%AF%E6%B3%95.html/:3:0","tags":["回溯法"],"title":"回溯法","uri":"/posts/%E5%9B%9E%E6%BA%AF%E6%B3%95.html/"},{"categories":["算法"],"content":"参考资料 五大基本算法之回溯算法 backtracking 小白带你学–回溯算法 17. 电话号码的字母组合 39. 组合总和 剑指 Offer II 082. 含有重复元素集合的组合 ","date":"2022-04-26","objectID":"/posts/%E5%9B%9E%E6%BA%AF%E6%B3%95.html/:4:0","tags":["回溯法"],"title":"回溯法","uri":"/posts/%E5%9B%9E%E6%BA%AF%E6%B3%95.html/"},{"categories":["python"],"content":"前言 记录一些 python 的基础使用 ","date":"2022-04-25","objectID":"/posts/python-%E5%9F%BA%E7%A1%80.html/:1:0","tags":["python"],"title":"Python 基础","uri":"/posts/python-%E5%9F%BA%E7%A1%80.html/"},{"categories":["python"],"content":"内容 ","date":"2022-04-25","objectID":"/posts/python-%E5%9F%BA%E7%A1%80.html/:2:0","tags":["python"],"title":"Python 基础","uri":"/posts/python-%E5%9F%BA%E7%A1%80.html/"},{"categories":["python"],"content":"常用的魔法方法 __len__() : 当使用 len 函数时，会自动调用该方法，若类没有使用该方法，则抛出异常 __getitem__() : 当使用切片、索引、for-in 循环时候，会自动调用该方法，若类实现了该方法，则可以使用索引、切片对访问类中的元素 __iter__() : 使用 for-in 循环会自动调用该方法，若类实现了该方法，则表明该类是可以迭代的 __abs__() : 使用 abs 函数会自动调用该方法 __add__() : 对类对象使用 ”+“ 运算符，会自动调用该方法，返回一个新的对象 __mul__() : 对类对象使用 “*” 运算符，会自动调用该方法，返回一个新的对象 __repr__() : 在终端直接输出对象时，调用该方法 __str__() : 使用 print 打印对象时，调用该方法。如果没有，则使用 __repr__ 方法进行替代 __bool__() ：使用 bool 函数时，会自动调用该方法，使用 if 、while 语句时，也会自动调用该方法，因为判断对象是否为真会调用 bool 函数。如果 __bool__ 方法不存在时，则调用 __len__ 方法进行判断，长度为 0 为假。默认对象都是为真 。 __iadd__() : 自增运算，当使用 += 运算符操作对象时，会自动调用该方法。若没有该方法，则会后退调用 __add__ 方法。 __call__() : 实现了该方法的类的对象，它的实例可以作为函数进行调用。 ","date":"2022-04-25","objectID":"/posts/python-%E5%9F%BA%E7%A1%80.html/:2:1","tags":["python"],"title":"Python 基础","uri":"/posts/python-%E5%9F%BA%E7%A1%80.html/"},{"categories":["python"],"content":"自增赋值 使用 += 等自增运算符时，表示原地自增。而使用 + 运算符，则生成了新的对象，并赋值。比如 a += b，则在 a 的基础上直接增加，不会生成新的变量。而 a = a + b ，则表示 a + b 生成新的对象，并将该对象的引用赋值给 a 。一般可变序列都实现了 __iadd__ 等自增运算符，不可变序列则不支持该方法。 ","date":"2022-04-25","objectID":"/posts/python-%E5%9F%BA%E7%A1%80.html/:2:2","tags":["python"],"title":"Python 基础","uri":"/posts/python-%E5%9F%BA%E7%A1%80.html/"},{"categories":["python"],"content":"序列的拼接 python 中两个列表相加时，是将两个列表合并为一个列表，合并顺序与相加顺序一致。这与 pytorch 的向量相加不一样，pytorch 两个向量相加则是对应位置值相加（按照广播原则进行）。 arr = [1, 2] out = [3] + arr print(out) ## [3, 1, 2] 使用 $*$ 运算符进行序列拼接时，若元素为引用对象的引用的话，则拼接的多个序列都指向一个对象。若发生修改，则都进行修改。 weird_board = [['_'] * 3] * 3 weird_board[1][2] = 'O' # [['_', '_', 'O'], ['_', '_', 'O'], ['_', '_', 'O']] 此时，需要使用列表推导式进行生成 board = [['_'] * 3 for i in range(3)] ","date":"2022-04-25","objectID":"/posts/python-%E5%9F%BA%E7%A1%80.html/:2:3","tags":["python"],"title":"Python 基础","uri":"/posts/python-%E5%9F%BA%E7%A1%80.html/"},{"categories":["python"],"content":"除法运算 python3 中 / 除法，两个操作数会转换为 float 类型，结果而已为 float 类型，如果需保持整数类型是，需要使用 // 运算符。 a = 10 # 死循环 while a \u003e 10: a /= 10 四舍五入 使用 round 方法对结果四舍五入 print(round(10 / 3)) # 3 取整数 舍去小数部分，只留整数部分 print(int (-7 / 6)) # 0 pirnt(round(-7 / 6)) # -1 向上取整 使用 math 库中的 ceil 方法，对结果向上取整 import math print(math.ceil(10 / 3)) # 4 取整数和小数部分 使用 math 库中的 modf 方法，取结果的整数和小数部分，结果为二元组。 import math print(math.modf(10 / 3)) # (0.3333333333333335, 3.0) 参考： Python除法：四舍五入，地板除，取整，取小数 ","date":"2022-04-25","objectID":"/posts/python-%E5%9F%BA%E7%A1%80.html/:2:4","tags":["python"],"title":"Python 基础","uri":"/posts/python-%E5%9F%BA%E7%A1%80.html/"},{"categories":["python"],"content":"nolocal 关键字 函数嵌套定义时，内部函数变量默认为局部变量，外部函数无法访问，即内部函数调用完成后销毁。若需要将内部变量提供给外部函数时，可以使用关键字 nolocal 关键字修饰 def myfunc1(): x = \"John\" def myfunc2(): nonlocal x x = \"hello\" myfunc2() return x print(myfunc1()) ","date":"2022-04-25","objectID":"/posts/python-%E5%9F%BA%E7%A1%80.html/:2:5","tags":["python"],"title":"Python 基础","uri":"/posts/python-%E5%9F%BA%E7%A1%80.html/"},{"categories":["python"],"content":"列表推导式的作用域 在 python2.* 版本中，列表推导式的变量会影响外部变量，但在 python3 中，列表推导式为局部作用域，不会影响外部变量 x = 2 dummy = [x for x in 'abc'] print(x) # 2 ","date":"2022-04-25","objectID":"/posts/python-%E5%9F%BA%E7%A1%80.html/:2:6","tags":["python"],"title":"Python 基础","uri":"/posts/python-%E5%9F%BA%E7%A1%80.html/"},{"categories":["python"],"content":"列表推导式的嵌套 列表推导式的 for 循环嵌套与书写顺序一致，生成相应的笛卡尔积结果 product = [(x, y) for x in range(3) for y in range(3,5)] # (0, 3) (0, 4) ... ","date":"2022-04-25","objectID":"/posts/python-%E5%9F%BA%E7%A1%80.html/:2:7","tags":["python"],"title":"Python 基础","uri":"/posts/python-%E5%9F%BA%E7%A1%80.html/"},{"categories":["python"],"content":"切片赋值 如果把切片放在赋值语句的左边,或把它作为 del 操作的对象,我们就可以对序列进行嫁接、切除或就地修改操作。如果赋值的对象是一个切片，那么赋值语句的右侧必须是可以迭代的对象。赋值的长度不需要一致 ","date":"2022-04-25","objectID":"/posts/python-%E5%9F%BA%E7%A1%80.html/:2:8","tags":["python"],"title":"Python 基础","uri":"/posts/python-%E5%9F%BA%E7%A1%80.html/"},{"categories":["python"],"content":"元组自增 元组是不支持自增运算的，但是元组内部的若含有可变对象时，则可以进行自增，但是自增之后因为于元组内数据发生变化，则会抛出异常。（说明自增运算不是原子操作，普通 + 则直接抛出异常，且数据不会发生变更） t = (1, 2, [30, 40]) t[2] += [50, 60] # 抛出异常，但 t 已经发生变化 print(t) # t = (1, 2, [30, 40, 50, 60]) 所以，元组内不应该放置可变元素 ","date":"2022-04-25","objectID":"/posts/python-%E5%9F%BA%E7%A1%80.html/:2:9","tags":["python"],"title":"Python 基础","uri":"/posts/python-%E5%9F%BA%E7%A1%80.html/"},{"categories":["python"],"content":"序列排序 list.sort() 会对序列原地排序，所以返回结果为 None，而内置的函数 sorted() 则会返回排序好的序列，该方法需要序列可以进行迭代，且两个方法都有两个关键字： reverse：为 True 时，进行逆序排列。 key： 一个只有一个参数的函数，该函数会应用到所有元素上，并使用结果进行排序，默认恒等函数。 ","date":"2022-04-25","objectID":"/posts/python-%E5%9F%BA%E7%A1%80.html/:2:10","tags":["python"],"title":"Python 基础","uri":"/posts/python-%E5%9F%BA%E7%A1%80.html/"},{"categories":["python"],"content":"装饰器 python 的装饰期在模块加载之后就立即执行。装饰器其实就是一个高阶函数，是一个语法糖。参数化的装饰器本质为两层嵌套函数，外层相当于装饰器工厂，根据参数返回需要的装饰器。 常用的装饰器： functools.lru_cache() 该装饰器实现了备忘的功能，并使用最近最少用策略管理缓存。 cache 装饰器不清理缓存，更快。这些在需要递归的函数中使用。可以在算法中需要使用记忆花搜索时使用 import functools @functools.lru_cache() @clock # 自己实现的查看函数执行时间的装饰器 def fib(n): if n \u003c 2: return n return fib(n-1) + fib(n-2) 必须像常规函数那样调用 lru_cache。这一行中有一对括号: @functools.lru_cache()。这么做的原因是，lru_cache 可以接受配置参数。使用该装饰器之后，这样每个 n 都只会执行一次。 该装饰器的签名 functools.lru_cache(maxsize=128, typed=False) 。maxsize 参数指定存储多少个调用的结果。缓存满了之后,旧的结果会被扔掉,腾出空间。为了得到最佳性能，maxsize 应该设为 2 的幂。typed 参数如果设为 True，把不同参数类型得到的结果分开保存，即把通常认为相等的浮点数和整数参数(如 1 和 1.0)区分开。 因为 lru_cache 使用了哈希散列存储，所以被装饰器的函数中的的参数都必须是可以散列的。 functools.singledispatch 由于 python 函数不支持重载，所以如果需要编写同名方法的函数，只能使用 if-else 调用不同的函数执行，于是则各个函数之间耦合过于紧密。python3.4 增加了 functools.singledispatch 装饰器用于解决该问题。 from functools import singledispatch from collections import abc import numbers import html @singledispatch ➊ def htmlize(obj): content = html.escape(repr(obj)) return '\u003cpre\u003e{}\u003c/pre\u003e'.format(content) @htmlize.register(str) ➋ def _(text): content = html.escape(text).replace('\\n', '\u003cbr\u003e\\n') return '\u003cp\u003e{0}\u003c/p\u003e'.format(content) @htmlize.register(numbers.Integral) ➍ def _(n): return '\u003cpre\u003e{0} (0x{0:x})\u003c/pre\u003e'.format(n) @htmlize.register(tuple) ➎ @htmlize.register(abc.MutableSequence) def _(seq): inner = '\u003c/li\u003e\\n\u003cli\u003e'.join(htmlize(item) for item in seq) return '\u003cul\u003e\\n\u003cli\u003e' + inner + '\u003c/li\u003e\\n\u003c/ul\u003e' singledispatch 创建一个自定义的 htmlize.register 装饰器，把多个函数绑在一起组成一个泛函数。 ","date":"2022-04-25","objectID":"/posts/python-%E5%9F%BA%E7%A1%80.html/:2:11","tags":["python"],"title":"Python 基础","uri":"/posts/python-%E5%9F%BA%E7%A1%80.html/"},{"categories":["python"],"content":"作用域 如果在函数体的内部定义了一个与全部变量同名的局部变量，则 python 会优先将该变量是作为局部变量，如果在赋值之前使用了该变量，则会抛出为引用的异常。 b = 3 def f(a): print(a) print(b) # b 为局部变量，为初始化使用抛出异常 b = 6 如果要在函数中使用全局变量，则应该使用 global 关键字。 ","date":"2022-04-25","objectID":"/posts/python-%E5%9F%BA%E7%A1%80.html/:2:12","tags":["python"],"title":"Python 基础","uri":"/posts/python-%E5%9F%BA%E7%A1%80.html/"},{"categories":["python"],"content":"闭包 闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。当闭包内使用的是不可变量时，若发生变化，则会变成局部变量，而不是自由变量。因此，则闭包内使用不可变量时，需要使用 nolocal 关键字，将不可变量标记为自由变量。 def make_averager(): series = [] def averager(new_value): series.append(new_value) # 自由变量 total = sum(series) return total/len(series) return averager def make_averager(): count = 0 total = 0 def averager(new_value): count += 1 # 局部变量 total += new_value # 局部变量 return total / count return averager ","date":"2022-04-25","objectID":"/posts/python-%E5%9F%BA%E7%A1%80.html/:2:13","tags":["python"],"title":"Python 基础","uri":"/posts/python-%E5%9F%BA%E7%A1%80.html/"},{"categories":["python"],"content":"is 和 == 区别 is 在 python 中比较的是两个对象的 id，在 cpython 解释器中，id 即为对象的内存地址。而 == 则是调用对象的 __eq__ 方法。这与 java 实现存在差异，在 java 中 == 比较是内存的地址。速度来说， is 直接比较内存地址，而 == 则需要调用方法，故 is 更快。 ","date":"2022-04-25","objectID":"/posts/python-%E5%9F%BA%E7%A1%80.html/:2:14","tags":["python"],"title":"Python 基础","uri":"/posts/python-%E5%9F%BA%E7%A1%80.html/"},{"categories":["python"],"content":"浅复制 序列的构造方法和切片生成的结果都是浅复制，如果里面的元素都是不可变对象时，则没有差异，如果是引用对象时，则会同时发生变化，和 java 一致。 copy 模块提供了 deepcopy 函数进行深拷贝。 ","date":"2022-04-25","objectID":"/posts/python-%E5%9F%BA%E7%A1%80.html/:2:15","tags":["python"],"title":"Python 基础","uri":"/posts/python-%E5%9F%BA%E7%A1%80.html/"},{"categories":["python"],"content":"引用传参 Python 唯一支持的参数传递模式是共享传参(call by sharing)，即引用传参数。共享传参指函数的各个形式参数获得实参中各个引用的副本。也就是说,函数内部的形参是实参的别名。 所以不应该将可变量作为默认参数进行传递。如果使用可变对象作为默认参数，则所有默认参数都将共享一个参数，会出现奇怪 bug。 ","date":"2022-04-25","objectID":"/posts/python-%E5%9F%BA%E7%A1%80.html/:2:16","tags":["python"],"title":"Python 基础","uri":"/posts/python-%E5%9F%BA%E7%A1%80.html/"},{"categories":["python"],"content":"del del 语句删除名称,而不是对象。del 命令可能会导致对象被当作垃圾回收,但是仅当删除的变量保存的是对象的最后一个引用,或者无法得到对象时。 当对象的引用数量归零后,垃圾回收程序会把对象销毁。但是,有时需要引用对象,而不让对象存在的时间超过所需时间。这经常用在缓存中。弱引用不会增加对象的引用数量。引用的目标对象称为所指对象(referent)。因此我们说, 弱引用不会妨碍所指对象被当作垃圾回收。 ","date":"2022-04-25","objectID":"/posts/python-%E5%9F%BA%E7%A1%80.html/:2:17","tags":["python"],"title":"Python 基础","uri":"/posts/python-%E5%9F%BA%E7%A1%80.html/"},{"categories":["python"],"content":"@classmethod 和 @staticmethod classmethod 该装饰器表示修饰的方法可以通过类名直接调用，当然也可以通过类的对象的调用，该方法传入的第一个参数对象为类对象。而 staticmethod 表示的类的静态方法，方法不需传入实例对象或者类对象。 ","date":"2022-04-25","objectID":"/posts/python-%E5%9F%BA%E7%A1%80.html/:2:18","tags":["python"],"title":"Python 基础","uri":"/posts/python-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java"],"content":"前言 算法题目中，经常出现集合和数组之间、集合和集合之间的转换。 ","date":"2022-04-24","objectID":"/posts/java-%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.html/:1:0","tags":["collections","arrays"],"title":"Java 数组和集合之间的转换","uri":"/posts/java-%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.html/"},{"categories":["Java"],"content":"内容 ","date":"2022-04-24","objectID":"/posts/java-%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.html/:2:0","tags":["collections","arrays"],"title":"Java 数组和集合之间的转换","uri":"/posts/java-%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.html/"},{"categories":["Java"],"content":"List 和 数组 List 转 数组 通过 toArray(T[] a) 方法 （推荐） toArray(T[] a) 方法是 Collection 接口中的方法，用来将集合转换为数组，参数为转换后的类型，不推荐使用 toArray() 方法，该方法返回的是 Object 数组，需要强制类型转换。 public static void main(String[] args) { //1. 通过 toArray() List\u003cString\u003e list = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c 10; i++) { list.add(\"value\" + i); } String[] arrays = list.toArray(new String[0]); System.out.println(Arrays.toString(arrays)); } 通过 stream (jdk 1.8 提供) public static void main(String[] args) { //2. jdk1.8 stream List\u003cString\u003e list = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c 10; i++) { list.add(\"value\" + i); } String[] arrays = list.stream().toArray(String[]::new); System.out.println(Arrays.toString(arrays)); } 数组转 List 通过 Arrays.asList() 方法 因为生成的 List 是 Arrays 的内部类，继承了 AbstractList 但没有实现 add() 那些方法，所以生成 List 长度固定，需谨慎使用 public static void main(String[] args) { /* * 此种方法生成的List不可进行add和remove操作 * 因为它是一个定长的List集合，跟数组长度一致 */ String[] array = new String[]{\"value1\", \"value2\", \"value3\"}; List\u003cString\u003e stringList = Arrays.asList(array); System.out.println(stringList.toString()); } 通过 Collections.addAll(list, arrays) public static void main(String[] args) { //2.通过Collections.addAll(list, arrays); List\u003cString\u003e stringList=new ArrayList\u003c\u003e(); String[] array=new String[]{\"value1\",\"value2\",\"value3\"}; Collections.addAll(stringList, array); System.out.println(stringList.toString()); } 通过 stream (jdk 1.8 提供) public static void main(String[] args) { //3. jdk1.8 通过Stream String[] arrays = new String[]{\"value1\", \"value2\", \"value3\"}; List\u003cString\u003e listStrings = Stream .of(arrays) .collect(Collectors.toList()); System.out.println(listStrings.toString()); } ","date":"2022-04-24","objectID":"/posts/java-%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.html/:2:1","tags":["collections","arrays"],"title":"Java 数组和集合之间的转换","uri":"/posts/java-%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.html/"},{"categories":["Java"],"content":"Set 和 数组 Set 转数组 通过 toArray(T[] a) 方法 private static void setToArray1() { Set\u003cString\u003e set = new HashSet\u003c\u003e(); set.add(\"value1\"); set.add(\"value2\"); set.add(\"value3\"); //Set--\u003e数组 String[] array=set.toArray(new String[0]); System.out.println(Arrays.toString(array)); } 通过 stream (jdk 1.8 提供) private static void setToArray2() { Set\u003cString\u003e set = new HashSet\u003c\u003e(); set.add(\"value1\"); set.add(\"value2\"); set.add(\"value3\"); //Set--\u003e数组 String[] array= set.stream().toArray(String[]::new); System.out.println(Arrays.toString(array)); } 数组转 Set 先转 List，在转 Set //数组--\u003eSet private static void arrayToSet() { String[] array = {\"value1\",\"value2\",\"value3\"}; Set\u003cString\u003e set = new HashSet\u003c\u003e(Arrays.asList(array)); System.out.println(set); } 通过 stream (jdk 1.8 提供) private static void arrayToSet2() { String[] array = {\"value1\",\"value2\",\"value3\"}; Set\u003cString\u003e set = Stream.of(array).collect(Collectors.toSet()); System.out.println(set); } ","date":"2022-04-24","objectID":"/posts/java-%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.html/:2:2","tags":["collections","arrays"],"title":"Java 数组和集合之间的转换","uri":"/posts/java-%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.html/"},{"categories":["Java"],"content":"Set 和 List Set 转 List List 构造方法 List 为 null 时，抛出异常 private static void setToList() { Set\u003cString\u003e set = new HashSet\u003c\u003e(); set.add(\"value1\"); set.add(\"value2\"); set.add(\"value3\"); set=null; List\u003cString\u003e list=new ArrayList\u003c\u003e(set); System.out.println(list.toString()); } 通过 stream private static void setToList2() { Set\u003cString\u003e set = new HashSet\u003c\u003e(); set.add(\"value1\"); set.add(\"value2\"); set.add(\"value3\"); List list=Stream.of(set.toArray(new String[0])).collect(Collectors.toList()); System.out.println(list.toString()); } List 转 Set 通过 Set 构造方法 private static void listToSet() { List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"value1\"); list.add(\"value2\"); list.add(\"value3\"); Set\u003cString\u003e set=new HashSet\u003c\u003e(list); System.out.println(set.toString()); } ","date":"2022-04-24","objectID":"/posts/java-%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.html/:2:3","tags":["collections","arrays"],"title":"Java 数组和集合之间的转换","uri":"/posts/java-%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.html/"},{"categories":["Java"],"content":"参考资料 Java中List，Set，数组的互相转换 ","date":"2022-04-24","objectID":"/posts/java-%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.html/:3:0","tags":["collections","arrays"],"title":"Java 数组和集合之间的转换","uri":"/posts/java-%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.html/"},{"categories":["算法"],"content":"前言 点集 Q 的凸包是一个最小的凸多边形 P，满足 Q 中每个点都在 P 的边界上或在 P 的内部。 凸包 ","date":"2022-04-23","objectID":"/posts/%E5%87%B8%E5%8C%85.html/:1:0","tags":["凸包","算法"],"title":"凸包","uri":"/posts/%E5%87%B8%E5%8C%85.html/"},{"categories":["算法"],"content":"算法 ","date":"2022-04-23","objectID":"/posts/%E5%87%B8%E5%8C%85.html/:2:0","tags":["凸包","算法"],"title":"凸包","uri":"/posts/%E5%87%B8%E5%8C%85.html/"},{"categories":["算法"],"content":"Jarvis 算法 算法思路： 先找到一个必定在凸包的点，比如最左边的点。在找到下一个点，该点要求如下：除了凸包上的点，其他点和凸包上最后的一个点所构成的向量都在该点和凸包最后一个点构成的向量的左边或者右边（后续都选择一边即可，比如一直选左边），并将该点作为凸包的最后一个点。按照上述规则循环，直到回到开始的第一个点。 判断一个向量是否在另一个向量的左侧还是右侧时，可以通过向量叉乘，两个二维向量的叉乘结果为 $z$ 轴向量，通过其值正负判断左右（根据右手螺旋法则）。若结果为正，则向量在其左侧，若结果为0，则同向，若结果为负，则向量在其右侧。 算法因为每个点都需要判断其他点是否在其左侧还是右侧，时间复杂度为 $O(n*h)$，h 为凸包上点的数量，n 为总顶点数量。 class Solution { public int[][] outerTrees(int[][] trees) { int n = trees.length; if (n \u003c 4) { return trees; } int leftMost = 0; for (int i = 0; i \u003c n; i++) { if (trees[i][0] \u003c trees[leftMost][0]) { leftMost = i; } } List\u003cint[]\u003e res = new ArrayList\u003cint[]\u003e(); boolean[] visit = new boolean[n]; int p = leftMost; do { int q = (p + 1) % n; for (int r = 0; r \u003c n; r++) { /* 如果 r 在 pq 的右侧，则 q = r */ if (cross(trees[p], trees[q], trees[r]) \u003c 0) { q = r; } } /* 是否存在点 i, 使得 p 、q 、i 在同一条直线上 */ for (int i = 0; i \u003c n; i++) { if (visit[i] || i == p || i == q) { continue; } if (cross(trees[p], trees[q], trees[i]) == 0) { res.add(trees[i]); visit[i] = true; } } if (!visit[q]) { res.add(trees[q]); visit[q] = true; } p = q; } while (p != leftMost); return res.toArray(new int[][]{}); } public int cross(int[] p, int[] q, int[] r) { return (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0]); } } ","date":"2022-04-23","objectID":"/posts/%E5%87%B8%E5%8C%85.html/:2:1","tags":["凸包","算法"],"title":"凸包","uri":"/posts/%E5%87%B8%E5%8C%85.html/"},{"categories":["算法"],"content":"Graham 算法 算法思路： 首先选择一个凸包上的初始点 $bottom$ 。我们选择 $y$ 坐标最小的点为起始点，如果有多个，则选择最最左边的点，我们可以肯定 $bottom$ 一定在凸包上，将给定点集按照相对的以 $bottom$ 为原点的极角大小进行排序。 极角顺序更小的点排在数组的前面。如果有两个点相对于点 $bottom$ 的极角大小相同，则按照与点 $bottom$ 的距离排序。 我们还需要考虑另一种重要的情况，如果共线的点在凸壳的最后一条边上，我们需要从距离初始点最远的点开始考虑起。所以在将数组排序后，我们从尾开始遍历有序数组并将共线且朝有序数组尾部的点反转顺序，因为这些点是形成凸壳过程中尾部的点，所以在经过了这些处理以后，我们得到了求凸壳时正确的点的顺序。 现在我们从有序数组最开始两个点开始考虑。我们将这条线上的点放入栈中。然后我们从第三个点开始遍历有序数组 。如果当前点与栈顶的点相比前一条线是一个「左拐」或者是同一条线段上，我们都将当前点添加到栈顶，表示这个点暂时被添加到凸壳上。 如果当前点与上一条线之间的关系是右拐的，说明上一个点不应该被包括在凸壳里，因为它在边界的里面，所以我们将它从栈中弹出并考虑倒数第二条线的方向。重复这一过程，弹栈的操作会一直进行，直到我们当前点在凸壳中出现了右拐。这表示这时凸壳中只包括边界上的点而不包括边界以内的点。在所有点被遍历了一遍以后，栈中的点就是构成凸壳的点。 class Solution { public int[][] outerTrees(int[][] trees) { int n = trees.length; if (n \u003c 4) { return trees; } int bottom = 0; /* 找到 y 最小的点 bottom*/ for (int i = 0; i \u003c n; i++) { if (trees[i][1] \u003c trees[bottom][1]) { bottom = i; } } swap(trees, bottom, 0); /* 以 bottom 原点，按照极坐标的角度大小进行排序 */ Arrays.sort(trees, 1, n, (a, b) -\u003e { int diff = cross(trees[0], a, b) - cross(trees[0], b, a); if (diff == 0) { return distance(trees[0], a) - distance(trees[0], b); } else { return -diff; } }); /* 对于凸包最后且在同一条直线的元素按照距离从小到大进行排序 */ int r = n - 1; while (r \u003e= 0 \u0026\u0026 cross(trees[0], trees[n - 1], trees[r]) == 0) { r--; } for (int l = r + 1, h = n - 1; l \u003c h; l++, h--) { swap(trees, l, h); } Deque\u003cInteger\u003e stack = new ArrayDeque\u003cInteger\u003e(); stack.push(0); stack.push(1); for (int i = 2; i \u003c n; i++) { int top = stack.pop(); /* 如果当前元素与栈顶的两个元素构成的向量顺时针旋转，则弹出栈顶元素 */ while (!stack.isEmpty() \u0026\u0026 cross(trees[stack.peek()], trees[top], trees[i]) \u003c 0) { top = stack.pop(); } stack.push(top); stack.push(i); } int size = stack.size(); int[][] res = new int[size][2]; for (int i = 0; i \u003c size; i++) { res[i] = trees[stack.pop()]; } return res; } public int cross(int[] p, int[] q, int[] r) { return (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0]); } public int distance(int[] p, int[] q) { return (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]); } public void swap(int[][] trees, int i, int j) { int temp0 = trees[i][0], temp1 = trees[i][1]; trees[i][0] = trees[j][0]; trees[i][1] = trees[j][1]; trees[j][0] = temp0; trees[j][1] = temp1; } } ","date":"2022-04-23","objectID":"/posts/%E5%87%B8%E5%8C%85.html/:2:2","tags":["凸包","算法"],"title":"凸包","uri":"/posts/%E5%87%B8%E5%8C%85.html/"},{"categories":["算法"],"content":"Andrew 扫描法 算法思路： 将所有的点排序，先 $x$ 坐标，后 $y$ 坐标。排序的第一一个点和最后一个点必定为凸包上的顶点，他们之间的部分可以分为上下两条链进行求解。求下侧链时，从小到大处理排序上的节点，逐步构造凸包，构造过程中的凸包末尾加上的节点可能会破坏凸性，使用向量叉乘判断凹凸性，将凹的部分节点从末尾提出即可。求上侧的链则从大到小处理。 算法因为需要排序，排序的时间复杂度为 O(nlogn) ，剩下部分处理的时间复杂度为 O(n) ，总的时间复杂度为 O(nlogn) 。 class Solution { public int[][] outerTrees(int[][] trees) { int n = trees.length; if (n \u003c 4) { return trees; } /* 按照 x 大小进行排序，如果 x 相同，则按照 y 的大小进行排序 */ Arrays.sort(trees, (a, b) -\u003e { if (a[0] == b[0]) { return a[1] - b[1]; } return a[0] - b[0]; }); List\u003cInteger\u003e hull = new ArrayList\u003cInteger\u003e(); boolean[] used = new boolean[n]; /* hull[0] 需要入栈两次，不进行标记 */ hull.add(0); /* 求出凸包的下半部分 */ for (int i = 1; i \u003c n; i++) { while (hull.size() \u003e 1 \u0026\u0026 cross(trees[hull.get(hull.size() - 2)], trees[hull.get(hull.size() - 1)], trees[i]) \u003c 0) { used[hull.get(hull.size() - 1)] = false; hull.remove(hull.size() - 1); } used[i] = true; hull.add(i); } int m = hull.size(); /* 求出凸包的上半部分 */ for (int i = n - 2; i \u003e= 0; i--) { if (!used[i]) { while (hull.size() \u003e m \u0026\u0026 cross(trees[hull.get(hull.size() - 2)], trees[hull.get(hull.size() - 1)], trees[i]) \u003c 0) { used[hull.get(hull.size() - 1)] = false; hull.remove(hull.size() - 1); } used[i] = true; hull.add(i); } } /* hull[0] 同时参与凸包的上半部分检测，因此需去掉重复的 hull[0] */ hull.remove(hull.size() - 1); int size = hull.size(); int[][] res = new int[size][2]; for (int i = 0; i \u003c size; i++) { res[i] = trees[hull.get(i)]; } return res; } public int cross(int[] p, int[] q, int[] r) { return (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0]); } } ","date":"2022-04-23","objectID":"/posts/%E5%87%B8%E5%8C%85.html/:2:3","tags":["凸包","算法"],"title":"凸包","uri":"/posts/%E5%87%B8%E5%8C%85.html/"},{"categories":["算法"],"content":"参考资料 安装栅栏 ","date":"2022-04-23","objectID":"/posts/%E5%87%B8%E5%8C%85.html/:3:0","tags":["凸包","算法"],"title":"凸包","uri":"/posts/%E5%87%B8%E5%8C%85.html/"},{"categories":["d2l"],"content":"前言 word2vec 算法代码实现，代码来自 d2l ","date":"2022-04-22","objectID":"/posts/word2vec-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html/:1:0","tags":["word2vec","d2l"],"title":"word2vec 代码实现","uri":"/posts/word2vec-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html/"},{"categories":["d2l"],"content":"代码 ","date":"2022-04-22","objectID":"/posts/word2vec-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html/:2:0","tags":["word2vec","d2l"],"title":"word2vec 代码实现","uri":"/posts/word2vec-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html/"},{"categories":["d2l"],"content":"下采样 将每次词汇以概率 $w_i$ 丢弃，其中高频词丢弃的概率更高 $$P(w_i) = \\max\\left(1 - \\sqrt{\\frac{t}{f(w_i)}}, 0\\right)$$ def subsample(sentences, vocab): \"\"\"下采样高频词\"\"\" # 排除未知词元'\u003cunk\u003e' sentences = [[token for token in line if vocab[token] != vocab.unk] for line in sentences] counter = d2l.count_corpus(sentences) num_tokens = sum(counter.values()) # 如果在下采样期间保留词元，则返回True def keep(token): return(random.uniform(0, 1) \u003c math.sqrt(1e-4 / counter[token] * num_tokens)) return ([[token for token in line if keep(token)] for line in sentences], counter) subsampled, counter = subsample(sentences, vocab) ","date":"2022-04-22","objectID":"/posts/word2vec-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html/:2:1","tags":["word2vec","d2l"],"title":"word2vec 代码实现","uri":"/posts/word2vec-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html/"},{"categories":["d2l"],"content":"获取中心词和上下文词 按照给定窗口大小获取中心词和其对应的上下文词 def get_centers_and_contexts(corpus, max_window_size): \"\"\"返回跳元模型中的中心词和上下文词\"\"\" centers, contexts = [], [] for line in corpus: # 要形成“中心词-上下文词”对，每个句子至少需要有2个词 if len(line) \u003c 2: continue centers += line for i in range(len(line)): # 上下文窗口中间i window_size = random.randint(1, max_window_size) indices = list(range(max(0, i - window_size), min(len(line), i + 1 + window_size))) # 从上下文词中排除中心词 indices.remove(i) contexts.append([line[idx] for idx in indices]) return centers, contexts ","date":"2022-04-22","objectID":"/posts/word2vec-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html/:2:2","tags":["word2vec","d2l"],"title":"word2vec 代码实现","uri":"/posts/word2vec-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html/"},{"categories":["d2l"],"content":"负采样 对于一对中心词和上下文词，我们随机抽取了K个（实验中为5个）噪声词。根据 word2vec 论文中的建议，将噪声词w的采样概率 $P(w)$ 设置为其在字典中的相对频率，其幂为0.75[Mikolov et al., 2013b] class RandomGenerator: \"\"\"根据n个采样权重在{1,...,n}中随机抽取\"\"\" def __init__(self, sampling_weights): # Exclude self.population = list(range(1, len(sampling_weights) + 1)) self.sampling_weights = sampling_weights self.candidates = [] self.i = 0 def draw(self): if self.i == len(self.candidates): # 缓存k个随机采样结果 self.candidates = random.choices( self.population, self.sampling_weights, k=10000) self.i = 0 self.i += 1 return self.candidates[self.i - 1] def get_negatives(all_contexts, vocab, counter, K): \"\"\"返回负采样中的噪声词\"\"\" # 索引为1、2、...（索引0是词表中排除的未知标记） sampling_weights = [counter[vocab.to_tokens(i)]**0.75 for i in range(1, len(vocab))] all_negatives, generator = [], RandomGenerator(sampling_weights) for contexts in all_contexts: negatives = [] while len(negatives) \u003c len(contexts) * K: neg = generator.draw() # 噪声词不能是上下文词 if neg not in contexts: negatives.append(neg) all_negatives.append(negatives) return all_negatives all_negatives = get_negatives(all_contexts, vocab, counter, 5) ","date":"2022-04-22","objectID":"/posts/word2vec-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html/:2:3","tags":["word2vec","d2l"],"title":"word2vec 代码实现","uri":"/posts/word2vec-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html/"},{"categories":["d2l"],"content":"跳元模型 求每个元素是中心词向量和上下文或噪声词向量的点积。 embed = nn.Embedding(num_embeddings=20, embedding_dim=4) def skip_gram(center, contexts_and_negatives, embed_v, embed_u): v = embed_v(center) u = embed_u(contexts_and_negatives) pred = torch.bmm(v, u.permute(0, 2, 1)) return pred 定义二元交叉熵损失： class SigmoidBCELoss(nn.Module): # 带掩码的二元交叉熵损失 def __init__(self): super().__init__() def forward(self, inputs, target, mask=None): out = nn.functional.binary_cross_entropy_with_logits( inputs, target, weight=mask, reduction=\"none\") return out.mean(dim=1) loss = SigmoidBCELoss() 初始化模型： embed_size = 100 net = nn.Sequential(nn.Embedding(num_embeddings=len(vocab), embedding_dim=embed_size), nn.Embedding(num_embeddings=len(vocab), embedding_dim=embed_size)) 训练代码： def train(net, data_iter, lr, num_epochs, device=d2l.try_gpu()): def init_weights(m): if type(m) == nn.Embedding: nn.init.xavier_uniform_(m.weight) net.apply(init_weights) net = net.to(device) optimizer = torch.optim.Adam(net.parameters(), lr=lr) animator = d2l.Animator(xlabel='epoch', ylabel='loss', xlim=[1, num_epochs]) # 规范化的损失之和，规范化的损失数 metric = d2l.Accumulator(2) for epoch in range(num_epochs): timer, num_batches = d2l.Timer(), len(data_iter) for i, batch in enumerate(data_iter): optimizer.zero_grad() center, context_negative, mask, label = [ data.to(device) for data in batch] pred = skip_gram(center, context_negative, net[0], net[1]) l = (loss(pred.reshape(label.shape).float(), label.float(), mask) / mask.sum(axis=1) * mask.shape[1]) l.sum().backward() optimizer.step() metric.add(l.sum(), l.numel()) if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1: animator.add(epoch + (i + 1) / num_batches, (metric[0] / metric[1],)) print(f'loss {metric[0] / metric[1]:.3f}, ' f'{metric[1] / timer.stop():.1f} tokens/sec on {str(device)}') ","date":"2022-04-22","objectID":"/posts/word2vec-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html/:2:4","tags":["word2vec","d2l"],"title":"word2vec 代码实现","uri":"/posts/word2vec-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html/"},{"categories":["d2l"],"content":"参考资料 14.3. 用于预训练词嵌入的数据集 14.4. 预训练word2vec ","date":"2022-04-22","objectID":"/posts/word2vec-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html/:3:0","tags":["word2vec","d2l"],"title":"word2vec 代码实现","uri":"/posts/word2vec-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html/"},{"categories":["Spring"],"content":"前言 在实际开发过程中，rest 风格的 api 也需要访问控制，并不是任意访问就可以去往数据库里插入东西的，所以我们需要JWT来做访问控制。 ","date":"2022-04-22","objectID":"/posts/jwt-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:1:0","tags":["jwt","token"],"title":"JWT 学习笔记","uri":"/posts/jwt-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"JWT 基本内容 JWT (JSON Web Token) 是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为 JSON 对象在各方之间安全地传输信息，该信息可以被验证和信任，因为它是数字签名的。 ","date":"2022-04-22","objectID":"/posts/jwt-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:0","tags":["jwt","token"],"title":"JWT 学习笔记","uri":"/posts/jwt-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"使用场景 下列场景中使用JSON Web Token是很有用的。 Authorization (授权) : 这是使用JWT的最常见场景。一旦用户登录，后续每个请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。 l Information Exchange (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式。因为JWTs可以被签名，例如，用公钥/私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容有没有被篡改 ","date":"2022-04-22","objectID":"/posts/jwt-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:1","tags":["jwt","token"],"title":"JWT 学习笔记","uri":"/posts/jwt-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"为什么需要 JWT 跨域问题 当采用分布式部署 web 时，一个网站可能有不同的域名，但 cookie 是根据同源策略，故不会将 cookie 信息发送至不同网站，因此用户可能需要再次登陆，造成用户体验不好。 单点登陆 使用负载均衡时，为了解决 session 问题，要么采用同一请求 ip 只映射到一台服务器，要么采用 session 复制。但这两个方案实现都不好，前者没有负载均衡，若服务器出现问题，则无服务器提供服务，后者则造成 session 冗余，内存浪费。 Token Vs Session Session 在讨论基于Token的身份认证是如何工作的以及它的好处之前，我们先来看一下以前我们是怎么做的：（基于session的身份认证） HTTP协议是无状态的，也就是说，如果我们已经认证了一个用户，那么他下一次请求的时候，服务器不知道我是谁，我们必须再次认证 传统的做法是将已经认证过的用户信息存储在服务器上，比如Session。用户下次请求的时候带着Session ID，然后服务器以此检查用户是否认证过。 这种基于服务器的身份认证方式存在一些问题： Sessions : 每次用户认证通过以后，服务器需要创建一条记录保存用户信息，通常是在内存中，随着认证通过的用户越来越多，服务器的在这里的开销就会越来越大。 Scalability : 由于Session是在内存中的，这就带来一些扩展性的问题。 CORS : 当我们想要扩展我们的应用，让我们的数据被多个移动设备使用时，我们必须考虑跨资源共享问题。当使用AJAX调用从另一个域名下获取资源时，我们可能会遇到禁止请求的问题。 CSRF : 用户很容易受到CSRF攻击 Token 使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录，大概流程如下 客户端使用用户名、密码请求登录 服务端收到请求、去验证用户名与密码 验证成功后，服务端会签发一个 token ，再把这个 token 发送给客户端 客户端收到 token 以后可以把它存储起来，存到客户端内存或者其他地方 客户端每次向服务器请求资源的时服务端收到请求，然后去验证客户端请求里面带着的 token 服务端收到请求，然后去验证客户端请求里面带着的 token，如果验证成功，就向客户端返回请求的数据 相同点是，它们都是存储用户信息；然而，Session是在服务器端的，而 JWT是在客户端的。Session方式存储用户信息的最大问题在于要占用大量服务器内存，增加服务器的开销，而 Token 的方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力，Session的状态是存储在服务器端，客户端只有session id，而 Token 的状态是存储在客户端。 Token 的好处 无状态和可扩展性： Token 存储在客户端，完全无状态，可扩展，我们的负载均衡器可以将用户传递到任意服务器上，因为任何服务器都不没状态信息或会话信息 安全：Token 不是 cookie，每次请求的时候 Token 都会被发送。而 且由于 cookie 没有发送，有助于 CSRF 攻击，即使实现中将 token 存储到 cookie 当中，这个 cookie 也是一种存储机制，而非身份认证机制。 JWT Token 基本格式 JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是： Header Payload Signature ","date":"2022-04-22","objectID":"/posts/jwt-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:2","tags":["jwt","token"],"title":"JWT 学习笔记","uri":"/posts/jwt-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["cs224n"],"content":"前言 由于 one-hot 将词转为向量的方法简单且容易实现，但生成的向量并不能表示各个词之间的关系（比如常见的余弦相似度，因为 one-hot 生成的向量两两正交），而 word2vec 算法则解决了该问题，word2vec 算法主要有两种算法，一种是 跳元模型 （Skip-grams , SG）算法，利用中心词推导上下文，另一种是 连续词袋 （Continuous Bag of Words, CBOW）算法，利用上下文推导中心词。cs224n 第一节课主要介绍了 word2vec 跳元模型算法的原理与公式推导。 ","date":"2022-04-22","objectID":"/posts/cs224n-lecture1-word-vectors.html/:1:0","tags":["cs224n","word2vec"],"title":"cs224n Lecture1 Word Vectors","uri":"/posts/cs224n-lecture1-word-vectors.html/"},{"categories":["cs224n"],"content":"内容 ","date":"2022-04-22","objectID":"/posts/cs224n-lecture1-word-vectors.html/:2:0","tags":["cs224n","word2vec"],"title":"cs224n Lecture1 Word Vectors","uri":"/posts/cs224n-lecture1-word-vectors.html/"},{"categories":["cs224n"],"content":"基本模型 在跳元模型当中，每个词都包含一对向量，即作为中心词向量和上下文词向量，更具体地说，对于词典中索引为i的任何词，分别用 $\\mathbf{u}_i\\in\\mathbb{R}^d$ 和 $\\mathbf{u}_i\\in\\mathbb{R}^d$ 表示其用作中心词和上下文词时的两个向量，计算给定中心词 $w_t$ 上下文词的条件概率，得到最大似然函数。最后利用最大似然函数的特性，转换为 log 函数进行最小化求解。 现在关键的问题为求解条件概率 $P(W_{t+j} | W_t; \\theta)$ 。对于每个词 $w$，定义其两个词向量：$v_w$表示当 $w$ 为中心词时的词向量，$u_w$ 表示当w为其他词的临近词时的词向量。则对于一个中心词c和其临近词 $o$，则可以通过 softmax 进行建模。 softmax 函数可以将放大较大 $x_i$ 概率（max），同时还保持较小的数的概率不为0（soft）。 求导的梯度如下，$u_o$ 表示观察到的上下文词向量，减号后面的是这个位置的期望的词向量，期望=概率*值。差值就是真实观察词向量减去期望词向量，这就是梯度。当它们的差值很小时，说明给定 $c$ 能很好的预测其临近词的概率分布。 对中心向量求导： 对上下文向量求导： 上述全连接网络虽然能很方便的计算词向量，但存在两个问题：1. 网络过于庞大，参数量太多；2. 训练样本太多，每个样本都更新所有参数，训练速度慢。针对这两个问题，作者分别提出了 subsampling 和 negative sampling 的技巧。 subsampling技巧是指，每个词有一个保留概率p，以这个概率p保留其在训练数据中，以1-p删掉这个词。对于词$w_i$，其概率 $P(w_i)$ 公式如下，其中 $z(w_i)$ 是词 $w$ 的词频。概率 $p$ 和这个词在语料库中的词频有关，词频越大，保留概率越低，即被删掉的概率越大，所以subsampling之后应该能较大的减少训练数据。 $$P(W_i) = (\\sqrt{\\frac{z(w_i)}{0.001}} + 1) * \\frac{0.001}{z(w_i)}$$ ","date":"2022-04-22","objectID":"/posts/cs224n-lecture1-word-vectors.html/:2:1","tags":["cs224n","word2vec"],"title":"cs224n Lecture1 Word Vectors","uri":"/posts/cs224n-lecture1-word-vectors.html/"},{"categories":["cs224n"],"content":"Negative Sampling negative sampling 技巧，只更新一小部分参数。比如对于(“fox”, “quick”)，期望的输出是quick的one-hot，即只有quick对应位为1，其他为0。但网络的softmax输出肯定不可能是完完全全的quick为1，其他为0；有可能是quick为0.8，其他位有些0.001，0.03之类的非0值，这就导致输出层的所有神经元都有误差。按照传统的方法，输出层所有神经元对应的U矩阵的权重都要更新。negative sampling技巧是，只更新和quick连接的U权重以及随机选5个输出神经元的连接权重进行更新，这样一下把需要更新的 U 权重个数从300w降到了6*300=1800，只需要更新0.06%的参数，大大减小了参数更新量！ 考虑一对中心词和上下文词$(w, c)$，我们通过 $P(D = 1 | w,c)$ 表示 $(w, c)$是来自语料库。相应地，表示 $P(D = 0 | w,c)$ 不是来自语料库。首先,我们对 $P(D = 1 | w,c)$ 用 sigmoid 函数建模: $$ P(D = 1| w, c, \\theta) = \\sigma(v_c^tv_w) = \\frac{1}{1 + e^{-v_c^tv_w}}$$ 我们建立一个新的目标函数,如果中心词和上下文词确实在语料库中，就最大化概率 ,如果中心词和上下文词确实不在语料库中，就最大化概率 $P(D = 1 | w,c)$ 。我们对这两个概率采用一个简单的极大似然估计的方法(这里我们把 $\\theta$ 作为模型的参数,在我们的例子是 $V$ 和 $U$。 最大化似然函数等同于最小化负对数似然： 有很多关于如何得到最好近似的讨论,从实际效果看来最好的是指数为 3/4 的 Unigram 模型。 $$P(w_i) = \\frac{f(w_i)^{3/4}}{\\sum_{j=0}^{n} f(w_j)^{3/4}}$$ ","date":"2022-04-22","objectID":"/posts/cs224n-lecture1-word-vectors.html/:2:2","tags":["cs224n","word2vec"],"title":"cs224n Lecture1 Word Vectors","uri":"/posts/cs224n-lecture1-word-vectors.html/"},{"categories":["cs224n"],"content":"Hierarchical softmax 在实际中，hierarchical softmax 对低频词往往表现得更好，负采样对高频词和较低维度向量表现得更好。 Hierarchical softmax 使用一个二叉树来表示词表中的所有词。树中的每个叶结点都是一个单词,而且只有一条路 径从根结点到叶结点。在这个模型中,没有词的输出表示。相反,图的每个节点(根节点和叶结点除外)与模型要 学习的向量相关联。单词作为输出单词的概率定义为从根随机游走到单词所对应的叶的概率。计算成本变为 $O(log|V|)$ 而不是 $O(|V|)$ 。 下图是 Hierarchical softmax 的二叉树示意图 让我们引入一些概念。令 $L(w)$ 为从根结点到叶结点 $w$ 的路径中节点数目。例如，上图中的 $L(w_2)$ 为 3。我们定 义 $n(w, i)$ 为与向量 $v_n(w, i)$ 相关的路径上第 $i$ 个结点。因此 $n(w, 1)$ 是根结点，而 $n(w, L(w))$ 是 $w$ 的父节 点。现在对每个内部节点 $n$ ，我们任意选取一个它的子节点，定义为 $ch(n)$ (一般是左节点)。然后，我们可以 计算概率为： $$p(w|w_i) = \\prod_{j=1}^{L(w) - 1}\\sigma([n(w, j+1) = ch(n(w, j))] * v_{n(w,j)}^Tv_{w_j})$$ 其中 $[x]$ 当 x 为true 时，为 1，否则为 0。 ","date":"2022-04-22","objectID":"/posts/cs224n-lecture1-word-vectors.html/:2:3","tags":["cs224n","word2vec"],"title":"cs224n Lecture1 Word Vectors","uri":"/posts/cs224n-lecture1-word-vectors.html/"},{"categories":["cs224n"],"content":"参考资料 CS224N（1.8）Introduction and Word Vectors Word2Vec Tutorial - The Skip-Gram Model Word2Vec Tutorial Part 2 - Negative Sampling ","date":"2022-04-22","objectID":"/posts/cs224n-lecture1-word-vectors.html/:3:0","tags":["cs224n","word2vec"],"title":"cs224n Lecture1 Word Vectors","uri":"/posts/cs224n-lecture1-word-vectors.html/"},{"categories":["深度学习"],"content":"前言 记录 numpy 的常用 api 使用 ","date":"2022-04-21","objectID":"/posts/numpy-%E5%B8%B8%E7%94%A8-api.html/:1:0","tags":["numpy"],"title":"Numpy 常用 api","uri":"/posts/numpy-%E5%B8%B8%E7%94%A8-api.html/"},{"categories":["深度学习"],"content":"常用 api ","date":"2022-04-21","objectID":"/posts/numpy-%E5%B8%B8%E7%94%A8-api.html/:2:0","tags":["numpy"],"title":"Numpy 常用 api","uri":"/posts/numpy-%E5%B8%B8%E7%94%A8-api.html/"},{"categories":["深度学习"],"content":"numpy.stack(arrays,axis=0**,** out=None) 将 python 的 arrays 转换为 ndarray，默认是按照第一维度堆叠起来。可以使用 list 先收集向量，在按照某维度转换为 ndarray。 list = [[1,2], [3,4]] M = np.stack(list) # array([[1, 2],[3, 4]]) M = np.stack(list, axis=-1) # array([[1, 3],[2, 4]]) ","date":"2022-04-21","objectID":"/posts/numpy-%E5%B8%B8%E7%94%A8-api.html/:2:1","tags":["numpy"],"title":"Numpy 常用 api","uri":"/posts/numpy-%E5%B8%B8%E7%94%A8-api.html/"},{"categories":["Spring"],"content":"前言 以往开发项目，都是将项目部署在一个单体的应用当中，但随着业务需求量的增多，内部耦合严重，扩展性差。为了解决这个问题，引入了微服务概念，即将若干个模块作为微服务独立运行。在之前的单体项目是通过内部的 api 实现各个模块资源访问，而微服务因为将模块分开部署，则必须解决各个业务模块之间的通信问题。 微服务主要分为两个部分，服务提供者（Provider）和服务消费者（Consumer），一个可能即是服务提供者也是服服务消费者。 Java 微服务常用两个微服务有 Dubbo 和 Spring Cloud。Dubbo 使用 RPC（Reomote Process Call） 框架，性能更好，通常应用与大型服务上，而 Spring Cloud 是基于Spring Boot 快捷开发，使用 http 通信，适用于中小型企业当中。 Dubbo 工作流程图 ","date":"2022-04-21","objectID":"/posts/duboo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:1:0","tags":["Dubbo"],"title":"Duboo 学习笔记","uri":"/posts/duboo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"使用流程 ","date":"2022-04-21","objectID":"/posts/duboo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:0","tags":["Dubbo"],"title":"Duboo 学习笔记","uri":"/posts/duboo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"导入依赖 spring 框架导入基本依赖 Dubbo 依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edubbo\u003c/artifactId\u003e \u003cversion\u003e2.5.3\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.netty\u003c/groupId\u003e \u003cartifactId\u003enetty-all\u003c/artifactId\u003e \u003cversion\u003e4.1.6.Final\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.javassist\u003c/groupId\u003e \u003cartifactId\u003ejavassist\u003c/artifactId\u003e \u003cversion\u003e3.21.0-GA\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-context\u003c/artifactId\u003e \u003cversion\u003e4.3.3.RELEASE\u003c/version\u003e \u003c/dependency\u003e spring boot 导入基本依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.spring.boot\u003c/groupId\u003e \u003cartifactId\u003edubbo-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e2.0.0\u003c/version\u003e \u003c/dependency\u003e ","date":"2022-04-21","objectID":"/posts/duboo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:1","tags":["Dubbo"],"title":"Duboo 学习笔记","uri":"/posts/duboo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"配置服务提供者 因为是服务提供者，需要定义服务接口，并实现该接口以提供给其他服务消费者 定义服务接口 package org.apache.dubbo.demo; public interface DemoService { String sayHello(String name); } 实现服务接口 package org.apache.dubbo.demo.provider; import org.apache.dubbo.demo.DemoService; public class DemoServiceImpl implements DemoService { public String sayHello(String name) { return \"Hello \" + name; } } 暴露服务 Spring 配置文件暴露。 在 spring 的配置文件 application.xml 中注册对象，并配置相关接口属性，服务提供者使用该配置以提供服务。 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"\u003e \u003c!-- 提供方应用信息，用于计算依赖关系 --\u003e \u003cdubbo:application name=\"hello-world-app\" /\u003e \u003c!-- 使用multicast广播注册中心暴露服务地址 --\u003e \u003c!--\u003cdubbo:registry address=\"multicast://224.5.6.7:1234\" /\u003e --\u003e \u003c!-- 用dubbo协议在20880端口暴露服务 --\u003e \u003cdubbo:protocol name=\"dubbo\" port=\"20880\" /\u003e \u003c!-- 声明需要暴露的服务接口 --\u003e \u003cdubbo:service registry=\"N/A\" interface=\"org.apache.dubbo.demo.DemoService\" ref=\"demoService\"/\u003e \u003c!-- 和本地bean一样实现服务 --\u003e \u003cbean id=\"demoService\" class=\"org.apache.dubbo.demo.provider.DemoServiceImpl\" /\u003e \u003c/beans\u003e import org.springframework.context.support.ClassPathXmlApplicationContext; public class Provider { public static void main(String[] args) throws Exception { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{\"META-INF/spring/dubbo-demo-provider.xml\"}); context.start(); System.in.read(); // 按任意键退出 } } Spring boot 配置注解 在服务提供者的类上配置 Service 注解，并在 spring boot 的配置文件上配置 dubbo 的设置 import com.alibaba.dubbo.config.annotation.Service; import org.springframework.stereotype.Component; @Service(interfaceClass = DemoService.class) @Component public class DemoServiceImpl implements DemoService { public String sayHello(String name) { return \"Hello \" + name; } } spring.application.name=dubbo-spring-boot-starter spring.dubbo.server=true spring.dubbo.registry=N/A ","date":"2022-04-21","objectID":"/posts/duboo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:2","tags":["Dubbo"],"title":"Duboo 学习笔记","uri":"/posts/duboo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"配置服务消费者 定义服务接口 定义与服务提供者相同的服务接口，全类名相同 配置引用远程服务 Spring 配置文件配置远程服务 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"\u003e \u003c!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --\u003e \u003cdubbo:application name=\"consumer-of-helloworld-app\" /\u003e \u003c!-- 使用multicast广播注册中心暴露发现服务地址 --\u003e \u003c!-- \u003cdubbo:registry address=\"multicast://224.5.6.7:1234\" /\u003e --\u003e \u003c!-- 生成远程服务代理，可以和本地bean一样使用demoService --\u003e \u003cdubbo:reference id=\"demoService\" interface=\"org.apache.dubbo.demo.DemoService url=\"dubbo://localhost:20880\" /\u003e \u003c/beans\u003e Spring boot 注解配置 在消费者类中使用 Reference 注解配置远程地址 import com.alibaba.dubbo.config.annotation.Reference; import com.cskaoyan.dubbo.provider.api.demoService; import org.springframework.stereotype.Component; @Component public class Consumer { @Refrence(url = \"dubbo://localhost:20880\") DemoService demoService; public void sendMsg(String name){ System.out.println(demoService.sayHello(name)); } } ","date":"2022-04-21","objectID":"/posts/duboo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:3","tags":["Dubbo"],"title":"Duboo 学习笔记","uri":"/posts/duboo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"服务注册和服务发现 上述过程都是直连提供者，是一种点对点的调用模式，这种模式主要是用于测试环境，而在线上环境中，服务请求更多，因此需要使用服务中心来协调服务。 ZooKeeper 是一个中间件，负责分布式系统提供协调服务 ","date":"2022-04-21","objectID":"/posts/duboo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:0","tags":["Dubbo"],"title":"Duboo 学习笔记","uri":"/posts/duboo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"安装 ZooKeeper archlinux 使用 aur 提供的包安装即可，并启动服务 yay -S zookeeper sudo systemctl start zookeeper.service ","date":"2022-04-21","objectID":"/posts/duboo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:1","tags":["Dubbo"],"title":"Duboo 学习笔记","uri":"/posts/duboo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"导入依赖 Spring 框架导入依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.101tec\u003c/groupId\u003e \u003cartifactId\u003ezkclient\u003c/artifactId\u003e \u003cversion\u003e1.0\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.zookeeper\u003c/groupId\u003e \u003cartifactId\u003ezookeeper\u003c/artifactId\u003e \u003cversion\u003e3.4.9\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003c/dependency\u003e Spring boot 导入依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.101tec\u003c/groupId\u003e \u003cartifactId\u003ezkclient\u003c/artifactId\u003e \u003cversion\u003e0.10\u003c/version\u003e \u003c/dependency\u003e ","date":"2022-04-21","objectID":"/posts/duboo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:2","tags":["Dubbo"],"title":"Duboo 学习笔记","uri":"/posts/duboo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"配置 Spring 整合配置 服务提供者配置 修改服务端的注册地址 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"\u003e \u003c!-- 提供方应用信息，用于计算依赖关系 --\u003e \u003cdubbo:application name=\"hello-world-app\" /\u003e \u003c!-- 使用multicast广播注册中心暴露服务地址 --\u003e \u003cdubbo:registry address=\"zookeeper://localhost:2181\" /\u003e \u003c!-- 用dubbo协议在20880端口暴露服务 --\u003e \u003cdubbo:protocol name=\"dubbo\" port=\"20880\" /\u003e \u003c!-- 声明需要暴露的服务接口 --\u003e \u003cdubbo:service interface=\"org.apache.dubbo.demo.DemoService\" ref=\"demoService\"/\u003e \u003c!-- 和本地bean一样实现服务 --\u003e \u003cbean id=\"demoService\" class=\"org.apache.dubbo.demo.provider.DemoServiceImpl\" /\u003e \u003c/beans\u003e 服务消费者配置 修改服务消费者注册中心 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"\u003e \u003c!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --\u003e \u003cdubbo:application name=\"consumer-of-helloworld-app\" /\u003e \u003c!-- 使用multicast广播注册中心暴露发现服务地址 --\u003e \u003cdubbo:registry address=\"zookeeper://localhost:2181\" /\u003e \u003c!-- 生成远程服务代理，可以和本地bean一样使用demoService --\u003e \u003cdubbo:reference id=\"demoService\" interface=\"org.apache.dubbo.demo.DemoService\"/\u003e \u003c/beans\u003e Spring boot 整合配置 服务提供者配置 在服务提供者的 spring boot 配置文件中配置 dubbo 的注册地址 spring.application.name=dubbo-spring-boot-starter spring.dubbo.server=true spring.dubbo.registry=zookeeper://localhost:2181 服务消费者配置 在服务消费者的 spring boot 配置文件中配置 dubbo 的注册地址，同时去掉服务消费者类的 url 设置。 pring.dubbo.registry=zookeeper://localhost:2181 ","date":"2022-04-21","objectID":"/posts/duboo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:3","tags":["Dubbo"],"title":"Duboo 学习笔记","uri":"/posts/duboo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"参考资料 Dubbo 文档 ","date":"2022-04-21","objectID":"/posts/duboo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:0","tags":["Dubbo"],"title":"Duboo 学习笔记","uri":"/posts/duboo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["深度学习"],"content":"前言 深度学习导入数据常用的两个工具类就是 Dataset 和 Dataloader，其中 Dataset 是 Dataloder 实例化所需要的参数。 ","date":"2022-04-20","objectID":"/posts/dataset-sampler-%E5%92%8C-dataloader-%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB.html/:1:0","tags":["pytorch"],"title":"Dataset 、 Sampler 和 Dataloader 三者的关系","uri":"/posts/dataset-sampler-%E5%92%8C-dataloader-%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB.html/"},{"categories":["深度学习"],"content":"三者关系 ","date":"2022-04-20","objectID":"/posts/dataset-sampler-%E5%92%8C-dataloader-%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB.html/:2:0","tags":["pytorch"],"title":"Dataset 、 Sampler 和 Dataloader 三者的关系","uri":"/posts/dataset-sampler-%E5%92%8C-dataloader-%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB.html/"},{"categories":["深度学习"],"content":"Dataset Dataset 是用来装数据集的抽象类，因此必须通过继承它来实例化对象。所有 Dataset 的子类都必须重写 __getitem__() 方法，可选择重写 __len__() 方法，但 Sampler 和 Dataloader 都需要使用该方法来获取数据集的大小，所以该方法一般都会进行重写。 ","date":"2022-04-20","objectID":"/posts/dataset-sampler-%E5%92%8C-dataloader-%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB.html/:2:1","tags":["pytorch"],"title":"Dataset 、 Sampler 和 Dataloader 三者的关系","uri":"/posts/dataset-sampler-%E5%92%8C-dataloader-%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB.html/"},{"categories":["深度学习"],"content":"Sampler Sampler 是用来对 Dataset 对象进行抽样的，生成一系列的 index，并按照 batch 进行合并为 indices 返回。pytoch 内部实现的 Sampler 有如下几种： SequentialSampler：顺序采样 RandomSampler：随机采样 SubsetRandomSampler： 子集合随机采用 BatchSampler：批量采样 DistributedSampler：按某概率分布进行采样 Sampler 也会作为参数实例化 Dataloader，实例化时，会传入两个参数，sampler 和 batch_sampler 。 如果你自定义了batch_sampler,那么这些参数都必须使用默认值：batch_size, shuffle,sampler,drop_last. 如果你自定义了sampler，那么shuffle需要设置为False 如果sample 和batch_sampler都为None,那么batch_sampler使用Pytorch已经实现好的BatchSampler,而sampler分两种情况 分两种情况： 若shuffle=True,则sampler=RandomSampler(dataset) 若shuffle=False,则sampler=SequentialSampler(dataset) ","date":"2022-04-20","objectID":"/posts/dataset-sampler-%E5%92%8C-dataloader-%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB.html/:2:2","tags":["pytorch"],"title":"Dataset 、 Sampler 和 Dataloader 三者的关系","uri":"/posts/dataset-sampler-%E5%92%8C-dataloader-%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB.html/"},{"categories":["深度学习"],"content":"Dataloader Dataloader 实例方法如下: torch.utils.data.DataLoader(dataset, batch_size=1, shuffle=False, sampler=None, batch_sampler=None, num_workers=0, collate_fn=None, pin_memory=False, drop_last=False, timeout=0, worker_init_fn=None, multiprocessing_context=None, generator=None, ***, prefetch_factor=2, persistent_workers=False)， num_workers: 多进程的数量，正整数，使用多进程加载数据。当在 windows 下使用时，需要设置为 0，否则会抛出异常（历史遗留bug，也可以通过其他设置修正） collate_fn：整合函数，为 None 时，则默认为 default_collate() 。 default_collate([(0, 1), (2, 3)]) # [tensor([0, 2]), tensor([1, 3])] default_collate([[0, 1], [2, 3]]) # [tensor([0, 2]), tensor([1, 3])] pin_memory：在返回数据之前，会将数据拷贝至 cuda 上 drop_last：将最后一个批量数据丢弃 Dataloader 对象通过 foreach 循环自动调用 __next__() ，__next__() 函数会自动调用 Sampler 的 __iter__() 的方法， __iter__() 方法会自动调用 Dataset 的 __getitem__() 来获取对象（python 的迭代器实现的功能 迭代器与生成器 ）。 ","date":"2022-04-20","objectID":"/posts/dataset-sampler-%E5%92%8C-dataloader-%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB.html/:2:3","tags":["pytorch"],"title":"Dataset 、 Sampler 和 Dataloader 三者的关系","uri":"/posts/dataset-sampler-%E5%92%8C-dataloader-%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB.html/"},{"categories":["深度学习"],"content":"参考资料 一文弄懂Pytorch的DataLoader, DataSet, Sampler之间的关系 Pytorch doc ","date":"2022-04-20","objectID":"/posts/dataset-sampler-%E5%92%8C-dataloader-%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB.html/:3:0","tags":["pytorch"],"title":"Dataset 、 Sampler 和 Dataloader 三者的关系","uri":"/posts/dataset-sampler-%E5%92%8C-dataloader-%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB.html/"},{"categories":["Spring"],"content":"前言 当用户访问网站时，需要判断用户用户是否登陆以及权限问题，这时需要对用户进行认证和授权。Spring 框架提供了 spring security 权限框架，但是与 spring 过于耦合，而 shiro 是 apache 的一个开源框架，是一个权限管理的框架，实现 用户认证、用户授权. shiro 工作流程 ","date":"2022-04-20","objectID":"/posts/shiro-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:1:0","tags":["shiro"],"title":"Shiro 学习笔记","uri":"/posts/shiro-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"使用流程 ","date":"2022-04-20","objectID":"/posts/shiro-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:0","tags":["shiro"],"title":"Shiro 学习笔记","uri":"/posts/shiro-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"导入依赖 shiro-spring 提供了与 spring 整合的依赖，同时还附带了 shiro 的三个依赖。 \u003cdependency\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-spring\u003c/artifactId\u003e \u003cversion\u003e1.2.3\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.slf4j\u003c/groupId\u003e \u003cartifactId\u003eslf4j-log4j12\u003c/artifactId\u003e \u003cversion\u003e1.7.25\u003c/version\u003e \u003c/dependency\u003e ","date":"2022-04-20","objectID":"/posts/shiro-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:1","tags":["shiro"],"title":"Shiro 学习笔记","uri":"/posts/shiro-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"SecurityManager 配置 SecurityManager 是 shiro 核心模块，需要对其进行初始化。 使用配置文件初始化（了解） 当不使用配置类时，可以使用配置文件进行初始化。首先需要心配置 shiro 的配置文件 shiro.ini 。 [user] #username=password zhangsan=123456 使用 IniSecurityManagerFactory 和配置文件初始化工厂，并使用工厂对象获得 SecurityManager 的对象，并将 securityManager 设置为当前权限管理对象。 Factory\u003cSecurityManager\u003e factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\"); SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); 使用配置类时 @Bean public DefaultWebSecurityManager defaultWebSecurityManager(@Qualifier(\"userRealm\") USerRealm userRealm, DefaultWebSessionManager defaultWebSessionManager){ DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager(); defaultWebSecurityManager.setRealm(userRealm); defaultWebSecurityManager.setSessionManager(defaultWebSessionManager); return defaultWebSecurityManager; } ","date":"2022-04-20","objectID":"/posts/shiro-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:2","tags":["shiro"],"title":"Shiro 学习笔记","uri":"/posts/shiro-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"获取 Subject 对象 通过 SecurityUtils 即可以获取到 subject 对象，该对象调用 login 方法时，会执行 Realm 的认证和授权步骤。如果没有指定 Realm 时，则会执行默认的 IniRealm 下的方法，该默认的 IniRealm 方法会在 ini 文件查询用户信息。如果验证失败，则抛出异常。 Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(username, password); try { subject.login(token); return \"index\"; }catch (UnknownAccountException e){ model.addAttribute(\"msg\", \"用户名错误\"); return \"login\"; }catch (IncorrectCredentialsException e){ model.addAttribute(\"msg\", \"密码错误\"); return \"login\"; } ","date":"2022-04-20","objectID":"/posts/shiro-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:3","tags":["shiro"],"title":"Shiro 学习笔记","uri":"/posts/shiro-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"自定义 Realm 默认的 Realm 无法满足用户需求，一般需要继承 AuthorizingRealm 对象，并重写认证和授权的方法。当返回结果为 null 时，则抛出异常。 public class USerRealm extends AuthorizingRealm { @Autowired UserService userService; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { System.out.println(\"执行授权\"); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.addStringPermission(\"user:add\"); Set\u003cString\u003e set = new HashSet\u003c\u003e(); set.add(\"user.add\"); return info; } @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { System.out.println(\"执行认证\"); UsernamePasswordToken usertoken = (UsernamePasswordToken) authenticationToken; User user = userService.queryUserByName(usertoken.getUsername()); if(user == null){ return null; } return new SimpleAuthenticationInfo(\"\", user.getPassword(), \"\"); } } 使用配置文件（了解） 需要在 shiro-ini 配置文件中设置 Realm [main] # 需要全类名 customReal=com.cskaoyan.shiro.CustomShiro securityManager.realm=$userRealm 使用配置类 需要在 SecurityManager 对象内设置自定义的 Realm。 defaultWebSecurityManager.setRealm(userRealm); ","date":"2022-04-20","objectID":"/posts/shiro-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:4","tags":["shiro"],"title":"Shiro 学习笔记","uri":"/posts/shiro-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"配置Filter 服务器内的资源并不是对所有用户都是可以访问的，需要对资源进行权限管理（也可以对用户进行权限管理，但用户管理起来更加不方便，同时是对用户进行角色划分，同时对资源根据不同的角色进行权限管理），这时需要使用过滤器对不同的 url 进行权限设置。 使用配置文件 首先在 web.xml 文件中配置 shiro 的过滤器。 \u003cfilter\u003e \u003cfilter-name\u003eshiro\u003c/filter-name\u003e \u003cfilter-class\u003eorg.springframework.web.filter.DelegatingFilterProxy\u003c/filter-class\u003e \u003cinit-param\u003e \u003cparam-name\u003etargetFilterLifecycle\u003c/param-name\u003e \u003cparam-value\u003etrue\u003c/param-value\u003e \u003c/init-param\u003e \u003cinit-param\u003e \u003cparam-name\u003etargetBeanName\u003c/param-name\u003e \u003cparam-value\u003eshiroFilter\u003c/param-value\u003e \u003c/init-param\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eshiro\u003c/filter-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e 接着 spring 的配置文件 application.xml 配置过滤选项，验证 url 路径由上至下依次匹配。 \u003cbean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\"\u003e \u003cproperty name=\"securityManager\" ref=\"securityManager\"/\u003e \u003cproperty name=\"loginUrl\" value=\"/login\"/\u003e \u003cproperty name=\"unauthorizedUrl\" value=\"/unAuthor\"/\u003e \u003cproperty name=\"filterChainDefinitions\"\u003e \u003cvalue\u003e /refuse = anon /index.jsp = anon /login.jsp = anon /login = anon /logout = logout /** = authc \u003c/value\u003e \u003c/property\u003e \u003c/bean\u003e 标签名称 标签条件（均是显示标签内容） shiro:authenticated 登录之后 shiro:notAuthenticated 不在登录状态时 shiro:guest 用户在没有RememberMe时 shiro:user 用户在RememberMe时 \u003cshiro:hasAnyRoles name=“abc,123” \u003e 在有abc或者123角色时 \u003cshiro:hasRole name=“abc”\u003e 拥有角色abc \u003cshiro:lacksRole name=“abc”\u003e 没有角色abc \u003cshiro:hasPermission name=“abc”\u003e 拥有权限资源abc \u003cshiro:lacksPermission name=“abc”\u003e 没有abc权限资源 shiro:principal 显示用户身份名称 \u003cshiro:principal property=“username”/\u003e 显示用户身份中的属性值 当认证出现错误时，返回给用户的不应该是一个异常，而是需要对其进行重定向进行重新认证，上述配置中的 unauthorizedUrl 异常对应为认证异常重定向的 url ，loginUrl 对应的为登陆的 url ，logout 为注销的的url ，该 url 可以不配置映射即可以使用。 使用配置类 通过 ShiroFilterFactoryBean 工厂对象设置 url 权限。该权限为一个 map，key 对应的是 url 路径，而 value 对应的为所需要的权限。 filterMap.put(\"/user/add\", \"perms[user:add]\"); filterMap.put(\"/user/*\", \"authc\"); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap); shiroFilterFactoryBean.setLoginUrl(\"/tologin\"); shiroFilterFactoryBean.setUnauthorizedUrl(\"/noauth\"); 当存在大量的 url 时，使用 map 管理起来可能不方便，则可以使用注解的方式，则需要在相应的 controller 配置权限控制。 使用注解是，需要导入 aop 技术，即需要导入 aspectjweaver 依赖，同时在 application-mvc.xml 中注册 advisor 对象。 \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.6.12\u003c/version\u003e \u003c/dependency\u003e \u003cbean class=\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\"\u003e \u003cproperty name=\"securityManager\" ref=\"securityManager\"/\u003e \u003c/bean\u003e @RequestMapping(\"/user/query\") @RequiresPermissions(value = {\"user:query\", \"user:delete\"}, logical = Logical.OR) public String queryUser(String name, Model model){ User user = userService.queryUserByName(name); model.addAttribute(\"user\", user); return \"/WEB-INF/view/user.jsp\"; } Shiro共有5个注解， 详细如下 RequiresAuthentication: 使用该注解标注的类，实例，方法在访问或调用时，当前Subject必须在当前session中已经过认证。 RequiresGuest: 使用该注解标注的类，实例，方法在访问或调用时，当前Subject可以是“gust”身份，不需要经过认证或者在原先的session中存在记录。 RequiresPermissions: 当前Subject需要拥有某些特定的权限时，才能执行被该注解标注的方法。如果当前Subject不具有这样的权限，则方法不会被执行。 RequiresRoles: 当前Subject必须拥有所有指定的角色时，才能访问被该注解标注的方法。如果当天Subject不同时拥有所有指定角色，则方法不会执行还会抛出AuthorizationException异常。 RequiresUser 当前Subject必须是应用的用户，才能访问或调用被该注解标注的类，实例，方法。 注意：Shiro的认证注解处理是有内定的处理顺序的，如果有个多个注解的话，前面的通过了会继续检查后面的，若不通过则直接返回，处理顺序依次为（与实际声明顺序无关） ","date":"2022-04-20","objectID":"/posts/shiro-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:5","tags":["shiro"],"title":"Shiro 学习笔记","uri":"/posts/shiro-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"其他 使用 shiro 对查询用户的权限时，都是通过访问数据库进行查询，为了减少磁盘的 IO，可以使用缓存来减少磁盘的 IO，shiro 默认是关闭认证信息缓存的，对于授权信息的缓存shiro默认开启的，但需要导入依赖和配置其 cacheManager。 \u003cdependency\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-ehcache\u003c/artifactId\u003e \u003cversion\u003e1.2.3\u003c/version\u003e \u003c/dependency\u003e \u003c!-- 缓存ehcache --\u003e \u003cdependency\u003e \u003cgroupId\u003enet.sf.ehcache\u003c/groupId\u003e \u003cartifactId\u003eehcache\u003c/artifactId\u003e \u003cversion\u003e2.8.1\u003c/version\u003e \u003c/dependency\u003e 同时注册 EhCacheManager，并在 SecurityManager 中设置相应的 cacheManager。 \u003cbean id=\"cacheManager\" class=\"org.apache.shiro.cache.ehcache.EhCacheManager\"\u003e \u003cproperty name=\"cacheManagerConfigFile\" value=\"classpath:shiro-ehcache.xml\"/\u003e \u003c/bean\u003e \u003cbean id=\"securtyManager\" class=\"org.apache.shiro.web.mgt.Default.WebSecurityManager\"\u003e \u003cproperty name=\"cacheManager\" ref=\"cacheManager\"/\u003e \u003c/bean\u003e 当用户权限时，缓存的信息不会更改，如果权限发生变化时，则需要更新缓存。可以在更新权限的同时，同时调用更新缓存的方法。 ","date":"2022-04-20","objectID":"/posts/shiro-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:0","tags":["shiro"],"title":"Shiro 学习笔记","uri":"/posts/shiro-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Python"],"content":"前言 为了更好的了解 python import 的功能，需要知道 python 中类、模块和包的概念和区别。 ","date":"2022-04-17","objectID":"/posts/python-%E7%B1%BB%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85.html/:1:0","tags":["python"],"title":"Python 类、模块和包","uri":"/posts/python-%E7%B1%BB%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85.html/"},{"categories":["Python"],"content":"定义 ","date":"2022-04-17","objectID":"/posts/python-%E7%B1%BB%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85.html/:2:0","tags":["python"],"title":"Python 类、模块和包","uri":"/posts/python-%E7%B1%BB%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85.html/"},{"categories":["Python"],"content":"类 python 作为面向对象的语言，提供了使用 class 关键字来定义一个类，并且支持面向对象编程（OOP）的所有标准特性：类的继承机制支持多个基类、派生的类能覆盖基类的方法、类的方法能调用基类中的同名方法。对象可包含任意数量和类型的数据。 ","date":"2022-04-17","objectID":"/posts/python-%E7%B1%BB%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85.html/:2:1","tags":["python"],"title":"Python 类、模块和包","uri":"/posts/python-%E7%B1%BB%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85.html/"},{"categories":["Python"],"content":"模块 模块就是一个 python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。 ","date":"2022-04-17","objectID":"/posts/python-%E7%B1%BB%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85.html/:2:2","tags":["python"],"title":"Python 类、模块和包","uri":"/posts/python-%E7%B1%BB%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85.html/"},{"categories":["Python"],"content":"包 python 中的包是一个文件夹，该文件夹下包含若干个模块和文件夹，且该文件夹下还必须包含一个 __init__.py 文件，若子文件夹下仍然含有 __init__.py 文件，则该文件夹为对应包的子包。 ","date":"2022-04-17","objectID":"/posts/python-%E7%B1%BB%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85.html/:2:3","tags":["python"],"title":"Python 类、模块和包","uri":"/posts/python-%E7%B1%BB%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85.html/"},{"categories":["Python"],"content":"基本使用 ","date":"2022-04-17","objectID":"/posts/python-%E7%B1%BB%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85.html/:3:0","tags":["python"],"title":"Python 类、模块和包","uri":"/posts/python-%E7%B1%BB%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85.html/"},{"categories":["Python"],"content":"导入类 因为类是在模块当中的，需要从模块中导入类 from modle import classname ","date":"2022-04-17","objectID":"/posts/python-%E7%B1%BB%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85.html/:3:1","tags":["python"],"title":"Python 类、模块和包","uri":"/posts/python-%E7%B1%BB%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85.html/"},{"categories":["Python"],"content":"导入模块 导入整个模块： import model 导入模块中的所有类 from model import * 导入某个包内的模块 from package import module # 或者 import package.module_a ","date":"2022-04-17","objectID":"/posts/python-%E7%B1%BB%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85.html/:3:2","tags":["python"],"title":"Python 类、模块和包","uri":"/posts/python-%E7%B1%BB%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85.html/"},{"categories":["Python"],"content":"常见问题 python 导包会从 PYTHONPATH 环境路径中逐级查找，如果没有找到则抛出异常，第一个是执行文件所在的路径，即会先从当前文件下进行搜索。常看导包的环境路径 import sys print(sys.path) ","date":"2022-04-17","objectID":"/posts/python-%E7%B1%BB%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85.html/:3:3","tags":["python"],"title":"Python 类、模块和包","uri":"/posts/python-%E7%B1%BB%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85.html/"},{"categories":["Spring"],"content":"前言 Spring MVC 框架帮我们做了参数封装，动作解耦，结果视图的转向，json结果的生成等，但参数和合法性验证没有实现，需要自己手动实现。而参数校验属于业务逻辑以外的项目，为了将这些代码解耦出来，可以使用 Hibernate Validator 框架提供的参数校验注解功能。 hibernate_validator 验证逻辑 ","date":"2022-04-14","objectID":"/posts/hibernate-validator-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:1:0","tags":["Hibernate"],"title":"Hibernate Validator 学习笔记","uri":"/posts/hibernate-validator-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"使用流程 ","date":"2022-04-14","objectID":"/posts/hibernate-validator-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:0","tags":["Hibernate"],"title":"Hibernate Validator 学习笔记","uri":"/posts/hibernate-validator-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"导入依赖 \u003c!-- validation --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.hibernate\u003c/groupId\u003e \u003cartifactId\u003ehibernate-validator\u003c/artifactId\u003e \u003cversion\u003e5.1.0.Final\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.validation\u003c/groupId\u003e \u003cartifactId\u003evalidation-api\u003c/artifactId\u003e \u003cversion\u003e1.1.0.Final\u003c/version\u003e \u003c/dependency\u003e ","date":"2022-04-14","objectID":"/posts/hibernate-validator-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:1","tags":["Hibernate"],"title":"Hibernate Validator 学习笔记","uri":"/posts/hibernate-validator-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"注册 在 application.xml （或者application-mvc.xml）配置文件中添加配置，即向 Spring MVC 容器中注册 validator 对象，并添加验证驱动。 \u003cbean id=\"validator\" class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\"\u003e \u003cproperty name=\"providerClass\" value=\"org.hibernate.validator.HibernateValidator\"/\u003e \u003c/bean\u003e \u003cmvc:annotation-driven validator=\"validator\"/\u003e ","date":"2022-04-14","objectID":"/posts/hibernate-validator-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:2","tags":["Hibernate"],"title":"Hibernate Validator 学习笔记","uri":"/posts/hibernate-validator-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"数据验证 在向需要验证的 Bean 的属性字段上添加所需要验证方式的注解。 @Size(min = 6, max = 8, message = \"size error\") String password; 其中 message 为验证错误时给出的错误信息，并在需要验证的传入参数添加 @Valid 注解 @Controller public class UserController { @RequestMapping(\"login\") public String login(@Valid User user){ return \"/WEB-INF/view/show.jsp\"; } } ","date":"2022-04-14","objectID":"/posts/hibernate-validator-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:3","tags":["Hibernate"],"title":"Hibernate Validator 学习笔记","uri":"/posts/hibernate-validator-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"常用注解 @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式 Hibernate Validator 附加的 constraint @NotBlank(message =) 验证字符串非null，且长度必须大于0 @Email 被注释的元素必须是电子邮箱地址 @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内 ","date":"2022-04-14","objectID":"/posts/hibernate-validator-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:0","tags":["Hibernate"],"title":"Hibernate Validator 学习笔记","uri":"/posts/hibernate-validator-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"前言 Druid 是 Alibab 开源的数据连接池，目前Java社区使用广泛的的数据库连接池，在功能、性能、扩展性方面，都超过其他数据库连接池，包括DBCP、C3P0、BoneCP、Proxool、JBoss DataSource。 ","date":"2022-04-14","objectID":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:1:0","tags":["Druid"],"title":"Druid 数据库连接池学习笔记","uri":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"使用流程 ","date":"2022-04-14","objectID":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:0","tags":["Druid"],"title":"Druid 数据库连接池学习笔记","uri":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"导入依赖 在 pom 文件导入 druid 相关依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid\u003c/artifactId\u003e \u003cversion\u003e${druid-version}\u003c/version\u003e \u003c/dependency\u003e ","date":"2022-04-14","objectID":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:1","tags":["Druid"],"title":"Druid 数据库连接池学习笔记","uri":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"更改连接池 之前学习 Spring 框架时候用的是 c3p0 连接池，现在只需要更换连接池类就可以了。 \u003cbean id=\"datasource\" class=\"com.alibaba.druid.pool.DruidDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/j13_jdbc_template?serverTimezone=GMT\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"admin\"/\u003e \u003cproperty name=\"filters\" value=\"stat\"/\u003e \u003c/bean\u003e ","date":"2022-04-14","objectID":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:2","tags":["Druid"],"title":"Druid 数据库连接池学习笔记","uri":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"开启性能监控 在 web.xml 文件中添加如下配置内容 \u003cservlet\u003e \u003cservlet-name\u003eDruidStatView\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.alibaba.druid.support.http.StatViewServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eDruidStatView\u003c/servlet-name\u003e \u003curl-pattern\u003e/druid/*\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003c!-- 配置druid监控--\u003e \u003cfilter\u003e \u003cfilter-name\u003eDruidWebStatFilter\u003c/filter-name\u003e \u003cfilter-class\u003ecom.alibaba.druid.support.http.WebStatFilter\u003c/filter-class\u003e \u003cinit-param\u003e \u003cparam-name\u003eexclusions\u003c/param-name\u003e \u003cparam-value\u003e*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*\u003c/param-value\u003e \u003c/init-param\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eDruidWebStatFilter\u003c/filter-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e ","date":"2022-04-14","objectID":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:3","tags":["Druid"],"title":"Druid 数据库连接池学习笔记","uri":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"查看 启动服务器，在 http://localhost/yourproject/druid/index.html 访问监控页面。 ","date":"2022-04-14","objectID":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:4","tags":["Druid"],"title":"Druid 数据库连接池学习笔记","uri":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"参考资料 官方仓库 ","date":"2022-04-14","objectID":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:0","tags":["Druid"],"title":"Druid 数据库连接池学习笔记","uri":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"前言 SSM 框架缩写是由 Spring 、 Spring MVC 和 Mybatis 三个单词首字母组合而成，将三者组合一起使用，就是常说的 SSM 框架。 ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:1:0","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Spring"],"content":"通过 xml 文件整合 ssm ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:2:0","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Spring"],"content":"导包 导入三个组件的依赖，其中 mybatis 提供了整合 spring 的 jar 包（mybatis-spring） \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e \u003cartifactId\u003ejavax.servlet-api\u003c/artifactId\u003e \u003cversion\u003e3.1.0\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.3.17\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.12\u003c/version\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.4.6\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e2.0.1\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.3.17\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.mchange\u003c/groupId\u003e \u003cartifactId\u003ec3p0\u003c/artifactId\u003e \u003cversion\u003e0.9.5.2\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:2:1","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Spring"],"content":"配置 sqlSessionFactory 在 application.xml 配置文件中，向容器中注册连接池 datasource，配置 c3p0 的datasource 连接池（后续更换 druid 连接池，性能更换好）。在向 spring 容器中注册 sqlSessionFactoryBean，后续通过其获得 sqlSession对象。 \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"typeAliasesPackage\" value=\"com.cskaoyan.bean\"/\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\"/\u003e \u003c/bean\u003e \u003cbean id=\"datasource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"\u003e \u003cproperty name=\"driverClass\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/j13_jdbc_template?serverTimezone=GMT\"/\u003e \u003cproperty name=\"user\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"admin\"/\u003e \u003c/bean\u003e ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:2:2","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Spring"],"content":"获取 mapper 对象 通过 mapper 接口的实现类。 @Repository public class UserMapperImpl implements UserMapper { @Autowired SqlSessionFactory sqlSessionFactory; @Override public User queryUserById(int id) { SqlSession sqlSession = sqlSessionFactory.openSession(); return null; } } 通过配置文件 在 application.xml 向容器中注册 MapperFactoryBean 对象。 \u003cbean class=\"org.mybatis.spring.mapper.MapperFactoryBean\"\u003e \u003cproperty name=\"mapperInterface\" value=\"com.cskaoyan.mapper.UserMapper\"/\u003e \u003cproperty name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/\u003e \u003c/bean\u003e 该方法缺点是每个 mapper 接口都需要在配置文件中编写 MapperFactoryBean。 注册 MapperScannerConfigurer 对象（常用方法，后续换成注解方式） 向容器中注册映射接口扫描对象，并配置扫描范围，使用 sqlSessionFactory 来生成映射对象。 \u003cbean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"\u003e \u003cproperty name=\"basePackage\" value=\"com.cskaoyan.mapper\"/\u003e \u003cproperty name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/\u003e \u003c/bean\u003e ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:2:3","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Spring"],"content":"配置 Spring MVC 在 web.xml 文件中配置 DispatherServlet \u003cservlet\u003e \u003cservlet-name\u003edispatcherServlet\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:application.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003edispatcherServlet\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 在 application.xml 注册 mvc 扫描驱动和 事务驱动 \u003ccontext:component-scan base-package=\"com.cskaoyan\"/\u003e \u003cmvc:annotation-driven/\u003e \u003cbean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\"/\u003e \u003c/bean\u003e \u003ctx:annotation-driven transaction-manager=\"txManger\"/\u003e ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:2:4","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Spring"],"content":"父子容器配置 上述过程将 spring 和 spring mvc 配置在一块，可以将二者分来开来，其中 spring 作为主容器，spring mvc 作为子容器。 在 web.xml 文件中使用 listener 标签加载 spring 容器，并设置 mvc 子容器的配置文件所在位置。 \u003clistener\u003e \u003clistener-class\u003eorg.springframework.web.context.ContextLoaderListener\u003c/listener-class\u003e \u003c/listener\u003e \u003ccontext-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:application.xml\u003c/param-value\u003e \u003c/context-param\u003e \u003cservlet\u003e \u003cservlet-name\u003edispatcherServlet\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:application_mvc.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003edispatcherServlet\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 父容器的配置文件为 applicatio.xml，子容器的配置为 application.xml。 父容器的配置内容为：其中 SpringBean 为 spring 容器的配置类，用来向 Spring 容器中注册类。 \u003ccontext:component-scan base-package=\"com.cskaoyan\"\u003e \u003ccontext:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/\u003e \u003c/context:component-scan\u003e \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"typeAliasesPackage\" value=\"com.cskaoyan.bean\"/\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\"/\u003e \u003c/bean\u003e \u003cbean id=\"datasource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"\u003e \u003cproperty name=\"driverClass\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/j13_jdbc_template?serverTimezone=GMT\"/\u003e \u003cproperty name=\"user\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"admin\"/\u003e \u003c/bean\u003e \u003cbean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"\u003e \u003cproperty name=\"basePackage\" value=\"com.cskaoyan.mapper\"/\u003e \u003cproperty name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/\u003e \u003c/bean\u003e \u003cbean class=\"com.cskaoyan.bean.SpringBean\"/\u003e 子容器配置内容为：其中 SpringMvcBean 容器的配置类，用来向 Spring MVC 容器中注册类。 \u003ccontext:component-scan base-package=\"com.cskaoyan.controller\"/\u003e \u003cmvc:annotation-driven/\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"\u003e \u003cproperty name=\"prefix\" value=\"/WEB-INF/view/\"/\u003e \u003cproperty name=\"suffix\" value=\".jsp\"/\u003e \u003c/bean\u003e \u003cbean class=\"com.cskaoyan.bean.SpringMvcBean\"/\u003e ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:2:5","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Spring"],"content":"通过配置类整合 ssm 上面通过配置 xml 文件来实现 ssm 整合，也可以通过配置类来实现 ssm 整合。 ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:3:0","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Spring"],"content":"配置启动器类 新建一个启动类，继承抽象类 AbstractAnnotationConfigDispatcherServletInitializer ，并重写父类方法的三个方法。getRootConfigClasses 方法是获得 Spring 容器配置类对象，getServletConfigClasses 方法获得 Spring MVC 容器配置类对象，getServletMappings 设置 DispatcherServlet 的启动路径。 public class ApplicationInitialize extends AbstractAnnotationConfigDispatcherServletInitializer { @Override protected Class\u003c?\u003e[] getRootConfigClasses() { return new Class[]{SpringConfig.class}; } @Override protected Class\u003c?\u003e[] getServletConfigClasses() { return new Class[]{SpringMvcConfig.class}; } @Override protected String[] getServletMappings() { return new String[]{\"/\"}; } } ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:3:1","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Spring"],"content":"配置 Spring 配置类 配置类上使用 @Configuration 和 @ComponentScan 注解，第一个注解是表示该类为一个配置类，第二个配置扫描注解的范围，若在扫描范围内，且含有对应注解，则向 Spring 容器中注册，要注意排除 Spring MVC 注册类扫描的范围 ，否则会向容器生成两个对象。并向 Spring 容器中注册 SqlSessionFactoryBean 、ComboPooledDataSource 和 MapperScannerConfigurer 对象。 @Configuration @ComponentScan(basePackages = \"com.cskaoyan\", excludeFilters = {@ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class, EnableWebMvc.class})}) public class SpringConfig { @Bean(\"sqlSessionFactoryBean\") public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){ SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setTypeAliasesPackage(\"com.cskaoyan.bean\"); sqlSessionFactoryBean.setDataSource(dataSource); return sqlSessionFactoryBean; } @Bean public DataSource dataSource() throws PropertyVetoException { ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(); comboPooledDataSource.setDriverClass(\"com.mysql.cj.jdbc.Driver\"); comboPooledDataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/j13_jdbc_template?serverTimezone=GMT\"); comboPooledDataSource.setUser(\"root\"); comboPooledDataSource.setPassword(\"admin\"); return comboPooledDataSource; } @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); mapperScannerConfigurer.setSqlSessionFactoryBeanName(\"sqlSessionFactoryBean\"); mapperScannerConfigurer.setBasePackage(\"com.cskaoyan.mapper\"); return mapperScannerConfigurer; } } ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:3:2","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Spring"],"content":"配置 Spring MVC 配置类 在配置类上使用 EnableWebMvc 和 ComponentScan 注解，并实现 WebMvcConfigurer 接口。第一个注解表示该类为 Spring MVC 配置类，第二个配置为扫描注解范围，在 Spring MVC 配置类上配置视图解析器。 @EnableWebMvc @ComponentScan(basePackages = \"com.cskaoyan.controller\") public class SpringMvcConfig implements WebMvcConfigurer { @Bean public ViewResolver viewResolver(){ InternalResourceViewResolver internalResourceViewResolver = new InternalResourceViewResolver(); internalResourceViewResolver.setSuffix(\".jsp\"); internalResourceViewResolver.setPrefix(\"/WEB-INF/view/\"); return internalResourceViewResolver; } } ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:3:3","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Spring"],"content":"其他组件 Encoding Filter 为了防止中文传输乱码，在启动类配置文件编码格式 @Override protected Filter[] getServletFilers(){ CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter(); encodingFilter.setEncoding(\"utf-8\"); encodingFilter.setForceEncoding(true); return new Filter[]{encodingFilter}; } Converter 数据转换器，在 Spring MVC 配置类中注册转换器 @Configuration @EnableWebMvc @ComponentScan(basePackages = \"com.cskaoyan.controller\") public class SpringMvcConfig implements WebMvcConfigurer { @Autowired ConfigurableConversionService configurableConversionService; @Bean @Primary public ConfigurableConversionService configurableConversionService(){ return configurableConversionService; } @PostConstruct public void addConverterToService(){ configurableConversionService.addConverter(new MyConverter()); } } File upload 可以通过注册 bean 进行文件上传 @Bean public CommonMultipartResolver multipartResolver(){ CommonMultipartResolver commonMultipartResolver = new CommonMultipartResolver(); commonMultipartResolver.setMaxUploadSize(500000); return commonMultipartResolver; } ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:3:4","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Spring"],"content":"前言 为了记录代码的工作信息，入门操作通常是使用控制台输出来查看记录。而当代码需要长时间工作时，则需要持久化记录。 log4j 是 apache 下日志记录的常用软件，可以在终端输出和在文本内记录应用的工作记录。 ","date":"2022-04-14","objectID":"/posts/log4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:1:0","tags":["log4j"],"title":"log4j 学习笔记","uri":"/posts/log4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"使用流程 ","date":"2022-04-14","objectID":"/posts/log4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:0","tags":["log4j"],"title":"log4j 学习笔记","uri":"/posts/log4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"导包 导入 log4j 的依赖 log4j 1.x 版本导入 \u003cdependency\u003e \u003cgroupId\u003elog4j\u003c/groupId\u003e \u003cartifactId\u003elog4j\u003c/artifactId\u003e \u003cversion\u003e1.2.17\u003c/version\u003e \u003c/dependency\u003e log4j 2.x 版本导入 \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-api\u003c/artifactId\u003e \u003cversion\u003e2.17.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-core\u003c/artifactId\u003e \u003cversion\u003e2.17.2\u003c/version\u003e \u003c/dependency\u003e ","date":"2022-04-14","objectID":"/posts/log4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:1","tags":["log4j"],"title":"log4j 学习笔记","uri":"/posts/log4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"配置 log4j 的配置文件 log4j 1.x ### DEBUG?INFO?WARN?ERROR?FATAL #????+??appender log4j.rootLogger=debug ,file,stdout,file2 #Appender #org.apache.log4j.ConsoleAppender????? #org.apache.log4j.FileAppender???? #org.apache.log4j.DailyRollingFileAppender???????????? #org.apache.log4j.RollingFileAppender??????????????????????? #org.apache.log4j.WriterAppender????????????????????? ### direct log messages to stdout ### log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.Target=System.out log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n ### direct messages to file hibernate.log ### log4j.appender.file=org.apache.log4j.FileAppender log4j.appender.file.File=/home/swq/Desktop/11mybatis.log log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n #org.apache.log4j.HTMLLayout??HTML??????? #org.apache.log4j.PatternLayout????????????? #org.apache.log4j.SimpleLayout????????????????? #org.apache.log4j.TTCCLayout???????????????????? log4j.appender.file2 = org.apache.log4j.FileAppender log4j.appender.file2.File=/home/swq/Desktop/file2.log log4j.appender.file2.layout=org.apache.log4j.SimpleLayout #log4j.appender.file2.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n log4j 2.x 2.x 已经放弃了 properties 方式，而是采用 xml, json 或者 jsn 格式。 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!-- log4j2 配置文件 --\u003e \u003c!-- 日志级别 trace\u003cdebug\u003cinfo\u003cwarn\u003cerror\u003cfatal --\u003e \u003cconfiguration status=\"debug\"\u003e \u003c!-- 自定义属性 --\u003e \u003cProperties\u003e \u003c!-- 日志格式(控制台) --\u003e \u003cProperty name=\"pattern1\"\u003e[%-5p] %d %c - %m%n\u003c/Property\u003e \u003c!-- 日志格式(文件) --\u003e \u003cProperty name=\"pattern2\"\u003e =========================================%n 日志级别：%p%n 日志时间：%d%n 所属类名：%c%n 所属线程：%t%n 日志信息：%m%n \u003c/Property\u003e \u003c!-- 日志文件路径 --\u003e \u003cProperty name=\"filePath\"\u003elogs/myLog.log\u003c/Property\u003e \u003c/Properties\u003e \u003cappenders\u003e \u003cConsole name=\"Console\" target=\"SYSTEM_OUT\"\u003e \u003cPatternLayout pattern=\"${pattern1}\"/\u003e \u003c/Console\u003e \u003cRollingFile name=\"RollingFile\" fileName=\"${filePath}\" filePattern=\"logs/$${date:yyyy-MM}/app-%d{MM-dd-yyyy}-%i.log.gz\"\u003e \u003cPatternLayout pattern=\"${pattern2}\"/\u003e \u003cSizeBasedTriggeringPolicy size=\"5 MB\"/\u003e \u003c/RollingFile\u003e \u003c/appenders\u003e \u003cloggers\u003e \u003croot level=\"debug\"\u003e \u003cappender-ref ref=\"Console\"/\u003e \u003cappender-ref ref=\"RollingFile\"/\u003e \u003c/root\u003e \u003c/loggers\u003e \u003c/configuration\u003e ","date":"2022-04-14","objectID":"/posts/log4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:2","tags":["log4j"],"title":"log4j 学习笔记","uri":"/posts/log4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"使用 log4j 1.x Logger logger = Logger.getLogger(LogTest.class); logger.debug(\"debug\"); logger.warn(\"warn\"); logger.info(\"info\"); logger.error(\"error\"); logger.fatal(\"fatal\"); log4j 2.x Logger logger = LogManager.getLogger(LogTest.class); logger.trace(\"trace level\"); logger.debug(\"debug level\"); logger.info(\"info level\"); logger.warn(\"warn level\"); logger.error(\"error level\"); logger.fatal(\"fatal level\"); 通过传入类名获得其 logger 对象，并使用其打印日志。 ","date":"2022-04-14","objectID":"/posts/log4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:3","tags":["log4j"],"title":"log4j 学习笔记","uri":"/posts/log4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"前言 MyBatis 是一款优秀的持久层框架**，它支持定制化 SQL（灵活的修改）、存储过程（函数）以及高级**映射（javabean和数据库对象的映射-\u003e输入映射和输出映射）。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。 MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJO 映射成数据库中的记录。（ORM和持久化） mybatis 流程图 ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:1:0","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"使用流程 ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:0","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"导入依赖 导入 mybatis 和 mysql 的依赖。 \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.4.6\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.12\u003c/version\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:1","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"配置数据库连接 在 mybatis.xml 配置配置数据库的参数设置连接。主要配置内容为数据库驱动jdbc driver 、 数据库的连接信息和查询映射文件。 映射文件配置有两种方式： 配置 mapper 标签处对应的为 Mapper 配置文件所在的位置rsource 。（配置文件需要与对应的映射接口处于同一个包下） ，如果没有配置，则后续 sql 语句第一个参数为 全类名.sql方法 ， 书写较为复杂。 在 mapper 标签内配置 package 参数，该参数表示配置文件所在的包目录。（主要使用） \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003c!--Managed--\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003c!--UNPooled--\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/j13_jdbc_template?serverTimezone=GMT\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"admin\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003cmapper resource=\"com/cskaoyan/dao/UserDao.xml\"/\u003e \u003c!--\u003cpackage name=\"com.cskaoyan.dao\"/\u003e--\u003e \u003c/mappers\u003e \u003c/configuration\u003e ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:2","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"生成 sqlSession 对象 使用 构建者 模式生成 sqlSession 对象。 public class MainTest { SqlSessionFactory sqlSessionFactory; SqlSession sqlSession; @Before public void init() throws IOException { InputStream inputStream = Resources.getResourceAsStream(\"mybatis.xml\"); //通过建造者创建工厂 sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } @After public void after(){ sqlSession.commit(); sqlSession.close(); } @Test public void mytest(){ sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.queryUserByid(1); System.out.println(user); } } ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:3","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"配置查询语句 在 UserDao.xml 配置文件中使用标签配置 sql 语句，同名的映射接口配置 sql 操作方法，该方法名为 sql 语句的 id 。 \u003cmapper namespace=\"com.cskaoyan.mapper.UserMapper\"\u003e \u003cinsert id=\"insertUser\"\u003e insert into j13_user_t (id, username, password, email) values (#{id}, #{username}, #{password}, #{email}) \u003c/insert\u003e \u003cdelete id=\"deleteUser\"\u003e delete from j13_user_t where id = #{id} \u003c/delete\u003e \u003cupdate id=\"updateUser\"\u003e update j13_user_t set username = #{username} where id = #{id} \u003c/update\u003e \u003c/mapper\u003e public interface UserMapper { User queryUserByid(int id); int insertUser(User user); int deleteUser(int id); int updateUser(User user); } insert 操作的必须配置 resultType（或者 resultMap） ，其他 sql 操作没有该参数选项。 sql 语句中传入的参数如果为基本类型时，则任意写，如果为 javabean 类型，则使用 #{类.属性} 进行选择。可以在调用 sql 语句中，使用注解 @Param 来限制后续选择，比如 int deleteUser(@Param(\"id\")int id); ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:4","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"映射关系 ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:0","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"输入映射 则在配置文件书写 sql 语句时，必须使用 #{id} 来访问传入参数 id 。 简单类型。对应简单基本类型来说，如果没有配置注解 @Param ，则使用名称小写即可（内部以实现映射）。使用了注解，则根据注解使用。 \u003cupdate id=\"updateUser\"\u003e update j13_user_t set username = #{username} where id = #{id} \u003c/update\u003e POJO ：没有使用注解时，使用类的小写即可（其中配置文件必须与类在同一个包下）。使用注解时，根据注解使用。如果传入类型为多个 pojo 类型时，且没有使用注解时，则使用 param1 、param2 来选择参数。使用了注解后，则使用注解对应的名字。（使用注解更加清晰），后续使用 . 来访问类内的属性。 \u003cupdate id=\"updateUser\"\u003e update j13_user_t set username = #{username} where id = #{param1.id} \u003c/update\u003e \u003cupdate id=\"updateUser\"\u003e update j13_user_t set username = #{username} where id = #{user.id} \u003c/update\u003e Map ：若只有一个传入参数，直接使用 Key 获取 Value 。若存在多个传入参数，则使用 param1 、param2 来选择。使用注解后根据注解使用。 \u003cupdate id=\"updateUser\"\u003e update j13_user_t set username = #{username} where id = #{param1.key} \u003c/update\u003e \u003cupdate id=\"updateUser\"\u003e update j13_user_t set username = #{username} where id = #{map.key} \u003c/update\u003e 凡是使用了注解 @Param ，都根据注解进行匹配，尽量使用注解，使用注解可以提高代码可读性。 使用$符号访问参数时，有注入风险，使用#则mybatis会帮我们进行参数预处理 ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:1","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"输出映射 简单类型。查询列必须为单列，才能使用简单类型映射 \u003cselect id=\"selectUser\" resultType=\"string\"\u003e select id from j13_user_t where username = #{user.username} \u003c/update\u003e pojo 对象映射。在 ResultType 字段配置 pojo 对象（因为映射接口和配置文件在同一包下，直接使用类小写即可），且查询列名必须与映射的类的属性名一一对应才能映射成功，如果某属性映射不成功，则设置为null。resultType 为类名的小写（配置文件必须与类在一个包内）。 public class User{ int id; String username; String password; String email; } \u003cselect id=\"selectUser\" resultType=\"user\"\u003e select id,username,password,email from j13_user_t where username = #{user.username} \u003c/update\u003e ResultMap 对象映射。查询的列名不再需要与对象的属性名一一对应，但是需要通过 ResultMap 标签来设置列名和属性名进行映射，其中 column 设置查询的结果的列名，property 设置属性名。 \u003cresultMap id=\"userMap\" type=\"user\"\u003e \u003cresult column=\"id\" property=\"idz\"/\u003e \u003cresult column=\"username\" property=\"usernames\"/\u003e \u003cresult column=\"password\" property=\"passwordw\"/\u003e \u003cresult column=\"email\" property=\"emaill\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"queryUserById\" resultMap=\"userMap\"\u003e select id,username,password,email from j13_user_t where id=#{id} \u003c/select\u003e 上述类中的属性名分别为 idz 、usernames 、passwordw 和 emaill ，将查询结果与对应属性映射起来。 ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:2","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"动态 sql 标签 常用的标签有 where 、 if 、sql 和 foreach 。标签的主要作用是将 sql 语句分成若干段，可以使用 inclde 标签和 refid 属性引用 sql 语句段，从而代码重用，减少冗余代码。 ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:0","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"where 标签 \u003cselect id=\"selectUser\" resultType=\"string\"\u003e select id from j13_user_t \u003cwhere\u003e username = #{user.username} \u003c/where\u003e \u003c/update\u003e ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:1","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"if 标签。 需要注意的是除了第一个 if 标签，后续 if 标签都需要添加 and 或者 or ，来表示层次关系。 \u003cselect id=\"selectUser\" resultType=\"string\"\u003e select id from j13_user_t \u003cwhere\u003e \u003cif test=\"username != null\"\u003e username = #{username} \u003c/if\u003e \u003cif test=\"age != 0\"\u003e and age = #{age} \u003c/if\u003e \u003c/where\u003e \u003c/update\u003e ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:2","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"sql 标签。 主要是用作片段，给其他语句 include 使用。 \u003csql id=\"selectAll\"\u003e select id,username,password,email from j13_user_t \u003c/sql\u003e ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:3","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"foreach 标签。 用来遍历链表或者数组。 未使用注解的数组。collection 使用 array , item 表示每次迭代的对象，separator 表示每次迭代后的连接符号，index 表示索引，从 0 开始。 \u003cinsert id=\"insertArray\"\u003e insert into j13_user_t (id,username,password,email) values \u003cforeach collection=\"array\" item=\"user\" sepatrtor=\",\" index=\"index\"\u003e (#{user.id}, #{user.username},#{user.password},#{user.email}) \u003c/foreach\u003e \u003c/insert\u003e 未使用注解的List。collection 使用 list 。open 和 close 表示迭代后的字符串左右两边的符号。若不使用的这两个属性，需要手动增加两个括号，代码不够优雅。 \u003cinsert id=\"selectUserById\" resultType=\"user\"\u003e select id,username,password,email from j13_uset_t \u003cwhere\u003e id in \u003cforeach collection=\"list\" item=\"userid\" open=\"(\" close\")\"\u003e #(userid) \u003c/foreach\u003e \u003c/where\u003e \u003c/insert\u003e 使用注解的数组和List。 \u003cinsert id=\"insertArray\"\u003e insert into j13_user_t (id,username,password,email) values \u003cforeach collection=\"users\" item=\"user\" sepatrtor=\",\"\u003e (#{user.id}, #{user.username},#{user.password},#{user.email}) \u003c/foreach\u003e \u003c/insert\u003e \u003cinsert id=\"selectUserById\" resultType=\"user\"\u003e select id,username,password,email from j13_uset_t \u003cwhere\u003e id in \u003cforeach collection=\"ids\" item=\"id\" open=\"(\" close\")\"\u003e #(id) \u003c/foreach\u003e \u003c/where\u003e \u003c/insert\u003e ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:4","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"Mybatis 的优化 ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:5:0","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"懒加载 根据数据的使用情况，按需加载 sql 语句。当某个 sql 语句执行完成后，没有书用到其中的数据时，则可以暂时不执行该语句。Mybatis 默认是没有懒加载的，需要在 Myabis 的 mybatis.xml 配置文件中手动开启，同时在映射文件中设置 fetchType 启用懒加载。（连接查询是没有懒加载的） \u003cconfiguration\u003e \u003csettings\u003e \u003csetting name=\"lazyLoadingEnabled\" value=\"true\"/\u003e \u003csetting name=\"cacheEnabled\" value=\"true\"/\u003e \u003c/settings\u003e \u003c/configuration\u003e \u003cresultMap id=\"userMap\" type=\"user\"\u003e \u003cresult column=\"id\" property=\"id\"/\u003e \u003cresult column=\"username\" property=\"username\"/\u003e \u003cresult column=\"password\" property=\"password\"/\u003e \u003cresult column=\"email\" property=\"email\"/\u003e \u003c!--property是我们1的成员变量名--\u003e \u003c!--colume是来源于第一次查询结果的列名，并且为第二次查询提供参数--\u003e \u003cassociation property=\"userDetail\" fetchType=\"lazy\" column=\"id\" select=\"com.cskaoyan.mapper.UserDetailMapper.selectUserDetailByUid\"/\u003e \u003c/resultMap\u003e ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:5:1","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"缓存 为了减少磁盘的IO，mybatis 提供了缓存机制。 mybatis 缓存 一级缓存 一级缓存默认是开启的，一级缓存级别是 sqlSession 级别的，即不同的 sqlSession 不会共享缓存。当 sqlSession commit 提交之后，缓存失效。同时若数据库的数据发生更改、添加和删除时，则缓存失效。 二级缓存 二级缓存默认是关闭的，二级缓存级别是 mapper 级别的，当 sqlSession 提交之后，二级缓存才生成 ，同时不同的 sqlSession 对象（同一个类的不同 sqlSession 对象）的 mapper 也共享当前缓存，如果对数据库进行了增删改操作是，如果没有提交事务，则缓存不会失效，即可能造成幻读，只有提交事务之后缓存才失效，需要注意。 二级缓存需要在 mybatis.xml 配置文件中开启 \u003csettings\u003e \u003csetting name=\"lazyLoadingEnabled\" value=\"true\"/\u003e \u003csetting name=\"cacheEnabled\" value=\"true\"/\u003e \u003c/settings\u003e 如果要对某一个类的进行二级缓存查询时，必须实现序列化接口，进行序列化，否则无法缓存，同时在该类的映射文件在添加 cache 标签。 public class User implements Serializable{ ... } \u003ccache/\u003e ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:5:2","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"逆向工程 为了减少映射文件的书写，可以使用逆向工程生成映射文件。 ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:6:0","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"导包 导包逆向工程的依赖和数据库的依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.generator\u003c/groupId\u003e \u003cartifactId\u003emybatis-generator-core\u003c/artifactId\u003e \u003cversion\u003e1.4.1\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.12\u003c/version\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:6:1","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"配置文件设置 在项目的根目录下配置逆向工程的配置 generatorConfig.xml 。 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"\u003e \u003cgeneratorConfiguration\u003e \u003ccontext id=\"testTables\" targetRuntime=\"MyBatis3\"\u003e \u003ccommentGenerator\u003e \u003c!-- 是否去除自动生成的注释 true：是 ： false:否 --\u003e \u003cproperty name=\"suppressAllComments\" value=\"true\" /\u003e \u003c/commentGenerator\u003e \u003c!--数据库连接的信息：驱动类、连接地址、用户名、密码 --\u003e \u003cjdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/j13_jdbc_template?serverTimezone=GMT\" userId=\"root\" password=\"admin\"\u003e \u003cproperty name=\"nullCatalogMeansCurrent\" value=\"true\"/\u003e \u003c/jdbcConnection\u003e \u003c!--\u0026lt;!\u0026ndash; for oracle \u0026ndash;\u0026gt; \u003cjdbcConnection driverClass=\"oracle.jdbc.OracleDriver\" connectionURL=\"jdbc:oracle:thin:@127.0.0.1:1521:yycg\" userId=\"yycg\" password=\"yycg\"\u003e \u003c/jdbcConnection\u003e--\u003e \u003c!-- 默认false， 为false把JDBC DECIMAL 和 NUMERIC 类型解析为Integer， 为 true把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --\u003e \u003c!--\u003cjavaTypeResolver\u003e \u003cproperty name=\"forceBigDecimals\" value=\"false\" /\u003e \u003c/javaTypeResolver\u003e--\u003e \u003c!-- javaModelGenerator javaBean生成的配置信息 targetProject:生成PO类的位置 targetPackage：生成PO类的类名--\u003e \u003cjavaModelGenerator targetPackage=\"com.cskaoyan.bean\" targetProject=\"./mybatis_demo8/src/main/java\"\u003e \u003c!-- enableSubPackages:是否允许子包,是否让schema作为包的后缀 即targetPackage.schemaName.tableName --\u003e \u003cproperty name=\"enableSubPackages\" value=\"true\" /\u003e \u003c!-- 从数据库返回的值是否清理前后的空格 --\u003e \u003cproperty name=\"trimStrings\" value=\"true\" /\u003e \u003c/javaModelGenerator\u003e \u003c!-- sqlMapGenerator Mapper映射文件的配置信息 targetProject:mapper映射文件生成的位置 targetPackage:生成mapper映射文件放在哪个包下--\u003e \u003csqlMapGenerator targetPackage=\"com.cskaoyan.mapper\" targetProject=\"./mybatis_demo8/src/main/resources\"\u003e \u003c!-- enableSubPackages:是否让schema作为包的后缀 --\u003e \u003cproperty name=\"enableSubPackages\" value=\"true\" /\u003e \u003c/sqlMapGenerator\u003e \u003c!-- javaClientGenerator 生成 Model对象(JavaBean)和 mapper XML配置文件 对应的Dao代码 targetProject:mapper接口生成的位置 targetPackage:生成mapper接口放在哪个包下 ANNOTATEDMAPPER XMLMAPPER MIXEDMAPPER --\u003e \u003cjavaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.cskaoyan.mapper\" targetProject=\"./mybatis_demo8/src/main/java\"\u003e \u003c!-- enableSubPackages:是否让schema作为包的后缀 --\u003e \u003cproperty name=\"enableSubPackages\" value=\"true\" /\u003e \u003c/javaClientGenerator\u003e\u003c!----\u003e \u003c!-- 指定数据库表 --\u003e \u003c!-- 指定所有数据库表 --\u003e \u003c!--\u003ctable tableName=\"%\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"false\" enableInsert=\"false\" enableDeleteByPrimaryKey=\"true\" enableSelectByPrimaryKey=\"true\" selectByExampleQueryId=\"false\" \u003e\u003c/table\u003e--\u003e \u003c!-- 指定数据库表，要生成哪些表，就写哪些表，要和数据库中对应，不能写错！ --\u003e \u003ctable tableName=\"j13_user_t\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"false\" enableInsert=\"true\" enableDeleteByPrimaryKey=\"true\" enableSelectByPrimaryKey=\"true\" selectByExampleQueryId=\"false\" domainObjectName=\"User\" \u003e \u003c/table\u003e \u003ctable tableName=\"j13_student_t\" domainObjectName=\"Student\"/\u003e \u003ctable tableName=\"j13_course_t\" domainObjectName=\"Course\"/\u003e \u003c!-- \u003ctable schema=\"\" tableName=\"orders\"\u003e\u003c/table\u003e \u003ctable schema=\"\" tableName=\"items\"\u003e\u003c/table\u003e \u003ctable schema=\"\" tableName=\"orderdetail\"\u003e\u003c/table\u003e --\u003e \u003c!-- 有些表的字段需要指定java类型 \u003ctable schema=\"\" tableName=\"\"\u003e \u003ccolumnOverride column=\"\" javaType=\"\" /\u003e \u003c/table\u003e --\u003e \u003c/context\u003e \u003c/generatorConfiguration\u003e ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:6:2","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"引入逆向工程的 main 方法 配置 main 方法，并运行，即可以生成配置文件中设置好的映射配置文件。 public class Generator { public void generator() throws Exception{ List\u003cString\u003e warnings = new ArrayList\u003cString\u003e(); boolean overwrite = true; //指向逆向工程配置文件 File configFile = new File(\"mybatis/generatorConfig.xml\"); System.out.println(configFile.getAbsolutePath()); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); } public static void main(String[] args) throws Exception { try { Generator generatorSqlmap = new Generator(); generatorSqlmap.generator(); } catch (Exception e) { e.printStackTrace(); } } } ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:6:3","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"其他 若映射文件和映射类在同一个包下，且名字相同时，则在映射文件中 resultType 通常用类名小写来代表返回类型。也可以在类名上使用 @Alias 注解，来规定返回使用类型别名。 @Alias(\"fruit\") public class Apple{ ... } \u003cselect id=\"selectApple\" resultType=\"fruit\"\u003e select * from j13_apple_t \u003c/select\u003e 对于简单的 sql 语句时，可以直接在映射接口上使用注解来完成 public interface AppleManager{ @Select(\"select * from j13_apple_t where id #{id}\") Apple selectAppleById(@Param(\"id\") int id); } ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:7:0","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"前言 在 Spring MVC 中，视图默认使用 jsp 文件，导致每次加载视图时，都需要对文件进行编译，从而浪费服务器的资源。为了减少对服务器资源使用，可以使用静态文件，提前将视图渲染为 html 文件。 FreeMarker 是一种是一款 模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件 freemarker 工作流程图 ","date":"2022-04-11","objectID":"/posts/freemarker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:1:0","tags":["FreeMarker"],"title":"Freemarker 学习笔记","uri":"/posts/freemarker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"使用流程 导入依赖。导入 spring-context-support 和 freemarker 依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.freemarker\u003c/groupId\u003e \u003cartifactId\u003efreemarker\u003c/artifactId\u003e \u003cversion\u003e2.3.31\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-context-support\u003c/artifactId\u003e \u003cversion\u003e5.3.17\u003c/version\u003e \u003c/dependency\u003e 在 appliction.xml 文件中配置对应的 bean对象。 \u003cbean class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer\"\u003e \u003cproperty name=\"templateLoaderPath\" value=\"/WEB-INF/freemarker\"/\u003e \u003cproperty name=\"defaultEncoding\" value=\"utf-8\"/\u003e \u003c/bean\u003e \u003cbean class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver\"\u003e \u003cproperty name=\"suffix\" value=\".ftl\"/\u003e \u003cproperty name=\"contentType\" value=\"text/html;ch araset=utf-8\"/\u003e \u003cproperty name=\"order\" value=\"1\"/\u003e \u003c/bean\u003e 在需要渲染的视图中中，配置模板对象。 public class MainTest{ @Test public void myTest() throws IOException, TemplateException { // 使用freemark版本号，创建 Configuration 对象 Configuration configuration = new Configuration(Configuration.getVersion()); File file = new File(\"src/main/resources\"); // 设置模板对象所在路径 configuration.setDirectoryForTemplateLoading(file); // 设置模板编码格式 configuration.setDefaultEncoding(\"utf-8\"); // 创建模板对象 Template template = configuration.getTemplate(\"hello.ftl\"); // 创建模板使用的数据集合，可以是 pojo 也可以是哈希表 HashMap\u003cString, Object\u003e stringObjectHashMap = new HashMap\u003c\u003e(); User user = new User(\"java\", \"pass\", 10); stringObjectHashMap.put(\"user\", user); stringObjectHashMap.put(\"code\", \"freemarker\"); // 创建一个 Writer对象，一般创建 FileWriter 对象，生成指定文件 FileWriter fileWriter = new FileWriter(new File(\"src/main/resources/hello.html\")); // 调用 process 方法，输出指定文件 template.process(stringObjectHashMap, fileWriter); // 关闭流 fileWriter.close(); } } ","date":"2022-04-11","objectID":"/posts/freemarker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:0","tags":["FreeMarker"],"title":"Freemarker 学习笔记","uri":"/posts/freemarker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"基本语法 访问哈希表中 key 所对应的 value 时，同 jsp 一样，使用 ${key} 访问。 访问 pojo 中的属性：使用 ${类名.属性} 访问 访问集合中的数据： 使用 #list 标签遍历访问 User user1 = new User(\"admin1\", \"123\"); User user2 = new User(\"admin2\", \"123\"); User user3 = new User(\"admin3\", \"123\"); List\u003cUser\u003e list = new ArrayList\u003c\u003e(); list.add(user1); list.add(user2); list.add(user3); dataMap.put(\"userlist\", list); \u003c#list userlist as users\u003e ${users.username} ${users.password} \u003c/#list\u003e 判断语法和比较语法 \u003c#if hello==\"java\"\u003e ${hello} \u003c#elseif hello==\"python\"\u003e ${hello} \u003c/#if\u003e 日期类处理 ${date?string(\"yyyy/MM/dd HH:mm:ss\")} null值处理：使用 ?? 判断是否为空，使用 ！ 表示为空使用默认值，后面什么都不跟的化，则使用空字符串。（若为空使用的则会抛出异常，且会输出到默认的指定文件当中） \u003c#if hello??\u003e ${hello! \"默认值\"} 引入其他模板文件。使用 include 引入其他模板文件。 \u003c#inclde \"foo.ftl\"\u003e ","date":"2022-04-11","objectID":"/posts/freemarker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:1","tags":["FreeMarker"],"title":"Freemarker 学习笔记","uri":"/posts/freemarker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"前言 MVC 三个单词分别为 Model 、 View 和 Controller ，MVC 模式是一种常用的web开发模式，比如python的 django 也是采用该模式。Spring 框架也提供了该模式，负责表示层。 spring mvc流程图 ","date":"2022-04-09","objectID":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:1:0","tags":["MVC"],"title":"Spring MVC 学习笔记","uri":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"使用流程 Spring MVC 提供了四大组件，前端控制器（DispatcherServlet）、处理器映射器（HandlerMapping）、处理器适配器（HandlerAdapter）以及视图解析器（ViewResolver）。 用户请求发送到前端控制器 DispatcherServlet。 前端控制器 DispatcherServlet 接收到请求后，DispatcherServlet 会使用 HandlerMapping 来处理，HandlerMapping 会查找到具体进行处理请求的 Handler 对象。 HandlerMapping 找到对应的 Handler 之后，并不是返回一个 Handler 原始对象，而是一个 Handler 执行链（HandlerExecutionChain），在这个执行链中包括了拦截器和处理请求的 Handler。HandlerMapping 返回一个执行链给 DispatcherServlet。 DispatcherServlet 接收到执行链之后，会调用 Handler 适配器去执行 Handler。 Handler 适配器执行完成 Handler（也就是 Controller）之后会得到一个 ModelAndView，并返回给 DispatcherServlet。 DispatcherServlet 接收到 HandlerAdapter 返回的 ModelAndView 之后，会根据其中的视图名调用 ViewResolver。 ViewResolver 根据逻辑视图名解析成一个真正的 View 视图，并返回给 DispatcherServlet。 DispatcherServlet 接收到视图之后，会根据上面的 ModelAndView 中的 model 来进行视图中数据的填充，也就是所谓的视图渲染。 渲染完成之后，DispatcherServlet 就可以将结果返回给用户了。 ","date":"2022-04-09","objectID":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:0","tags":["MVC"],"title":"Spring MVC 学习笔记","uri":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"使用流程 ","date":"2022-04-09","objectID":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:0","tags":["MVC"],"title":"Spring MVC 学习笔记","uri":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"导包 导入 spring-webmvc 依赖，该依赖依赖于 spring-context ，所以可以不用手动导入 spring-context。 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.3.17\u003c/version\u003e \u003c/dependency\u003e ","date":"2022-04-09","objectID":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:1","tags":["MVC"],"title":"Spring MVC 学习笔记","uri":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"配置前端控制器 \u003cservlet\u003e \u003cservlet-name\u003edispatcher\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:application.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003edispatcher\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e ","date":"2022-04-09","objectID":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:2","tags":["MVC"],"title":"Spring MVC 学习笔记","uri":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"配置 HandlerMapping 和 HandlerAdapter 可以通过配置文件配置也可以通过注解配置。 通过配置文件 在配置文件中配置 springmvc 的所需要的 bean 。 \u003cbean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"\u003e\u003c/bean\u003e \u003cbean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"\u003e\u003c/bean\u003e 通过注解方式（常用） 在配置文件进行驱动注册（需要使用 spring-context 的注解扫描） \u003ccontext:component-scan base-package=\"com.cskaoyan\"/\u003e \u003cmvc:annotation-driven/\u003e ","date":"2022-04-09","objectID":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:3","tags":["MVC"],"title":"Spring MVC 学习笔记","uri":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"配置Controller和Url 可以通过实现接口实现，也可以通过注解实现. 实现接口实现。实现 Controller 接口，并重写 handlerRequest 方法。并在配置文件配置 url 映射。 public class HelloController implements Controller{ @Overriders public ModelView handleRequest(HttpServletRequest request, HttpServeletResponce responce){ } } \u003cbean name=\"hello\" class=\"com.cskaoyan.controller.HelloController\"\u003e\u003c/bean\u003e 通过注解实现。（常用） @Controller public class HelloController{ @RequestMapping(\"/hello\") public ModelAndView login(){ } } 可以通过 application.xml 配置文件设置 url 路径的前缀和后缀，减少路径名书写。 \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"\u003e \u003cproperty name=\"prefix\" value=\"/WEB-INF/view/\"/\u003e \u003cproperty name=\"suffix\" value=\".jsp\"/\u003e \u003c/bean\u003e ","date":"2022-04-09","objectID":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:4","tags":["MVC"],"title":"Spring MVC 学习笔记","uri":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"拦截器配置（可选） SpringMVC 的处理器拦截器类似于Servlet 开发中的过滤器Filter，用于对处理器进行预处理和后处理。 实现 HandlerIntercepter 接口，并重写 preHandler 、 postHandler 和 afterCompletion 方法。 在 application.xml 文件中配置拦截器。其中 mapping 表示配置的内容对应拦截的 url 范围。 \u003cmvc:interceptors\u003e \u003cmvc:interceptor\u003e \u003cmvc:mapping path=\"/user/*\"/\u003e \u003cbean class=\"com.cskaoyan.hander.Myhandeler\"/\u003e \u003c/mvc:interceptor\u003e \u003c/mvc:interceptors\u003e preHandler ：预处理回调方法，实现处理器的预处理（如登录检查），第三个参数为响应的处理器。返回值为 boolean ，true表示继续流程（如调用下一个拦截器或处理器），false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过response来产生响应 postHandler ： 后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。 afterCompletion ： 整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中preHandle返回true的拦截器的afterCompletion 可以配置多个拦截器，拦截范围相同时，则按注册顺序执行。只要 preHandler 返回为 true 时，afterCompletion 一定会执行到。 ","date":"2022-04-09","objectID":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:5","tags":["MVC"],"title":"Spring MVC 学习笔记","uri":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"其他设置 ","date":"2022-04-09","objectID":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:0","tags":["MVC"],"title":"Spring MVC 学习笔记","uri":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"RequestMapping功能 url 路径映射 窄化请求。可以在 Controller 类上同时配置 RequestMapping ，类里面的所有方法都在父路径里面。 请求方法限定。使用 Request.Method 来限制请求方法。同时也可以通过其他参数配置限定其他参数。 ","date":"2022-04-09","objectID":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:1","tags":["MVC"],"title":"Spring MVC 学习笔记","uri":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"Controller 方法的返回值 返回值类型可以为如下三种： ModelAndView : 返回模型视图对象，可以使用该对象来设置请求的视图。 Void ： 请求参数中必须使用 (HttpServletRequest request, HttpServeletResponce responce) ，使用 request 来设置请求视图。 String ： 返回视图对应的字符串。会自动转发到对应的视图文件上，也可也手动使用 forward 或者 redirect 转发到对应的视图的解析器上，也可以转发到其他 Controller 的 url 路径上。 return \"forward:hello.jsp\"; return \"redirect:hello.jsp\"; return \"redirct:/user/login\"; ","date":"2022-04-09","objectID":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:2","tags":["MVC"],"title":"Spring MVC 学习笔记","uri":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"请求参数封装 使用 request 对象提取 在请求参数中，增加 (HttpServletRequest request, HttpServeletResponce responce) 参数，利用 request 对象根据 key 获取对应的 value 。 String str = request.getParameter(\"id\"); 基本数据类型获取 需要与请求参数 key 一一对应，即形参必须同名，通过相同的参数名提取。 将请求参数封装到 JavaBean 对象当中（常用） 需要在视图页面使用 对象.属性 来设置传递过来的 value ，如果存在多个对象时，可以封装一个含有多个对象的对象。 \u003cinput type=\"text\" name=\"user.id\"\u003e 如果在提交的过程中，使用了中文数据，则会导致，需要在配置文件 web.xml 中配置传输数据的编码格式。 \u003cfilter\u003e \u003cfilter-name\u003eebcoding\u003c/filter-name\u003e \u003cfilter-class\u003eorg.springframework.web.filter.CharacterEncodingFilter\u003c/filter-class\u003e \u003cinit-param\u003e \u003cparam-name\u003eencoding\u003c/param-name\u003e \u003cparam-value\u003eutf-8\u003c/param-value\u003e \u003c/init-param\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eebcoding\u003c/filter-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e ","date":"2022-04-09","objectID":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:3","tags":["MVC"],"title":"Spring MVC 学习笔记","uri":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"请求参数类型转换 当请求的参数需要进行转换才能使用时，比如时间格式，需要对传入的数据进行格式转换。 首先配置自定义的类型转换器。通过实现 Converter 接口，重写 convert 方法来实现类型转换器。 public class MyDateCOnverter implements Converter\u003cString, Date\u003e { @Override public Date convert(String value) { SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yy-MM-dd\"); try { Date parse = simpleDateFormat.parse(value); return parse; } catch (ParseException e) { e.printStackTrace(); } return null; } } 在 application.xml 文件中，配置类型转换器。 \u003cmvc:annotation-driven conversion-service=\"myConvertorService\"/\u003e \u003cbean id=\"myConvertorService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"\u003e \u003cproperty name=\"converters\"\u003e \u003cset\u003e \u003cbean class=\"com.cskaoyan.converter.MyDateCOnverter\"/\u003e \u003cbean class=\"com.cskaoyan.converter.UserConverter\"/\u003e \u003c/set\u003e \u003c/property\u003e \u003c/bean\u003e ","date":"2022-04-09","objectID":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:4","tags":["MVC"],"title":"Spring MVC 学习笔记","uri":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"请求参数集合封装 数组封装 使用 checkbox，传递多个值 \u003ch2\u003e封装数组获取参数\u003c/h2\u003e \u003cform action=\"submitArray\" method=\"post\"\u003e id1:\u003cinput type=\"checkbox\" name=\"ids\" value=\"1\"\u003e\u003cbr\u003e id2:\u003cinput type=\"checkbox\" name=\"ids\" value=\"2\"\u003e\u003cbr\u003e id3:\u003cinput type=\"checkbox\" name=\"ids\" value=\"3\"\u003e\u003cbr\u003e id4:\u003cinput type=\"checkbox\" name=\"ids\" value=\"4\"\u003e\u003cbr\u003e id5:\u003cinput type=\"checkbox\" name=\"ids\" value=\"5\"\u003e\u003cbr\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e 集合封装 使用索引设置 ArrayList 各个元素属性。同时构建一个 JavaBean 对象来接受请求参数，该对象含有对应的 List\u003cT\u003e 成员属性。 public class QueryVo { User user; String content; int count; List\u003cUser\u003e users; @Override public String toString() { return \"QueryVo{\" + \"user=\" + user + \", content='\" + content + '\\'' + \", count=\" + count + \", users=\" + users + '}'; } public List\u003cUser\u003e getUsers() { return users; } public void setUsers(List\u003cUser\u003e users) { this.users = users; } public QueryVo(User user, String content, int count) { this.user = user; this.content = content; this.count = count; } public User getUser() { return user; } public void setUser(User user) { this.user = user; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public int getCount() { return count; } public void setCount(int count) { this.count = count; } } \u003ch2\u003e封装集合获取参数\u003c/h2\u003e \u003cform action=\"submitCollection\" method=\"post\"\u003e id:\u003cinput type=\"text\" name=\"user.id\"\u003e\u003cbr\u003e username:\u003cinput type=\"text\" name=\"user.username\"\u003e\u003cbr\u003e password:\u003cinput type=\"password\" name=\"user.password\"\u003e\u003cbr\u003e phoneNumber:\u003cinput type=\"text\" name=\"user.phoneNumber\"\u003e\u003cbr\u003e content:\u003cinput type=\"text\" name=\"content\"\u003e\u003cbr\u003e count:\u003cinput type=\"text\" name=\"count\"\u003e\u003cbr\u003e user1:id:\u003cinput type=\"text\" name=\"users[0].id\"\u003e\u003cbr\u003e user1:username:\u003cinput type=\"text\" name=\"users[0].username\"\u003e\u003cbr\u003e user1:password:\u003cinput type=\"password\" name=\"users[0].password\"\u003e\u003cbr\u003e user1:phoneNumber:\u003cinput type=\"text\" name=\"users[0].phoneNumber\"\u003e\u003cbr\u003e user2:id:\u003cinput type=\"text\" name=\"users[1].id\"\u003e\u003cbr\u003e user2:username:\u003cinput type=\"text\" name=\"users[1].username\"\u003e\u003cbr\u003e user2:password:\u003cinput type=\"password\" name=\"users[1].password\"\u003e\u003cbr\u003e user2:phoneNumber:\u003cinput type=\"text\" name=\"users[1].phoneNumber\"\u003e\u003cbr\u003e user3:id:\u003cinput type=\"text\" name=\"users[2].id\"\u003e\u003cbr\u003e user3:username:\u003cinput type=\"text\" name=\"users[2].username\"\u003e\u003cbr\u003e user3:password:\u003cinput type=\"password\" name=\"users[2].password\"\u003e\u003cbr\u003e user3:phoneNumber:\u003cinput type=\"text\" name=\"users[2].phoneNumber\"\u003e\u003cbr\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e ","date":"2022-04-09","objectID":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:5","tags":["MVC"],"title":"Spring MVC 学习笔记","uri":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"文件上传 图片上传需要外部依赖。 导包。导入 commons-io 和 commons-fileupload 依赖。 \u003cdependency\u003e \u003cgroupId\u003ecommons-io\u003c/groupId\u003e \u003cartifactId\u003ecommons-io\u003c/artifactId\u003e \u003cversion\u003e2.6\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-fileupload\u003c/groupId\u003e \u003cartifactId\u003ecommons-fileupload\u003c/artifactId\u003e \u003cversion\u003e1.4\u003c/version\u003e \u003c/dependency\u003e 配置解析器。在 application.xml 配置解析器。（id 必须固定，否则异常） \u003cbean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"\u003e \u003c/bean\u003e 接受参数中，增加 MultipartFile myfile 参数，使用 transferTo 方法传输的文件写入本地。 String filePath = \"path/to/file\"; File file = new File(filePath); myfile.transferTo(file); ","date":"2022-04-09","objectID":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:6","tags":["MVC"],"title":"Spring MVC 学习笔记","uri":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"参考资料 [深入源码分析SpringMVC执行过程] ","date":"2022-04-09","objectID":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:5:0","tags":["MVC"],"title":"Spring MVC 学习笔记","uri":"/posts/spring-mvc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"前言 在 Spring 框架中，需要使用事务管理对数据库进行操作，以实现事务的 ACID 特性。 ","date":"2022-04-05","objectID":"/posts/spring-transaction%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:1:0","tags":["Transaction"],"title":"Spring Transaction学习笔记","uri":"/posts/spring-transaction%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"事务的基本实现 Spring 框架提供了三个对象来管理事务。 PlatformTransactionManager ：平台事务管理器，spring要管理事务，必须使用事务管理器。事务配置的过程中，也必须配置事务管理器，常见的事务管理器有： DataSourceTransactionManager ，在jdbc开发中采用 JdbcTemplate 。(常用) HibernateTransactionManage ，hibernate开发时事务管理器，整合hibernate。 常用 api 有三个： TransactionStatus getTransaction(TransactionDefinition definition) ： 事务管理器 通过“事务详情”，获得“事务状态”，从而管理事务。 获取事务状态后，Spring根据传播行为来决定如何开启事务 void commit(TransactionStatus status) ： 根据状态提交 void rollback(TransactionStatus status) ： 根据状态回滚 TransactionDefinition ：这个接口的作用就是定义事务的名称、隔离级别、传播行为、超时时间长短、只读属性等。 TransactionStatus ： 这个接口的作用就是获取事务的状态（回滚点、是否完成、是否新事物、是否回滚）属性 ","date":"2022-04-05","objectID":"/posts/spring-transaction%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:0","tags":["Transaction"],"title":"Spring Transaction学习笔记","uri":"/posts/spring-transaction%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"使用流程 首先需要导入 spring-tx 包。 实现方式有四种： 使用事务模板完成 向容器中注册 TransactionTemplate 对象，然后在Service 类中引入事务管理器 \u003cbean id=\"myUserServiceImpl\" class=\"com.cskaoyan.service.UserServiceImpl\"\u003e \u003cproperty name=\"dao\" ref=\"accountdaoImpl\"\u003e\u003c/property\u003e \u003cproperty name=\"transactionTemplate\" ref=\"myTransactionTemplate\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003cbean id=\"myTransactionTemplate\" class=\"org.springframework.transaction.support.TransactionTemplate\"\u003e \u003cproperty name=\"transactionmanager\" ref=\"myTransactionmanager\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003cbean id=\"myTransactionmanager\" class=\"org.springframework.transaction.support.TransactionManager\"\u003e \u003cproperty name=\"datasource\" ref=\"mydatasource\"\u003e\u003c/property\u003e \u003c/bean\u003e @Autowired TransactionTemplate transactionTemplate; public void setTransactionTemplate(TransactionTemplate transactionTemplate){ this.transactionTemplate = transactionTemplate; } 在需要执行的事务业务中，使用 transactionTemplate 对象执行 execute(new TransactionCallbackWithoutResult(){})方法。在匿名类中写事务代码。 transactionTemplate.execute(new TransactionCallbackWithoutResult(){ // 执行所需要的事务 }) 使用配置文件配置事务 \u003cbean id=\"myServiceProxyFactoryBean\" class=\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\"\u003e \u003cproperty name=\"proxyInterface\" value=\"com.cskaoyan.service.UserService\"\u003e\u003c/property\u003e \u003cproperty name=\"target\" ref=\"myServiceImpl\"\u003e\u003c/property\u003e \u003cproperty name=\"transactionManager\" ref=\"myTransactionManager\"\u003e\u003c/property\u003e \u003cpreoerty name=\"transactionAttribues\"\u003e \u003cprops\u003e \u003cprop ket=\"transferMoney\"\u003ePROPAGATION_REQUIRED,ISOLATION_REPEATABLE_READ\u003c/prop\u003e \u003c/props\u003e \u003c/preoerty\u003e \u003c/bean\u003e \u003cbean id=\"myTransactionManager\" class=\"org.springframework.transaction.support.TransactionManager\"\u003e \u003cproperty name=\"datasource\" ref=\"mydatasource\"\u003e\u003c/property\u003e \u003c/bean\u003e 使用事务模板实现，通过使用 spring-tx 配置，首先使用 spring-tx 的schema \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!-- bean definitions here --\u003e \u003c/beans\u003e 接着配置事务，与 aop:advisor 配合一起使用。 \u003caop:config\u003e \u003caop:point-cut id=\"mypointcut\" expression=\"execution(* com..impl...*(..))\"/\u003e \u003caop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"mypointcut\"/\u003e \u003c/aop:config\u003e \u003ctx:advice id=\"txAdvice\" transaction-manager=\"myTransactionManager\"\u003e \u003ctx:attribues\u003e \u003ctx:method name=\"transferMoney\" propagation=\"REQUIRED\" isolation=\"DEFAULT\"/\u003e \u003c/tx:attribues\u003e \u003c/tx:advice\u003e 通过spring tx 注解实现，在需要执行事务而方法中使用注解。（常用方式） 首先配置注解驱动 \u003ctx:annotation-direver transaction-manager=\"txManager\"/\u003e 接着在所需要执行事务的方法中配置注解 @Transactional(isolation=Isolation.Default, propagation=Propagation.REQUIRED) ","date":"2022-04-05","objectID":"/posts/spring-transaction%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:1","tags":["Transaction"],"title":"Spring Transaction学习笔记","uri":"/posts/spring-transaction%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"前言 Spring 提供了 JDBCTemplate 来操作jdbc，而让用户只需要关注sql语句即可。 ","date":"2022-04-05","objectID":"/posts/spring-jdbc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:1:0","tags":["JDBC"],"title":"Spring JDBC 学习笔记","uri":"/posts/spring-jdbc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"使用流程 ","date":"2022-04-05","objectID":"/posts/spring-jdbc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:0","tags":["JDBC"],"title":"Spring JDBC 学习笔记","uri":"/posts/spring-jdbc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"使用JDBCTemplate 导包。jdbc 所需要而依赖不在 spring 四个核心当中，需要额外导包。需要导入一个数据库驱动、一个连接池取代、 spring-jdbc 。数据库以 mysql 为例 \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.12\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.mchange\u003c/groupId\u003e \u003cartifactId\u003ec3p0\u003c/artifactId\u003e \u003cversion\u003e0.9.5.5\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.3.17\u003c/version\u003e \u003c/dependency\u003e 创建连接池 ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(); comboPooledDataSource.setDriverClass(\"com.mysql.cj.jdbc.Driver\"); comboPooledDataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/j13_jdbc_template?serverTimezone=GMT\"); comboPooledDataSource.setUser(\"root\"); comboPooledDataSource.setPassword(\"admin\"); 创建 jdbc 模板 JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(comboPooledDataSource); 模板使用 String s = jdbcTemplate.queryForObject(sql, String.class, 0); ","date":"2022-04-05","objectID":"/posts/spring-jdbc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:1","tags":["JDBC"],"title":"Spring JDBC 学习笔记","uri":"/posts/spring-jdbc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"使用JDBCDaoSupport 方法与上述不同 首先每个DAO都需要声明template 而且要写set方法 在配置文件中配置JDBC连接池 \u003cbean id=\"myDatasource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"\u003e \u003cproperty name=\"driverClass\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/j13_jdbc_template?serverTimezone=GMT\"/\u003e \u003cproperty name=\"user\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"admin\"/\u003e \u003c/bean\u003e \u003cbean\u003e \u003cproperty name=\"jdbcTemplate\" ref=\"myJDBCTemplate\"\u003e\u003c/property\u003e \u003cproperty name=\"datasource\" ref=\"myDatasource\"\u003e\u003c/property\u003e \u003c/bean\u003e JDBCDaoSupport 中含有 JdbcTemplate 对象，直接使用即可 ","date":"2022-04-05","objectID":"/posts/spring-jdbc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:2","tags":["JDBC"],"title":"Spring JDBC 学习笔记","uri":"/posts/spring-jdbc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"前言 AOP 全称为 Aspect Oriented Programming，即面向切片编程。与 OOP (Object Oriented Programming) 面向对象编程不同的是，AOP将系统看作为多个对象的交互，通过切面，对系统的不同关注点，切分为多个平面，利用 AOP ，可以更好的对过往代码进行复用。 ","date":"2022-04-05","objectID":"/posts/spring-aop-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:1:0","tags":["AOP"],"title":"Spring AOP 学习笔记","uri":"/posts/spring-aop-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"AOP基础 ","date":"2022-04-05","objectID":"/posts/spring-aop-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:0","tags":["AOP"],"title":"Spring AOP 学习笔记","uri":"/posts/spring-aop-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"术语 AOP 的基本用语： Target：目标类，需要代理的类 JointPoint：连接点，被代理的对象中需要增强的点，比如方法 PointCut：切入点，已经被增强的连接点 Advice：通知，代理对象执行到 连接点所需要执行的操作 Weaver：植入，把通知应用到代理对象当中的过程 Proxy ：代理类，动态代理 ","date":"2022-04-05","objectID":"/posts/spring-aop-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:1","tags":["AOP"],"title":"Spring AOP 学习笔记","uri":"/posts/spring-aop-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"实现方式 AOP 的底层采用代理机制方式实现。AOP 功能实现方式主要有三种 手动实现。使用 jdk 或者 cglib 动态代理实现 使用 Spring AOP api 实现。该方法需要手动实现 AOP 的接口，并对指定方法进行增加 使用 aspectj 实现。常用方式，实现过程如下 导入 aspectjweaver 包，在 application.xml 中引入 aop 的头文件（后续可以使用配置类完成） \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!-- bean definitions here --\u003e \u003c/beans\u003e 配置切入面、切入点和通知 \u003caop:config\u003e \u003c!-- --\u003e \u003caop:aspect ref=\"myAspect（切片的id）\"\u003e \u003caop:pointcut id=\"mypointcut\" expression=\"execution(public boolean com.cskaoyan.dao.impl.UserServiceImpl.register(String,String))\"/\u003e \u003caop:pointcut id=\"mypointcut2\" expression=\"execution(* com..impl..*(..))\"/\u003e \u003caop:before method=\"before13\" pointcut-ref=\"mypointcut2\"/\u003e \u003caop:around method=\"myAround\" pointcut-ref=\"mypointcut2\"/\u003e \u003caop:after method=\"myAfter\" pointcut-ref=\"mypointcut2\"/\u003e \u003caop:after-throwing method=\"myAfterThrowing\" pointcut-ref=\"mypointcut2\" throwing=\"myThrowable\"/\u003e \u003caop:after-returning method=\"myAfterReturning\" pointcut-ref=\"mypointcut2\" returning=\"myReturnResult\"/\u003e \u003c/aop:aspect\u003e \u003c!-- \u003caop:aspect ref=\"myAspect2\"\u003e \u003caop:before method=\"before13\" pointcut-ref=\"mypointcut\"/\u003e \u003c/aop:aspect\u003e --\u003e \u003c/aop:config\u003e ","date":"2022-04-05","objectID":"/posts/spring-aop-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:2","tags":["AOP"],"title":"Spring AOP 学习笔记","uri":"/posts/spring-aop-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"AspectJ 基于 AOP 框架，Spring2.0 之后支持了基于 AspectJ 的切入点表达式，可以在不改动原代码的的前提下，自定义开发，植入代码。 AspectJ 流程图 语法：execution（修饰符 返回值 包 类 方法名(参数类型) throws 异常 ，其中修饰符一般省略，修饰符可以使用 * 表示任意; 返回值不可以省略，但是可以使用 * 表示任意，若是非 java.lang 下的类型，需要写全类名; 方法不可以省略，可以使用 * 表示任意; 参数可以使用 (..) 表示参数任意; throws 异常可以省略。 通知类型： Before ： 在切入点之前执行。 参数类型的校验。 前置通知 AtterReturning ： 周在切入点之后执行。后置通知，可以对结果进行检查，增加log Around ：环绕通知 在切入点之前和之后都会执行。增加事务等等。 AfterThrowing ： 抛出异常的时候执行通知。正常情况下走不到。只有发生异常的情况下才会去通知，比如记录一些日志。 After ： 在finally语句里。不管切入点是否有异常发生都会执行。 实现方式： 在配置文件 xml 中书写 \u003caop:before method=\"MyBefore\" pointcut-ref=\"myPointCut\"/\u003e \u003caop:after-returning method=\"MyAfterReturning\" pointcut-ref=\"myPointCut\"/\u003e \u003caop:around method=\"MyAround\" pointcut-ref=\"myPointCut\"/\u003e \u003caop:afterthrowing method=\"MyAfterThrowing\" pointcut-ref=\"myPointCut\"/\u003e \u003caop:after method=\"MyAfter\" pointcut-ref=\"myPointCut\"/\u003e 使用注解实现，需要现在配置文件中引入自动代理 \u003caop:aspectj-autoproxy/\u003e @Before(\"execution(public java.utils.list.com..*.addUser(..))\") @AfterReturning(value = \"execution(public java.utils.list.com..*.addUser(..))\"\", returning = \"res) @Around(\"execution(public java.utils.list.com..*.addUser(..))\") @AfterThrowing(value = \"execution(public java.utils.list.com..*.addUser(..))\", throwing = \"exception\") @After(\"execution(public java.utils.list.com..*.addUser(..))\") ","date":"2022-04-05","objectID":"/posts/spring-aop-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:0","tags":["AOP"],"title":"Spring AOP 学习笔记","uri":"/posts/spring-aop-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"前言 IOC 全称为 Inverse of control ，即控制反转。通过向 Spring 的IOC容器中注册，从而使得获得对象的过程进行反转，即不再手动生成所需要的对象，而是IOC容器向应用程序注入某个对象。 ","date":"2022-04-05","objectID":"/posts/spring-ioc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:1:0","tags":["IOC"],"title":"Spring IOC 学习笔记","uri":"/posts/spring-ioc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"IOC基础 ","date":"2022-04-05","objectID":"/posts/spring-ioc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:0","tags":["IOC"],"title":"Spring IOC 学习笔记","uri":"/posts/spring-ioc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"对象注册 首先需要导入 spring-contex 包，该包包含四个核心和一个依赖，剩余三个核心分别为 spring-aop 、spring-bean 和 spring-core，一个依赖为 spring-expression。 同时在配置中引入头文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003c!-- bean definitions here --\u003e \u003c/beans\u003e 接着在配置文件中进行对象注册 \u003cbean name=\"userService\" class=\"com.cskaoyan.service.impl.UserServiceImpl\"/\u003e 此时，IOC容器中就包含了所该类的一个的对象。 ","date":"2022-04-05","objectID":"/posts/spring-ioc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:1","tags":["IOC"],"title":"Spring IOC 学习笔记","uri":"/posts/spring-ioc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"对象设置 在配置文件中设置对象。利用 property 标签设置，name 表示为类中的 set 方法的后缀。如果设置的为对象，则使用 ref= 来设置对象，若是值，则使用 value= 来设置。 \u003cbean name=\"userService\" class=\"com.cskaoyan.service.impl.UserServiceImpl\"\u003e \u003cproperty name=\"userDao\" ref=\"UserDao\"/\u003e \u003cbean\u003e 默认是通过无参构造方法创建对象（也是主要使用方法），如没有无参构造方法时，需要使用有参构造方法，配置 \u003cconstructor-arg\u003e 标签来通过调用有参构造方法来创建对象。 \u003cbean name=\"userService\" class=\"com.cskaoyan.service.impl.UserServiceImpl\"\u003e \u003cconstructor-arg name=\"id\" value=\"001\"/\u003e \u003cconstructor-arg name=\"name\" value=\"java\"/\u003e \u003cbean\u003e 也可以通过实例工厂或静态工厂来获得对象（了解即可） 在IOC容器注册的对象是单例模式，可以通过不同的ID来创建同一个类的不同的对象，也可以更改Bean的作用域（singleton更改为prototype），使得每次获得的对象都是一个新的实例。 ","date":"2022-04-05","objectID":"/posts/spring-ioc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:2","tags":["IOC"],"title":"Spring IOC 学习笔记","uri":"/posts/spring-ioc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"注解装配对象 通过配置文件，自动扫描带有注解的类，将类进行注册。配置文件设置如下 \u003ccontext:component-scan base-package=\"com.cskaoyan\"\u003e\u003c/context:component-scan\u003e @Component取代，@Component(“id”) 取代 在 web 开发中，使用衍生注解取代 @Repository ：dao层 @Service：service层 @Controller：web层 属性注入 普通值：@Value(\"\") 引用值：@Autowired、 @Autowired @Qualifier(“名称”) 或 @Resource(name = “名称”) ","date":"2022-04-05","objectID":"/posts/spring-ioc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:3","tags":["IOC"],"title":"Spring IOC 学习笔记","uri":"/posts/spring-ioc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Spring"],"content":"Test配置 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(\"classpath:application.xml\") ","date":"2022-04-05","objectID":"/posts/spring-ioc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:4","tags":["IOC"],"title":"Spring IOC 学习笔记","uri":"/posts/spring-ioc-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["算法"],"content":"前言 在图论中，找到单点 s 到单点 t 的最大流，称为最大流问题，其中 s-t 的最大流等于 s-t 的最小割，使用 Ford–Fulkerson 算法可以确认最大流。 维基百科 最大流 ","date":"2022-04-05","objectID":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/:1:0","tags":["最大流最小割"],"title":"图论 最大流和最小割","uri":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/"},{"categories":["算法"],"content":"最大流 求由 s 发出，t 每秒接受的最大流量，称为最大流问题。首先可以利用贪心算法，确认 s-\u003et 的一条路径，但该路径不一定是最大流。Ford–Fulkerson 算法提出了一个残余网络，也叫增广路，将之前的s-\u003et路径的流进行反转，同时原网络减去 s-\u003et 的流量，二者合并构成残余网络。同时在根据残余网络找到 s-\u003et 的路径。根据上述规则，不断的重复迭代，直到 s-\u003et 没有到达路径流，则可以得到最大流（最大流量在每次迭代的过程中都是累加的，因为只需要计算 s 到 t 的流量，终点 t 每次迭代后流入流量都是在累加）。 将流量路径反转的目的是在于可以重新规划边的流量流向，若后续还存在 s-\u003et 路径，且需要更改反转的路径大小，则表面需要调整之前的流量大小，以此提高 s 到 t 的流量大小。 ","date":"2022-04-05","objectID":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/:2:0","tags":["最大流最小割"],"title":"图论 最大流和最小割","uri":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/"},{"categories":["算法"],"content":"最小割 图的割，指的是对于某个顶点集合 $S \\subseteq V$ ，从 S 出发指向外部那些边的集合，记为割(S, V\\S)。这些边的流量容量之和称为割的容量。通俗来说，就是将一个连通图，划分为两个不连通的子图，而割代表的是再划分时，所需要去掉的边。为了让 s 和 t 分别处于不同的子图，所需要的最小边的容量，记为最小割。当 s 和 t 处于不同的子图时，s 和 t 即不存在相连通的路径。 ","date":"2022-04-05","objectID":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/:3:0","tags":["最大流最小割"],"title":"图论 最大流和最小割","uri":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/"},{"categories":["算法"],"content":"基本公式 记$f$为s-t的流量，则$f = (s出边的总流量)$ ，对于$v \\in S${s} 时，又有 $(v的出边的总流量) = (v的入边的总流量)$，所以 $f = (S的出边的总流量) - (S的入边的总流量)$ ，所以 $f \\le (割的流量)$。 对于残余网络来说，$f^‘$ 对应的残余网路中s 到可达 v 的的集合为 S ，因为$f^‘$ 不存在 s-\u003et 的路径，所以(S, V\\S)就是一个s-t割。根据 $f^‘ = (S的出边的总流量) - (S的入边的总流量) = (割的流量)$ ，所以$f^‘$ 为最大流。 ","date":"2022-04-05","objectID":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/:4:0","tags":["最大流最小割"],"title":"图论 最大流和最小割","uri":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/"},{"categories":["算法"],"content":"代码实现 可以利用DFS或者BFS进行路径搜索，并不断进行迭代，直到两点之间没有路径，即可以达到最大流量。 // Ford-Fulkerson algorith in Java import java.util.LinkedList; class FordFulkerson { static final int V = 6; // Using BFS as a searching algorithm boolean bfs(int Graph[][], int s, int t, int p[]) { boolean visited[] = new boolean[V]; for (int i = 0; i \u003c V; ++i) visited[i] = false; LinkedList\u003cInteger\u003e queue = new LinkedList\u003cInteger\u003e(); queue.add(s); visited[s] = true; p[s] = -1; while (queue.size() != 0) { int u = queue.poll(); for (int v = 0; v \u003c V; v++) { if (visited[v] == false \u0026\u0026 Graph[u][v] \u003e 0) { queue.add(v); p[v] = u; visited[v] = true; } } } return (visited[t] == true); } // Applying fordfulkerson algorithm int fordFulkerson(int graph[][], int s, int t) { int u, v; int Graph[][] = new int[V][V]; for (u = 0; u \u003c V; u++) for (v = 0; v \u003c V; v++) Graph[u][v] = graph[u][v]; int p[] = new int[V]; int max_flow = 0; # Updating the residual calues of edges while (bfs(Graph, s, t, p)) { int path_flow = Integer.MAX_VALUE; for (v = t; v != s; v = p[v]) { u = p[v]; path_flow = Math.min(path_flow, Graph[u][v]); } for (v = t; v != s; v = p[v]) { u = p[v]; Graph[u][v] -= path_flow; Graph[v][u] += path_flow; } // Adding the path flows max_flow += path_flow; } return max_flow; } public static void main(String[] args) throws java.lang.Exception { int graph[][] = new int[][] { { 0, 8, 0, 0, 3, 0 }, { 0, 0, 9, 0, 0, 0 }, { 0, 0, 0, 0, 7, 2 }, { 0, 0, 0, 0, 0, 5 }, { 0, 0, 7, 4, 0, 0 }, { 0, 0, 0, 0, 0, 0 } }; FordFulkerson m = new FordFulkerson(); System.out.println(\"Max Flow: \" + m.fordFulkerson(graph, 0, 5)); } } ","date":"2022-04-05","objectID":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/:5:0","tags":["最大流最小割"],"title":"图论 最大流和最小割","uri":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/"},{"categories":["算法"],"content":"参考资料 图论：最大流最小割详解 Ford-Fulkerson Algorithm ","date":"2022-04-05","objectID":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/:6:0","tags":["最大流最小割"],"title":"图论 最大流和最小割","uri":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/"},{"categories":["算法"],"content":"前言 线段树擅长处理区间，形状如下图 。线段树是一颗完美二叉树，其叶子存储元素值值，非叶子节点存储对应区间的值，根节点维护整个区间，对区间的操作可以在 O(log n) 时间复杂度完成。 Transformer 模型框架) ","date":"2022-04-04","objectID":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/:1:0","tags":["线段树"],"title":"线段树","uri":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/"},{"categories":["算法"],"content":"算法思想 如果要对连续区间重复多次操作时，比如求区间的最值/和等，利用线段树是可以从 O(m * n) 降低至 O(m * logn) ，m 为操作次数， n 为总区间长度。算法基本过程： 构造线段树。利用所给的区间元素，构造线段树。由于父节点需要存储两个子节点运算后的值，可以采用 自底向上 构造线段树，比如使用递归方法。 更改线段树。更改某元素的值时，也需要更改父节点以上的值，和构造阶段一样，采用 自底向上 的方法依次更改。 求区间值。求区间则使用 自顶向下 方法实现取值，根据父节点的区间范围与求取的范围，不断的递归向下取值，同时根据所求范围将区间进行拆分为若干个极大区间，直到左右区间达到所给而范围。 ","date":"2022-04-04","objectID":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/:2:0","tags":["线段树"],"title":"线段树","uri":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/"},{"categories":["算法"],"content":"再优化 当需要改变区间内某些元素值时，可以在所对应区间内（包括父节点的区间）进行标记，从而记录更改，而当需要查询到该区间时，在依次递归进行更改，减少因为更改而增加的复杂度。 ","date":"2022-04-04","objectID":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/:2:1","tags":["线段树"],"title":"线段树","uri":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/"},{"categories":["算法"],"content":"代码实现 ","date":"2022-04-04","objectID":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/:3:0","tags":["线段树"],"title":"线段树","uri":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/"},{"categories":["算法"],"content":"区间求和 307. 区域和检索 - 数组可修改 给你一个数组 nums ，请你完成两类查询。 其中一类查询要求 更新 数组 nums 下标对应的值 另一类查询要求返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 ，其中 left \u003c= right 实现 NumArray 类： NumArray(int[] nums) 用整数数组 nums 初始化对象 void update(int index, int val) 将 nums[index] 的值 更新 为 val int sumRange(int left, int right) 返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 （即，nums[left] + nums[left + 1], ..., nums[right]） 线段树各层数量为等比数量，最大需要 4n 空间。根据二叉树性质，父节点 i 的两个子节点对应的索引分别为 2 * i + 1 和 2 * i + 2 ，i 从0开始编号，从而可以使用数组来表示线段树。 class NumArray { private int[] segmentTree; private int n; public NumArray(int[] nums) { n = nums.length; segmentTree = new int[nums.length * 4]; build(0, 0, n - 1, nums); } public void update(int index, int val) { change(index, val, 0, 0, n - 1); } public int sumRange(int left, int right) { return range(left, right, 0, 0, n - 1); } private void build(int node, int s, int e, int[] nums) { if (s == e) { segmentTree[node] = nums[s]; return; } int m = s + (e - s) / 2; build(node * 2 + 1, s, m, nums); build(node * 2 + 2, m + 1, e, nums); segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2]; } private void change(int index, int val, int node, int s, int e) { if (s == e) { segmentTree[node] = val; return; } int m = s + (e - s) / 2; if (index \u003c= m) { change(index, val, node * 2 + 1, s, m); } else { change(index, val, node * 2 + 2, m + 1, e); } segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2]; } private int range(int left, int right, int node, int s, int e) { if (left == s \u0026\u0026 right == e) { return segmentTree[node]; } int m = s + (e - s) / 2; if (right \u003c= m) { return range(left, right, node * 2 + 1, s, m); } else if (left \u003e m) { return range(left, right, node * 2 + 2, m + 1, e); } else { return range(left, m, node * 2 + 1, s, m) + range(m + 1, right, node * 2 + 2, m + 1, e); } } } 链表实现，因为构造线段树采用 自顶向下 实现，所以使用了前缀和来构造线段树。 class TreeNode{ int val; int low; int high; TreeNode left; TreeNode right; TreeNode parent; } class NumArray { int n; TreeNode root; int[] prefix; int sum; public NumArray(int[] nums) { n = nums.length; root = new TreeNode(); prefix = new int[n]; prefix[0] = nums[0]; for(int i = 1; i \u003c n; i++){ prefix[i] = prefix[i - 1] + nums[i]; } root.val = prefix[n-1]; root.low = 0; root.high = n -1; root.left = init(root, nums, 0, (n-1) / 2); root.right = init(root, nums, (n-1) / 2 + 1, n - 1); } public TreeNode init(TreeNode root, int[] nums, int low, int high){ if(low \u003e high){ return null; } TreeNode child = new TreeNode(); child.parent = root; child.low = low; child.high = high; if(low == 0){ child.val = prefix[high]; }else{ child.val = prefix[high] - prefix[low - 1]; } if(low == high){ return child; }else{ child.left = init(child, nums, low, (low + high) / 2); child.right = init(child, nums, (low + high) / 2 + 1, high); return child; } } public void update(int index, int val) { TreeNode p = root; int mid = (p.low + p.high) / 2; while(p.low != index || p.high != index){ if(mid \u003c index){ p = p.right; }else{ p = p.left; } mid = (p.low + p.high) / 2; } p.val = val; while(p.parent != null){ if(p.parent.right != null){ p.parent.val = p.parent.left.val + p.parent.right.val; }else{ p.parent.val = p.parent.left.val; } p = p.parent; } } public int sumRange(int left, int right) { sum = 0; TreeNode p = root; if(left == root.low \u0026\u0026 right == root.high){ return root.val; } return getSum(p, left, right); } public void getSum(TreeNode root, int left, int right) { if(root == null){ return; } int mid = (root.low + root.high) / 2; if(root.low == left \u0026\u0026 root.high == right) { sum = root.val; return; } if(root.low == left \u0026\u0026 root.high \u003c right) { sum += root.val; return ; } if(root.low \u003e left \u0026\u0026 root.high \u003c right) { sum += root.val; return; } if(root.low \u003e left \u0026\u0026 root.high == right) { sum += root.val; return; } if(mid \u003c= right) { getSum(root.right, left, right); } getSum(root.left, left, right); } } ","date":"2022-04-04","objectID":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/:3:1","tags":["线段树"],"title":"线段树","uri":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/"},{"categories":["算法"],"content":"动态开点线段树 当离散点数量过大时，比如 $1e9$ 级别，直接创建线段树可能会内存超出，所以需要动态开点创建线段树，此时直接使用数组无法进行表示，需要使用节点对象数组。该节点需要维护信息的如下： ls/rs: 分别代表当前节点的左右子节点在线段树数组 tr 中的下标； add: 懒标记； val: 为当前区间的所包含的点的数量 729. 我的日程安排表 I 动态开点相比于原始的线段树实现，本质仍是使用「满二叉树」的形式进行存储，只不过是按需创建区间，如果我们是按照连续段进行查询或插入，最坏情况下仍然会占到 $O(4*n)$ 的空间，因此盲猜 $\\log{n}$ 的常数在 4 左右，保守一点可以直接估算到 6，因此我们可以估算点数为 $6 * m * \\log{n}$ ，其中 $n = 1e9$ 和 $m = 1e3$ 分别代表值域大小和查询次数。 当然一个比较实用的估点方式可以「尽可能的多开点数」，利用题目给定的空间上界和我们创建的自定义类（结构体）的大小，尽可能的多开（ Java 的 128M 可以开到 $5 * 10^6$ 以上） 代码实现如下： class MyCalendar { class Node { int ls, rs, add, val; } int N = (int)1e9, M = 120010, cnt = 1; Node[] tr = new Node[M]; void update(int u, int lc, int rc, int l, int r, int v) { if (l \u003c= lc \u0026\u0026 rc \u003c= r) { tr[u].val += (rc - lc + 1) * v; tr[u].add += v; return ; } lazyCreate(u); pushdown(u, rc - lc + 1); int mid = lc + rc \u003e\u003e 1; if (l \u003c= mid) update(tr[u].ls, lc, mid, l, r, v); if (r \u003e mid) update(tr[u].rs, mid + 1, rc, l, r, v); pushup(u); } int query(int u, int lc, int rc, int l, int r) { if (l \u003c= lc \u0026\u0026 rc \u003c= r) return tr[u].val; lazyCreate(u); pushdown(u, rc - lc + 1); int mid = lc + rc \u003e\u003e 1, ans = 0; if (l \u003c= mid) ans = query(tr[u].ls, lc, mid, l, r); if (r \u003e mid) ans += query(tr[u].rs, mid + 1, rc, l, r); return ans; } void lazyCreate(int u) { if (tr[u] == null) tr[u] = new Node(); if (tr[u].ls == 0) { tr[u].ls = ++cnt; tr[tr[u].ls] = new Node(); } if (tr[u].rs == 0) { tr[u].rs = ++cnt; tr[tr[u].rs] = new Node(); } } void pushdown(int u, int len) { tr[tr[u].ls].add += tr[u].add; tr[tr[u].rs].add += tr[u].add; tr[tr[u].ls].val += len / 2 * tr[u].add; tr[tr[u].rs].val += len / 2 * tr[u].add; tr[u].add = 0; } void pushup(int u) { tr[u].val = tr[tr[u].ls].val + tr[tr[u].rs].val; } public boolean book(int start, int end) { if (query(1, 1, N + 1, start + 1, end) \u003e 0) return false; update(1, 1, N + 1, start + 1, end, 1); return true; } } ","date":"2022-04-04","objectID":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/:4:0","tags":["线段树"],"title":"线段树","uri":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/"},{"categories":["算法"],"content":"参考资料 线段树 OI Wiki 线段树 【宫水三叶】一题双解 :「模拟」\u0026「线段树（动态开点 算法学习笔记(49): 线段树的拓展 动态开点线段树 ","date":"2022-04-04","objectID":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/:5:0","tags":["线段树"],"title":"线段树","uri":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/"},{"categories":["算法"],"content":"动态规划","date":"2022-04-03","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/","tags":["算法","动态规划"],"title":"动态规划","uri":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/"},{"categories":["算法"],"content":"前言 动态规划与分治方法类似，通过组合子问题解决原问题。动态规划应用与子问题重叠的情况，及不同的子问题具有公共 的子子问题的解。动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。 适用情况 (摘自 维基百科 动态规划) ： 最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。 无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。 ","date":"2022-04-03","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/:1:0","tags":["算法","动态规划"],"title":"动态规划","uri":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/"},{"categories":["算法"],"content":"解题思路 动态规划算法主要通过四个步骤来设计 刻画一个最优解的结构特征 递归定义最优解 计算最优解的值（自底向上或带备忘的自顶向下，大部分使用自底向上) 利用计算的信息构造最优解 ","date":"2022-04-03","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/:2:0","tags":["算法","动态规划"],"title":"动态规划","uri":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/"},{"categories":["算法"],"content":"代码实现 以 剑指 Offer II 093. 最长斐波那契数列 题目为例 如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是 斐波那契式 的： n \u003e= 3 对于所有 i + 2 \u003c= n，都有 X_i + X_{i+1} = X_{i+2} 给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。 （回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列） 斐波纳契数列长度主要观察最后两位，若后续值可以等于最后两位的和，则表示可以将该数加入对应的数列当中。于是可以使用dp[i][j]：表示以arr[i] , arr[j]结尾的斐波那契数列的最大长度。若 arr[j] - arr[i] 存在数列当中，且索引小于 i 时，记为 k ，则 dp[i][j] 需要进行更新，dp[i][j] = max(dp[i][j], dp[k][i] + 1) 。 为了降低确认 差值 是否存在数列当中且索引低于 i ，可以先将数列存入哈希表当中，其中 Key 为值， Value 为索引。 class Solution { public int lenLongestFibSubseq(int[] arr) { int n = arr.length; Map\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); for(int i = 0; i \u003c n; i++){ map.put(arr[i], i); } int[][] dp = new int[n][n]； int max = 0; for(int i = 0; i \u003c n - 1; i++) { for(int j = i + 1; j \u003c n; j++) { int temp = arr[j] - arr[i]; int index = map.getOrDefault(temp, -1); if(index \u003e -1 \u0026\u0026 index \u003c i) { dp[i][j] = dp[index][i] + 1; max = Math.max(max, dp[i][j] + 2); } } } return max \u003e 2 ? max : 0; } } 注：解该题的重要思路就是确认 dp 数组表示的内容，即表示到达 i 和 j 的斐波纳契数列最大长度。 ","date":"2022-04-03","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/:3:0","tags":["算法","动态规划"],"title":"动态规划","uri":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/"},{"categories":["算法"],"content":"再优化 更新 dp 数组时，上述代码采用的是暴力更新。因为数列是已经排序好了的，可以采用双指针进行遍历更新，从而减少时间复杂度，同时也不在需要哈希表了。 class Solution { public int lenLongestFibSubseq(int[] arr) { int n = arr.length, max = 0; int[][] dp = new int[n][n]; for(int i = 2 ; i \u003c n ; i++){ int j = 0, k = i-1; while(j \u003c k){ if(arr[j] + arr[k] == arr[i]){ if(dp[j][k] == 0){ dp[k][i] = 3; }else{ dp[k][i] = Math.max(dp[j][k]+1, dp[k][i]); } max = Math.max(max, dp[k][i]); j++;k--; } else if(arr[j] + arr[k] \u003c arr[i]){ j++; }else { k--; } } } return max; } } ","date":"2022-04-03","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/:3:1","tags":["算法","动态规划"],"title":"动态规划","uri":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/"},{"categories":["算法"],"content":"参考资料 动态规划 状态定义很是重要！ 算法导论 ","date":"2022-04-03","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/:4:0","tags":["算法","动态规划"],"title":"动态规划","uri":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/"},{"categories":["算法"],"content":"博弈论常见案例","date":"2022-04-02","objectID":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/","tags":["算法","双博弈论"],"title":"博弈论","uri":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/"},{"categories":["算法"],"content":"前言 博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。表面上不同的相互作用可能表现出相似的激励结构（incentive structure），所以它们是同一个游戏的特例。 ","date":"2022-04-02","objectID":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/:1:0","tags":["算法","双博弈论"],"title":"博弈论","uri":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/"},{"categories":["算法"],"content":"博弈论基本解法 由于博弈论都是在考虑最优解的情况下进行的步骤，所以只需要知道在各个步骤的的必败必胜必和情况，并以此进行规划就可以知道最后的胜负状况。其中最重要的是，是确定必胜/必败/必和的条件。 ","date":"2022-04-02","objectID":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/:2:0","tags":["算法","双博弈论"],"title":"博弈论","uri":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/"},{"categories":["算法"],"content":"案例一 异或数列 ： Alice 和 Bob 正在玩一个异或数列的游戏。初始时，Alice 和 Bob 分别有一个整数 a 和 b，有一个给定的长度为 n 的公共数列 $X_1, X_2, · · · , X_n$Alice 和 Bob 轮流操作，Alice 先手，每步可以在以下两种选项中选一种： 选项 1：从数列中选一个 Xi 给 Alice 的数异或上，或者说令 a 变为 a ⊕ $X_i$。（其中 ⊕ 表示按位异或） 选项 2：从数列中选一个 Xi 给 Bob 的数异或上，或者说令 b 变为 b ⊕ $X_i$。 每个数 Xi 都只能用一次，当所有 $X_i$ 均被使用后（n 轮后）游戏结束。游戏结束时，拥有的数比较大的一方获胜，如果双方数值相同，即为平手。现在双方都足够聪明，都采用最优策略，请问谁能获胜。（$n \u003c 2^{20}$） 首先确认游戏的必胜/必败/必和情况。其中必和情况为：A=B ，所以 A^B = 0 ，所以只需要对各个数字异或判断是否为 0 即可。剩下比较异或结果的数字大小，只需要看最高位即可，故只需要统计一下各个位 1 的个数。由题目可知，各个数字都可以由 20 位表示。 必和：$X_0$ ⊕ $X_i$ ⊕ $X_n$ = 0 i = 1, 2, …, n -1 必胜/必败：最高位，1 的个数位偶数，则下一位判断。奇数时 1 的个数为 1 时，则先手获胜 大于 1 时，总数字个数位偶数时，先手必败 大于 1 时，总数字个数位奇数时，先手必胜 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); int T = in.nextInt(); int[] ans = new int[T]; long sum = 1; for(int i = 0; i \u003c T; i++) { int n = in.nextInt(); int[] count = new int[20]; sum = 0; for(int j = 0; j \u003c n; j++) { long num = in.nextLong(); int temp = 1; int k = 0; sum = sum ^ num; for(; k \u003c 20; k++) { if((num \u0026 temp) == temp) { count[k]++; } temp \u003c\u003c= 1; } } if(sum == 0) { ans[i] = 0; // System.out.println(0); continue; } int k = 19; for(; k \u003e= 0; k--) { if(count[k] == 1) { ans[i] = 1; // System.out.println(1); break; }else if(count[k] % 2 == 1 \u0026\u0026 n % 2 == 0) { ans[i] = -1; // System.out.println(-1); break; }else if(count[k] % 2 == 1 \u0026\u0026 n % 2 == 1) { ans[i] = 1; // System.out.println(1); break; } } } for(int i = 0; i \u003c T; i++) { System.out.println(ans[i]); } } } ","date":"2022-04-02","objectID":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/:2:1","tags":["算法","双博弈论"],"title":"博弈论","uri":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/"},{"categories":["算法"],"content":"案例二 著名的 Nim游戏 ： 有 n 堆石子，每堆各有 $a_i$ 颗石子。Alice 和 Bob 轮流从非空的石子堆取走至少一颗石子。Alice 先取，取光所有石子的一方获胜。当双方采取最优策略时，谁会获胜？ 同样，首先确认该游戏必胜/必败/必和情况。有如下结论成立 $$a_1 XOR a_2 XOR … XOR a_n != 0 —\u003e 必胜态 $$ $$a_1 XOR a_2 XOR … XOR a_n == 0 —\u003e 必败态 $$ 其中 XOR 表示异或。 ","date":"2022-04-02","objectID":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/:2:2","tags":["算法","双博弈论"],"title":"博弈论","uri":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/"},{"categories":["算法"],"content":"参考 博弈论 挑战程序设计竞赛 蓝桥杯2021年第十二届省赛真题-异或数列 ","date":"2022-04-02","objectID":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/:3:0","tags":["算法","双博弈论"],"title":"博弈论","uri":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/"},{"categories":["Java"],"content":"Comparator类的compare方法重写","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["Java"],"content":"前言 做算法题时，经常遇到需要对某些数据结构的 compare 方法重写，比如 PriorityQueue，但 Java 默认实现的优先队列为小顶堆，即最小的优先选择。但有的时候需要大顶堆或者其他数据类型比较，比如数组，类等，所以，必须对 Comparator 的 compare 方法进行重写 ","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/:1:0","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["Java"],"content":"基本步骤 以下都以 PriorityQueue 优先队列实现作为参考，其他数据结构类似 ","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/:2:0","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["Java"],"content":"基本数据类型 当对基本数据类型重写时，只需要对方法简单重写即可。重写方法有创建 Comparator 的子类、匿名类或者 Lambda 表达式。以下均为改写为升序优先队列，即大顶堆实现方式。 子类 继承 Comparator 子类并重写父类的方法，是最基本的实现方式 class Main{ public static void main(String[] args){ PriorityQueue\u003cInteger\u003e numbers = new PriorityQueue\u003c\u003e(new myComparator()); } } class MyComparator implements Comparator\u003cInteger\u003e { @Override public int compare(Integer number1, Integer number2) { return number2 - number1; } } 匿名类 为了减少创建不必要的类，可以直接使用匿名类完成 class Main{ public static void main(String[] args){ PriorityQueue\u003cInteger\u003e numbers = new PriorityQueue\u003c\u003e(new Comparator(){ @Override public int compare(Integer number1, Integer number2) { return number2 - number1; } }); } } Lambda 表达式 为了减少使用匿名类的代码，可以直接使用 Lambda 表达式 class Main{ public static void main(String[] args){ PriorityQueue\u003cInteger\u003e numbers = new PriorityQueue\u003c\u003e((a, b) -\u003e b - a); } } ","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/:2:1","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["Java"],"content":"数组 数组重写方法基本与基本数据类似，只以匿名类写法作为参考 class Main{ public static void main(String[] args){ PriorityQueue\u003cint[]\u003e numbers = new PriorityQueue\u003c\u003e(new Comparator\u003cint[]\u003e(){ @Override public int compare(int[] o1, int[] o2){ return o1[1] - o2[1]; } }); } } 该优先队列存储数据结构类型为 int 数组，且以下数组的索引 1 为对应数据降序排序 ","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/:2:2","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["Java"],"content":"二维数组 有的时候需要对二维数组的某一维度进行排序，比如需要调用 Arrays.sort() 方法对二维数组排序，但原生排序只支持一维数组，故需要重写，例如对二维数组的第一维度进行升序排序 Arrays.sort(intervals, new Comparator\u003cint[]\u003e() { @Override public int compare(int[] o1 , int[] o2){ return o1[0] - o2[0]; } }); ","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/:2:3","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["Java"],"content":"参考资料 Java PriorityQueue 1606. 找到处理最多请求的服务器 ","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/:3:0","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["深度学习"],"content":"Pytorch 常用api记录","date":"2022-03-29","objectID":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/","tags":["pytorch","基础"],"title":"Pytorch 常用api","uri":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/"},{"categories":["深度学习"],"content":"前言 Pytorch 是研究生阶段深度学习常用的工具。在学习深度学习的过程中，记录一下使用 Pytorch 经常遇到 api。 ","date":"2022-03-29","objectID":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/:1:0","tags":["pytorch","基础"],"title":"Pytorch 常用api","uri":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/"},{"categories":["深度学习"],"content":"常用 API ","date":"2022-03-29","objectID":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/:2:0","tags":["pytorch","基础"],"title":"Pytorch 常用api","uri":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/"},{"categories":["深度学习"],"content":"Tensor.repeat(*sizes) -\u003e Tensor 沿指定维度重复张量 sizes 次数，可以同时指定多个维度，例如 \u003e\u003e\u003e x = torch.tensor([1, 2, 3]) \u003e\u003e\u003e x.repeat(4, 2) tensor([[ 1, 2, 3, 1, 2, 3], [ 1, 2, 3, 1, 2, 3], [ 1, 2, 3, 1, 2, 3], [ 1, 2, 3, 1, 2, 3]]) \u003e\u003e\u003e x.repeat(4, 2, 1).size() torch.Size([4, 2, 3]) 上述表达式为在第 0 维度重复四次，在第 1 维度重复两次 ","date":"2022-03-29","objectID":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/:2:1","tags":["pytorch","基础"],"title":"Pytorch 常用api","uri":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/"},{"categories":["深度学习"],"content":"torch.permute(input, dims) -\u003e Tensor 按所给顺序交换张量各个维度 \u003e\u003e\u003e x = torch.randn(2, 3, 5) \u003e\u003e\u003e x.size() torch.Size([2, 3, 5]) \u003e\u003e\u003e torch.permute(x, (2, 0, 1)).size() torch.Size([5, 2, 3]) 默认顺序从 0 开始，上述表达式为各个维度向右移动一位。 ","date":"2022-03-29","objectID":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/:2:2","tags":["pytorch","基础"],"title":"Pytorch 常用api","uri":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/"},{"categories":["深度学习"],"content":"torch.empty(size…)→ Tensor 安装所给的维度，初始化一个张量，但张量内数据未初始化（随机） \u003e\u003e\u003e torch.empty((2,3), dtype=torch.int64) tensor([[ 9.4064e+13, 2.8000e+01, 9.3493e+13], [ 7.5751e+18, 7.1428e+18, 7.5955e+18]]) ","date":"2022-03-29","objectID":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/:2:3","tags":["pytorch","基础"],"title":"Pytorch 常用api","uri":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/"},{"categories":["深度学习"],"content":"torch.transpose(input, dim0, dim1) → Tensor 将 input 的 tensor的 dim0 和 dim1 维度转置 \u003e\u003e\u003e x = torch.randn(2, 3) \u003e\u003e\u003e x tensor([[ 1.0028, -0.9893, 0.5809], [-0.1669, 0.7299, 0.4942]]) \u003e\u003e\u003e torch.transpose(x, 0, 1) tensor([[ 1.0028, -0.1669], [-0.9893, 0.7299], [ 0.5809, 0.4942]]) ","date":"2022-03-29","objectID":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/:2:4","tags":["pytorch","基础"],"title":"Pytorch 常用api","uri":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/"},{"categories":["深度学习"],"content":"torch.index_select(input, dim, index, ***, out=None) → Tensor 返回一个新张量，该张量使用索引中的条目沿维度 dim 索引输入张量，该条目是 LongTensor ","date":"2022-03-29","objectID":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/:2:5","tags":["pytorch","基础"],"title":"Pytorch 常用api","uri":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/"},{"categories":["深度学习"],"content":"Transformer 代码分析","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"前言 Transformer 是 2017 年 Google 团队提出的新的一种 NLP 模型，采用 Encoder-Decoder （编码器-解码器）架构，使用 self-attention 机制。 其在 seq2seq 上表现出非常鲁棒的性能，并且在 Transformer 基础上，提出了众多变种类型，比较知名的有 Bert 和 GPT 。以上模型，在 github 中都有实现 State-of-the-art Machine Learning for JAX, PyTorch and TensorFlow Transformer 模型框架) ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:1:0","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"基本结构 为了更好的理解和运用 Transformer ，应理解 Transformer 代码实现过程 以下代码来自 动手学深度学习 PyTorch版 ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:2:0","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"导包 因为在如下部分代码中使用了动手学深度学习 PyTorch版 使用了自身提供的库，需要将他们的库导入 import math import pandas as pd import torch from torch import nn from d2l import torch as d2l ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:2:1","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"逐位前馈网络 逐位前馈网络 实质就是一个 MLP 网络，含有两个 全连接层 ，和一个 ReLU 层。 class PositionWiseFFN(nn.Module): \"\"\"基于位置的前馈网络\"\"\" def __init__(self, ffn_num_input, ffn_num_hiddens, ffn_num_outputs, **kwargs): super(PositionWiseFFN, self).__init__(**kwargs) self.dense1 = nn.Linear(ffn_num_input, ffn_num_hiddens) self.relu = nn.ReLU() self.dense2 = nn.Linear(ffn_num_hiddens, ffn_num_outputs) def forward(self, X): return self.dense2(self.relu(self.dense1(X))) ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:2:2","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"残差和层规范化 和 RNN 类似，残差在 Transformer 中，使用的是 batch normlization ，而不是常用的 layer normlization #@save class AddNorm(nn.Module): \"\"\"残差连接后进行层规范化\"\"\" def __init__(self, normalized_shape, dropout, **kwargs): super(AddNorm, self).__init__(**kwargs) self.dropout = nn.Dropout(dropout) self.ln = nn.LayerNorm(normalized_shape) def forward(self, X, Y): return self.ln(self.dropout(Y) + X) ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:2:3","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"编码块 Transformer 中含有 6 层 编码块和 6 层 解码 块。在每个编码块中包含有一个注意力层、两个批量规范层和一个逐位前馈网络层，在每个批量规范层中都使用了残差连接 class EncoderBlock(nn.Module): \"\"\"transformer编码器块\"\"\" def __init__(self, key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, dropout, use_bias=False, **kwargs): super(EncoderBlock, self).__init__(**kwargs) self.attention = d2l.MultiHeadAttention( key_size, query_size, value_size, num_hiddens, num_heads, dropout, use_bias) self.addnorm1 = AddNorm(norm_shape, dropout) self.ffn = PositionWiseFFN( ffn_num_input, ffn_num_hiddens, num_hiddens) self.addnorm2 = AddNorm(norm_shape, dropout) def forward(self, X, valid_lens): Y = self.addnorm1(X, self.attention(X, X, X, valid_lens)) return self.addnorm2(Y, self.ffn(Y)) ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:2:4","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"解码块 与编码块不同的是，在解码块中使用了两个注意力层，第一个注意层用来生成 Query，并将编码器的结果作为 Key 和 Value ，送入第二个注意层学习。在使用多头注意力机制时，将每个头的结果矩阵拼接起来，最后在传入全连接层计算。 class DecoderBlock(nn.Module): \"\"\"解码器中第 i 个块\"\"\" def __init__(self, key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, dropout, i, **kwargs): super(DecoderBlock, self).__init__(**kwargs) self.i = i self.attention1 = d2l.MultiHeadAttention( key_size, query_size, value_size, num_hiddens, num_heads, dropout) self.addnorm1 = AddNorm(norm_shape, dropout) self.attention2 = d2l.MultiHeadAttention( key_size, query_size, value_size, num_hiddens, num_heads, dropout) self.addnorm2 = AddNorm(norm_shape, dropout) self.ffn = PositionWiseFFN(ffn_num_input, ffn_num_hiddens, num_hiddens) self.addnorm3 = AddNorm(norm_shape, dropout) def forward(self, X, state): enc_outputs, enc_valid_lens = state[0], state[1] # 训练阶段，输出序列的所有词元都在同一时间处理， # 因此 `state[2][self.i]` 初始化为 `None`。 # 预测阶段，输出序列是通过词元一个接着一个解码的， # 因此 `state[2][self.i]` 包含着直到当前时间步第 `i` 个块解码的输出表示 if state[2][self.i] is None: key_values = X else: key_values = torch.cat((state[2][self.i], X), axis=1) state[2][self.i] = key_values if self.training: batch_size, num_steps, _ = X.shape # `dec_valid_lens` 的开头: (`batch_size`, `num_steps`), # 其中每一行是 [1, 2, ..., `num_steps`] dec_valid_lens = torch.arange( 1, num_steps + 1, device=X.device).repeat(batch_size, 1) else: dec_valid_lens = None # 自注意力 X2 = self.attention1(X, key_values, key_values, dec_valid_lens) Y = self.addnorm1(X, X2) # 编码器－解码器注意力。 # `enc_outputs` 的开头: (`batch_size`, `num_steps`, `num_hiddens`) Y2 = self.attention2(Y, enc_outputs, enc_outputs, enc_valid_lens) Z = self.addnorm2(Y, Y2) return self.addnorm3(Z, self.ffn(Z)), state ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:2:5","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"实现代码 Transformer 模型分为两大部分，编码器和解码器，根据上述基本结构，就可以实现这两大部分 ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:3:0","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"编码器 在 Transformer 的编码器包含了多个编码块。可以使用 nn.Sequential() 生成多个编码块，构成编码器 class TransformerEncoder(d2l.Encoder): \"\"\"transformer编码器\"\"\" def __init__(self, vocab_size, key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, num_layers, dropout, use_bias=False, **kwargs): super(TransformerEncoder, self).__init__(**kwargs) self.num_hiddens = num_hiddens self.embedding = nn.Embedding(vocab_size, num_hiddens) self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout) self.blks = nn.Sequential() for i in range(num_layers): self.blks.add_module(\"block\"+str(i), EncoderBlock(key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, dropout, use_bias)) def forward(self, X, valid_lens, *args): # 因为位置编码值在 -1 和 1 之间， # 因此嵌入值乘以嵌入维度的平方根进行缩放， # 然后再与位置编码相加。 X = self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens)) self.attention_weights = [None] * len(self.blks) for i, blk in enumerate(self.blks): X = blk(X, valid_lens) self.attention_weights[ i] = blk.attention.attention.attention_weights return X ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:3:1","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"解码器 同编码器一样，使用使用 nn.Sequential() 生成多个解码块，构成解码器 class TransformerDecoder(d2l.AttentionDecoder): def __init__(self, vocab_size, key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, num_layers, dropout, **kwargs): super(TransformerDecoder, self).__init__(**kwargs) self.num_hiddens = num_hiddens self.num_layers = num_layers self.embedding = nn.Embedding(vocab_size, num_hiddens) self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout) self.blks = nn.Sequential() for i in range(num_layers): self.blks.add_module(\"block\"+str(i), DecoderBlock(key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, dropout, i)) self.dense = nn.Linear(num_hiddens, vocab_size) def init_state(self, enc_outputs, enc_valid_lens, *args): return [enc_outputs, enc_valid_lens, [None] * self.num_layers] def forward(self, X, state): X = self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens)) self._attention_weights = [[None] * len(self.blks) for _ in range (2)] for i, blk in enumerate(self.blks): X, state = blk(X, state) # 解码器自注意力权重 self._attention_weights[0][ i] = blk.attention1.attention.attention_weights # “编码器－解码器”自注意力权重 self._attention_weights[1][ i] = blk.attention2.attention.attention_weights return self.dense(X), state @property def attention_weights(self): return self._attention_weights ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:3:2","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"训练与预测 # 训练 num_hiddens, num_layers, dropout, batch_size, num_steps = 32, 2, 0.1, 64, 10 lr, num_epochs, device = 0.005, 200, d2l.try_gpu() ffn_num_input, ffn_num_hiddens, num_heads = 32, 64, 4 key_size, query_size, value_size = 32, 32, 32 norm_shape = [32] train_iter, src_vocab, tgt_vocab = d2l.load_data_nmt(batch_size, num_steps) encoder = TransformerEncoder( len(src_vocab), key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, num_layers, dropout) decoder = TransformerDecoder( len(tgt_vocab), key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, num_layers, dropout) net = d2l.EncoderDecoder(encoder, decoder) d2l.train_seq2seq(net, train_iter, lr, num_epochs, tgt_vocab, device) # 预测 engs = ['go .', \"i lost .\", 'he\\'s calm .', 'i\\'m home .'] fras = ['va !', 'j\\'ai perdu .', 'il est calme .', 'je suis chez moi .'] for eng, fra in zip(engs, fras): translation, dec_attention_weight_seq = d2l.predict_seq2seq( net, eng, src_vocab, tgt_vocab, num_steps, device, True) print(f'{eng} =\u003e {translation}, ', f'bleu {d2l.bleu(translation, fra, k=2):.3f}') ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:3:3","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["算法"],"content":"计算质因子个数","date":"2022-03-25","objectID":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/","tags":["算法","质因子"],"title":"质因子个数计算","uri":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/"},{"categories":["算法"],"content":"前言 172. 阶乘后的零 该题中计算阶乘结果 0 的个数，可转换为计算 n 中含有 5 质因子的个数问题 ","date":"2022-03-25","objectID":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/:1:0","tags":["算法","质因子"],"title":"质因子个数计算","uri":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/"},{"categories":["算法"],"content":"算法思想 [1,n] 中 p 的倍数有 $n_1 = \\lfloor \\frac{n}{p} \\rfloor$ ，以此类推可以得到 $n_i = \\lfloor \\frac{n}{p^i} \\rfloor$ 可以得到 $p^i$ 质因子的个数。又因为若 n 是 $p^i$ 的倍数，则 n 必定也是 $n^{i-1}$ 的倍数，故 [1, n]的中的 p 的质因子个数为 $\\sum \\lfloor \\frac{n}{p^i} \\rfloor$ 计算结果的 0 的个数即统计 10 因子的个数，质因素分解为 2 和 5 ，根据上述公式，可以知道 2 的 个数多余 5 的个数，故只要计算 5 的质因子个数。 ","date":"2022-03-25","objectID":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/:2:0","tags":["算法","质因子"],"title":"质因子个数计算","uri":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/"},{"categories":["算法"],"content":"代码 class Solution { public int trailingZeroes(int n) { int res = 0; while(n \u003e= 5){ res += n / 5; n /= 5; } return res; } } ","date":"2022-03-25","objectID":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/:3:0","tags":["算法","质因子"],"title":"质因子个数计算","uri":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/"},{"categories":["算法"],"content":"参考资料 阶乘后的零 ","date":"2022-03-25","objectID":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/:4:0","tags":["算法","质因子"],"title":"质因子个数计算","uri":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/"},{"categories":["Java"],"content":"Java 的常用数据结构","date":"2022-03-24","objectID":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/","tags":["数据结构"],"title":"Java 常用数据结构","uri":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Java"],"content":"LinkedList LinkedList 链表，除了 队列 接口，还实现了 双端队列 void add(int index, E element) : 在特定位置位置插入元素 boolean add(E e) ： 在链表尾部加入元素 E remove(int index) ： 删除链表给定序号的元素 E removeLast() : 删除链表尾部元素 ","date":"2022-03-24","objectID":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:1:0","tags":["数据结构"],"title":"Java 常用数据结构","uri":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Java"],"content":"HashMap HashMap 哈希表，可以存 空值 ，不保证映射后的遍历顺序，也不保证该顺序会随着时间变化而保持，迭代方式 键值迭代 import java.util.HashMap; import java.util.Map; public class Test { public static void main(String[] args) throws IOException { Map\u003cInteger, Integer\u003e map = new HashMap\u003cInteger, Integer\u003e(); map.put(1, 10); map.put(2, 20); // Iterating entries using a For Each loop for (Map.Entry\u003cInteger, Integer\u003e entry : map.entrySet()) { System.out.println(\"Key = \" + entry.getKey() + \", Value = \" + entry.getValue()); } } } 键迭代 import java.util.HashMap; import java.util.Map; public class Test { public static void main(String[] args) throws IOException { Map\u003cInteger, Integer\u003e map = new HashMap\u003cInteger, Integer\u003e(); map.put(1, 10); map.put(2, 20); // 迭代键 for (Integer key : map.keySet()) { System.out.println(\"Key = \" + key); } // 迭代值 for (Integer value : map.values()) { System.out.println(\"Value = \" + value); } } } boolean isEmpty() : 判断哈希表是否为空 boolean containsKet(Object Key) : 查询哈希表是否存在 Key ，存在返回 true Set\u003cMap.Entry \u003cK, V\u003e\u003e entrySet() ： 获取 HashMap 的迭代器，可以同时获得 Key 和 Value Set\u003cK\u003e keySet ：获取哈希表的 Key 的迭代器 V remove(Object Key) : 溢出哈希表的 Key和对于的 Value int size() : 获取哈希标的实际大小 ","date":"2022-03-24","objectID":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:2:0","tags":["数据结构"],"title":"Java 常用数据结构","uri":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Java"],"content":"LinkedHashMap LinkedHashMap 与 HashMap 不同的是，该哈希表可以预测迭代顺序，因为实现了双向链表，该链表定义了迭代顺序，api 同上 ","date":"2022-03-24","objectID":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:3:0","tags":["数据结构"],"title":"Java 常用数据结构","uri":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Java"],"content":"TreeSet TreeSet 为有序集合，实现了 NavigableSet 接口，默认排序顺序为升序排序，内部结构为平衡二叉树(红黑树)。可以在 O(h) 的时间复杂度完成查找、增加、删除操作。由于实现了 NavigableSet 接口，可以实现查找小于、大于某元素的结果，如没有找到则返回 null 。所以，需要使用包装类接受返回值，而不能使用基本类型接受返回数据。 E ceiling(E e) : 返回此集合中大于或等于给定元素的最小元素，如果没有这样的元素，则返回 null E floor(E e) : 返回此集合中小于或等于给定元素的最大元素，如果没有这样的元素，则返回 null E greater(E e) : 返回此集合中严格大于给定元素的最小元素，如果没有这样的元素，则返回 null E lower(E e) : 返回此集合中严格小于给定元素的最小元素，如果没有这样的元素，则返回 null boolean contains(Object o) : 查询元素是否存在有序集合当中 ","date":"2022-03-24","objectID":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:4:0","tags":["数据结构"],"title":"Java 常用数据结构","uri":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Java"],"content":"TreeMap 基于红黑树的 NavigableMap 实现。根据其键的自然顺序排序，或者由地图创建时提供的 Comparator 排序，具体取决于使用的构造函数，和 TreeSet 类似。 Map.Entry\u003cK, V\u003e floorEntry(Key key) : 返回与小于或等于给定键的最大键关联的键值映射，如果没有这样的键，则返回 null K floorKey(Key key) ：返回小于或等于给定键的最大键，如果没有这样的键，则返回 null Map.Entry\u003cK, V\u003e ceilingEntry (Key key) ： 返回与大于或等于给定键的最小键关联的键值映射，如果没有这样的键，则返回 null K ceilingKey(Key key) ：返回大于或等于给定键的最小键，如果没有这样的键，则返回 null Map.Entry\u003cK, V\u003e lowerEntry(Key key) ： 返回与严格小于给定键的最大键关联的键值映射，如果没有这样的键，则返回 null K lowerKey(Key key) ：返回严格小于给定键的最大键，如果没有这样的键，则返回 null Map.Entry\u003cK, V\u003e higherEntry (Key key) ： 返回与严格大于给定键的最小键关联的键值映射，如果没有这样的键，则返回 null K highKey(Key key) ：返回严格大于给定键的最小键，如果没有这样的键，则返回 null ","date":"2022-03-24","objectID":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:4:1","tags":["数据结构"],"title":"Java 常用数据结构","uri":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Java"],"content":"PriorityQueue PriorityQueue 默认实现为小顶堆，与C++ 的优先队列默认为大顶堆不一样。 E peek() : 查看堆顶元素 E poll() : 删除顶堆元素 ","date":"2022-03-24","objectID":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:4:2","tags":["数据结构"],"title":"Java 常用数据结构","uri":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["算法"],"content":"变位词匹配 算法","date":"2022-03-24","objectID":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/","tags":["算法","变位词"],"title":"变位词","uri":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/"},{"categories":["算法"],"content":"前言 变位词 是指字符串更改字符顺序后相等的字符串（即字符串内各个字符出现的次数相等）。变位词 匹配就是将字符串数组中所有相同的变位词找出。 剑指 Offer II 033. 变位词组 ","date":"2022-03-24","objectID":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/:1:0","tags":["算法","变位词"],"title":"变位词","uri":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/"},{"categories":["算法"],"content":"算法思想 暴力求解 ：将两个字符串的各个字符查询统计并比较，这种算法的时间复杂度为 O(m*n) ，且难适用于多个字符串同时进行匹配分组 计数拼接 ： 将各个字符统计并计数，最后将各个字符与对应的次数进行拼接起来，比如 leetcode，计算得到的字符为 c1d1e3l1o1t1，接着将结果作为哈希 Key ， 该字符的索引作为 Value ，使用哈希匹配分组 素数求积 ： 将各个字符映射为一个素数，同时求得字符串的累积，并将结果作为哈希的 Key ，字符串的索引作为 Value ，使用哈希匹配分组。该思路需要考虑 大数 问题，若基本数据会溢出的话，可以使用 mod 求余，但这也需要考虑哈希冲突 ","date":"2022-03-24","objectID":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/:2:0","tags":["算法","变位词"],"title":"变位词","uri":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/"},{"categories":["算法"],"content":"代码 计数拼接代码，参考自 字母异位词分组 class Solution { public List\u003cList\u003cString\u003e\u003e groupAnagrams(String[] strs) { Map\u003cString, List\u003cString\u003e\u003e map = new HashMap\u003cString, List\u003cString\u003e\u003e(); for (String str : strs) { int[] counts = new int[26]; int length = str.length(); for (int i = 0; i \u003c length; i++) { counts[str.charAt(i) - 'a']++; } // 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键 StringBuffer sb = new StringBuffer(); for (int i = 0; i \u003c 26; i++) { if (counts[i] != 0) { sb.append((char) ('a' + i)); sb.append(counts[i]); } } String key = sb.toString(); List\u003cString\u003e list = map.getOrDefault(key, new ArrayList\u003cString\u003e()); list.add(str); map.put(key, list); } return new ArrayList\u003cList\u003cString\u003e\u003e(map.values()); } } 素数求积。根据题目所给要求，判断不会溢出，故没有取余 class Solution { public List\u003cList\u003cString\u003e\u003e groupAnagrams(String[] strs) { List\u003cList\u003cString\u003e\u003e res = new ArrayList\u003c\u003e(); Map\u003cLong, Integer\u003e map = new HashMap\u003c\u003e(); int[] primeNum = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47, 53,59,61,67,71,73,79,83,89,97,101}; long product = 1; String temp; int index; for(int i = 0; i \u003c strs.length; i++){ temp = strs[i]; product = 1; for(int j = 0; j \u003c temp.length(); j++){ product *= primeNum[temp.charAt(j) - 'a']; } if(map.containsKey(product)){ index = map.get(product); res.get(index).add(temp); }else{ List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(temp); res.add(list); map.put(product, res.size()-1); } } return res; } } ","date":"2022-03-24","objectID":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/:3:0","tags":["算法","变位词"],"title":"变位词","uri":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/"},{"categories":["算法"],"content":"参考资料 变位词问题 ","date":"2022-03-24","objectID":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/:4:0","tags":["算法","变位词"],"title":"变位词","uri":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/"},{"categories":["深度学习"],"content":"机器学习的常用缩写","date":"2022-03-23","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/","tags":["机器学习"],"title":"机器学习中常用缩写汇总","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/"},{"categories":["深度学习"],"content":"前言 阅读论文经常遇到各种缩写形式，为了方便论文阅读，故将论文常用的缩写记录下来 ","date":"2022-03-23","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/:1:0","tags":["机器学习"],"title":"机器学习中常用缩写汇总","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/"},{"categories":["深度学习"],"content":"机器学习 ","date":"2022-03-23","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/:2:0","tags":["机器学习"],"title":"机器学习中常用缩写汇总","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/"},{"categories":["深度学习"],"content":"深度学习 DNN ：Deep Neural Networks，深度神经网络，深度学习的基础 ReLU ：Rectified Linear Unit ，常用的激活函数 GMM ：Gaussian Mixture Model ，高斯混合模型，单一高斯概率密度函数的延伸，就是用多个高斯概率密度函数（正态分布曲线）精确地量化变量分布，是将变量分布分解为若干基于高斯概率密度函数（正态分布曲线）分布的统计模型。 HMM : Hidden Markov Model ，隐马尔可夫模型，用来描述一个含有隐含未知参数的马尔可夫过程 MAP ： Maximum APosteriori ，最大后验概率 MLLR ： Maximum Likelihood Linear Regression ，最大似然回归 DBN ： Deep Belief Networks ，深度置信网络 CD ： Context Dependent ，上下文相关 MFCC : Mel Frequency Cepstral Coeffcients ，梅尔倒谱系数，对语音进行编码 FBK ：Filter Bank Feature ，滤波器组特征，用于语音编码 PLP ： Perceptual Linear Prediction ，感知线性预测系数，用于语音编码 ","date":"2022-03-23","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/:3:0","tags":["机器学习"],"title":"机器学习中常用缩写汇总","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/"},{"categories":["算法"],"content":"字典树的基本原理","date":"2022-03-23","objectID":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/","tags":["算法","字典树"],"title":"字典树","uri":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/"},{"categories":["算法"],"content":"前言 字典树 ，是一种空间换时间的数据结构，又称 Trie 树、前缀树 ，是一种树形结构(字典树是一种数据结构)，用于统计、排序、和保存大量字符串 ","date":"2022-03-23","objectID":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/:1:0","tags":["算法","字典树"],"title":"字典树","uri":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/"},{"categories":["算法"],"content":"算法思想 按照题目所给的 字典序 要求，生成相应的 字典树 结构。后续查找通过公共前缀来减少查找时间，降低查找时间复杂度 字典树 的三个重要性质： 根节点不包含字符，除了根节点每个节点都只包含一个字符。root节点不含字符这样做的目的是为了能够包括所有字符串。 从根节点到某一个节点，路过字符串起来就是该节点对应的字符串。（也可以直接在该节点保存字符连接后的结果） 每个节点的子节点字符不同，也就是找到对应单词、字符是唯一的。 ","date":"2022-03-23","objectID":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/:2:0","tags":["算法","字典树"],"title":"字典树","uri":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/"},{"categories":["算法"],"content":"在优化 字典树 的空间复杂度为 O(N) ，可以根据 前序 结果推导出 后序 结果，可以不创建 字典树 ，直接使用 前序 进行迭代，相应的空间复杂度可降低至 O(1) 。例如 440. 字典序的第K小数字 ","date":"2022-03-23","objectID":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/:3:0","tags":["算法","字典树"],"title":"字典树","uri":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/"},{"categories":["算法"],"content":"代码 字典树 的实现 public class TrieNode { int count; int prefix; TrieNode[] nextNode=new TrieNode[26]; public TrieNode(){ count=0; prefix=0; } } //插入一个新单词 public static void insert(TrieNode root,String str){ if(root==null||str.length()==0){ return; } char[] c=str.toCharArray(); for(int i=0;i\u003cstr.length();i++){ //如果该分支不存在，创建一个新节点 if(root.nextNode[c[i]-'a']==null){ root.nextNode[c[i]-'a']=new TrieNode(); } root=root.nextNode[c[i]-'a']; root.prefix++;//注意，应该加在后面 } //以该节点结尾的单词数+1 root.count++; } //查找该单词是否存在，如果存在返回数量，不存在返回-1 public static int search(TrieNode root,String str){ if(root==null||str.length()==0){ return -1; } char[] c=str.toCharArray(); for(int i=0;i\u003cstr.length();i++){ //如果该分支不存在，表名该单词不存在 if(root.nextNode[c[i]-'a']==null){ return -1; } //如果存在，则继续向下遍历 root=root.nextNode[c[i]-'a']; } //如果count==0,也说明该单词不存在 if(root.count==0){ return -1; } return root.count; } //查询以str为前缀的单词数量 public static int searchPrefix(TrieNode root,String str){ if(root==null||str.length()==0){ return -1; } char[] c=str.toCharArray(); for(int i=0;i\u003cstr.length();i++){ //如果该分支不存在，表名该单词不存在 if(root.nextNode[c[i]-'a']==null){ return -1; } //如果存在，则继续向下遍历 root=root.nextNode[c[i]-'a']; } return root.prefix; } 440. 字典序的第K小数字 代码实现 class Solution { public int findKthNumber(int n, int k) { int pos = 1; k--; int step; while(k \u003e 0){ step = getStep(pos, n); if(step \u003e k){ pos *= 10; k--; }else{ k -= step; pos++; } } return pos; } public int getStep(int pos, int n){ long first = pos; long last = pos; int step = 0; while(first \u003c= n){ step += Math.min(last, n) - first + 1; first = first * 10; last = last * 10 + 9; } return step; } } ","date":"2022-03-23","objectID":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/:4:0","tags":["算法","字典树"],"title":"字典树","uri":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/"},{"categories":["算法"],"content":"参考资料 字典树 (Trie) 数据结构与算法：字典树（前缀树） 一文搞懂字典树 ","date":"2022-03-23","objectID":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/:5:0","tags":["算法","字典树"],"title":"字典树","uri":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/"},{"categories":["算法"],"content":"双指针 算法","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"前言 双指针主要用来在序列中进行遍历，其中常用方式有 快慢指针 、 对撞指针 和 滑动窗口 。可以从将暴力求解的时间复杂度 O(n^2) 降低至 O(n) ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:1:0","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"算法思想 ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:2:0","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"快慢指针 快慢指针 是指两个指针的速度移动不一致。比如一个循环内一个指针移动一位，另一个移动两位，这样在循环结束时，两个指针的移动的距离之比则是固定倍数。 快慢指针 一般用来求序列的中间位置、序列是否成环（进一步也可也求成环的初始位置），例题参考如下 剑指 Offer II 022. 链表中环的入口节点 剑指 Offer II 027. 回文链表 ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:2:1","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"对撞指针 对撞指针 是指两个指针初始在序列的不同端，并且不断的向中心进行寻找 对撞指针 一般用来求解序列两数之 ”和“（广义上指两元素之间关系） 是否满足某一条件，通常该序列一般经过特殊处理过，比如升序排列，也可以对字符串进行翻转。例题参考如下 344. 反转字符串 体积问题转换为左右边界问题，而左右边界问题可以通过对撞指针在时间复杂度为 O(n) 完成，例题参考如下： 盛最多水的容器 42. 接雨水 ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:2:2","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"滑动窗口 滑动窗口 两个指针分别为窗口的左端和右端，并按一定的条件进行有移动。 滑动窗口 按照题目的要求，可以使用固定宽度和动态宽度。该方法一般用来求解连续序列问题。 ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:2:3","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"代码 快慢指针 代码参考如下 public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head; ListNode fast = head; ListNode p = head; while(fast != null){ fast = fast.next; if(fast == null){ return null; } // System.out.println(fast.val); fast = fast.next; if(fast == null){ return null; } slow = slow.next; if(fast == slow){ break; } } while(p != slow){ p = p.next; slow = slow.next; } return p; } } 对撞指针代码参考如下： class Solution { public void reverseString(char[] s) { int i=0; int j=s.length-1; while(i\u003cj){ char tmp = s[i]; s[i] = s[j]; s[j] = tmp; i++; j--; } } } 滑动窗口参考代码如下： class Solution { public int minSubArrayLen(int s, int[] nums) { int n = nums.length; if (n == 0) { return 0; } int ans = Integer.MAX_VALUE; int start = 0, end = 0; int sum = 0; while (end \u003c n) { sum += nums[end]; while (sum \u003e= s) { ans = Math.min(ans, end - start + 1); sum -= nums[start]; start++; } end++; } return ans == Integer.MAX_VALUE ? 0 : ans; } } ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:3:0","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"参考资料 和大于等于 target 的最短子数组 算法一招鲜——双指针问题 ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:4:0","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["Java"],"content":"Java 常用小技巧","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java"],"content":"前言 主要总结一些 java 的基本使用 持续总结中 ing ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:1:0","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java"],"content":"内容 ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:0","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java"],"content":"字符串拼接 字符串的拼接优先使用StringBuilder和StringBuffer类，同时在使用拼接的过程中，尽量使用一个一个的字符串进行 append ，而不是将某些字符串拼接后再 append ，例如 int n = 100; StringBuilder sb = new StringBuilder(); for(int i = 0; i \u003c n; i++){ # sb.append(i + \"#\"); sb.append(i); sb.append(\"#\"); } 不要将 i + \"#\" 拼接好后在 append ，字符串拼接后会产生的新的字符串从而产生更多的开销 ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:1","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java"],"content":"Comparator 类的 compare 方法重写 当需要在某数组某区间进行排序并且需要逆序是，则可以重写 static \u003cT\u003e void sort(T[] a, int fromIndex, int toIndex, Comparator\u003c? super T\u003e c) 方法，该方法返回类型为泛型，所以不能使用基本类型数组进行接受（数组泛型不会自动解包操作），需要使用包装类完成类型接受。 public static void mySort(Integer[] nums, int idx) { Arrays.sort(nums, 0, idx, (a, b) -\u003e Integer.compare(b, a)); } ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:2","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java"],"content":"数组填充 int double long 数组的默认初始化是 0， boolean 数组默认初始化为 false ，类的数组初始化为 null。 若需要对数组全部进行填充时，可以使用Arrays api完成，比如将 int 数组 arr 初始化为 -1。 Arrays.fill(arr, -1) ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:3","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java"],"content":"集合元素添加 当往集合中添加非基本类型元素时，因为非基本类型元素是引用类型，若引用类型发生改变，则集合元素也会发生改变。所以，没有特别要求时，集合添加元素时，需要额外创建一个引用类型进行添加，以区分之前的引用元素。 set.add(new ArrayList\u003c\u003e(list)); 当直接添加引用元素时，引用元素修改，集合元素也发生修改 set.add(list); list.add(12); // set 中的 list 会增加 12 元素 ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:4","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java"],"content":"Arrays.asList 注意事项 将数组转换为 List 时，Arrays.asList 生成的 list 长度是固定的，内容结构不可变更（不可以使用add、remove，但是可以使用 set），但内部数据可以发生变更，且生成的 list 底层结构仍然是数组，是对数组的引用，若生成的 list 数据发生变更，则数组对应的数组也会变更。 当基本类型转换时，需要使用包装类完成。若使用基本类型时，比如 int ，则生成的 list 的类型为 int[] 。因为 Arrays.asList 的实现是通过泛型完成，而基本类型是不可以泛化的，而基本类型的数组是可以泛化的，所以生成的的 list 的类型为基本类型数组。若需要使用基本类型的 list ，则应该使用基本类型对应的包装类数组完成转换，比如 Integer[] 数组。 import java.util.Arrays; import java.util.List; public class Test { public static void main(String[] args){ int[] nums = {1, 2, 3}; List\u003cint[]\u003e list1 = Arrays.asList(nums); Integer[] nums1 = new Integer[]{1,2,3}; List\u003cInteger\u003e list1 = Arrays.asList(nums1); } } 参考：Arrays.asList() 详解 ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:5","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java"],"content":"基本数据类型排序 java 的内部排序默认是快排，数据是从大到小，但当需要从小到大时，需要重写 Comparator 接口方法。但如果是基本数据类型数组，因为基本类型不属于类，所有没有办法利用泛型重写 Comparator 接口方法。解决方法如下： 自己手写一个排序 利用 java8 的流特性进行反转 内部排序之后再逆转 将 int[] 数组转换为 Integer[] 数组，利用包装类进行排序。（不能直接强制类型转换，只能循环复制，利用自动装箱和拆箱机机制） 参考：怎么进行java数组逆序排序？ ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:6","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java"],"content":"HashSet 去重 HashSet 是无序不可重复的集合，线程不安全的，底层基于HashMap，基于hashCode()。判断重复机制首先判断添加的元素的 hashCode() 是否相同，再通过 equals() 方法判断元素是否相等。 当使用 HashSet 去重 Integer[] 等数组元素时，如果每次都是通过 new 添加元素，而Integr[] 数组对象没有重写 hashCode 和 equals 方法，故无法达到去重的效果 HashSet\u003cInteger[]\u003e set = new HashSet\u003c\u003e(); set.add(new Integer[]{1, 2}); set.add(new Integer[]{1,2 }); // 无法去重，因为 new 出来的对象 hashcode 不同，而 equals 方法默认是比较两个对象的地址，故也不同。 而 HashSet 去重 Collection 元素时，即使通过 new 创建一个对象，但 Collection 都已经重写了 hashCode 和 equals 方法，故可以去重。 HashSet\u003cList\u003cInteger\u003e\u003e set = new HashSet\u003c\u003e(); ArrayList\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(1); list.add(2); set.add(new ArrayList\u003c\u003e(list)); set.add(new ArrayList\u003c\u003e(list)); // set size 仍为 1 ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:7","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java"],"content":"StringBuilder 插入 使用 StringBuilder 底层的数据结构为字符数组，所以当执行频繁的插入操作时，尽量使用 append 方法在尾部插入。 Deque\u003cCharacter\u003e stack = new LinkedList\u003c\u003e(); while (!stack.isEmpty()){ sb.append(stack.pollFirst()); // sb.insert(0, stack.pollLast()); } ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:8","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java"],"content":"final 关键字 final 定义的变量是不可以变的量，指的是变量不能更改对象引用，但是引用的对象内容是可以变更的。比如用 final 修饰 list 时，list的内容仍然可以发生变更，但使用 final 修饰基本类型或者包装类时，则变量对应的就是基本数据，不可以发生变更，否则编译异常。 final Integer i = 1; i += 1; // 编译不通过 final ArrayList\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(2); // 编译通过 ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:9","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java"],"content":"toString 在将对象输出时，会自动调用对象的 toString 方法。如果想利用 toString 方法打印对象地址，不能使用 this 来打印对象地址，而需要使用 Object.toString() 方法，即使用 super.toString() ，否则会出现循环调用，因为 this 对象也表示该对象，即对象再次调用自己的 toString 方法。 ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:10","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java"],"content":"数组转 String Arrays.toString 方法是用来将一维数组转换 String。多为数组使用 Arrays.deepToString。 ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:11","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java"],"content":"双浮点数除法精确度 当使用两个浮点数进行除法时，可能会出现结果与预期不一致的问题，其原因是使用浮点数无法正确表示某些小数，所以尽量减少使用浮点数做除法。 double v1 = 0.7; double v2 = 0.025; double result = v1 / v2; System.out.println(result); // 27.999999999999996 而不是预期的 28 ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:12","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java"],"content":"Math.ceil 该方法主要作用是对一个浮点数向上取整。但是如果是对除法结果向上取整时，在 java 中除法的结果已经对结果向下取整了，即结果已经是一个整数，故与预期结果不一致。 int x = 16; int y = 3; int ans =(int) Math.ceil(x / y); System.out.println(ans); // 5 而不是预期的 6 解决办法有三种： 改为浮点数除法，这样结果即为浮点数，在对其向上取整。弊端是存在双浮点数除法存在精度异常问题，需要注意使用 int ans =(int) Math.ceil((double)x / y); System.out.println(ans); // 6 利用模运算，若取余结果不为 0，则对除法结果进一 int ans = x / y + ((x % y) == 0 ? 0 : 1) System.out.println(ans); // 6 利用加法的一些技巧 int ans = (x + y - 1) / y; // 该情况不适用于 y \u003c 0 int ans = (x - 1) / y + 1; // 该情况不适用于 a=0 和 b\u003c1 Java rounding up to an int using Math.ceil ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:13","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java"],"content":"System.arraycopy 和 Arrays.copyOf 二者对数组的拷贝方式都是浅拷贝。调用 list.toArray(T[]) 方法时，当传递的数组大小小于集合长度时，调用 Arrays.copyOf 方法进行拷贝，反之，则调用 System.arraycopy 进行拷贝。Arrays.copyOf 底层仍然是调用 System.copyarray 方法进行拷贝。故集合的 toArray(T[]) 方法也为浅拷贝。 注意集合中的 toArray() 方法也是浅拷贝 ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:14","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java"],"content":"内存存储 使用 new 关键字创建的对象都是存储在堆内存中的，而基本类型都是存储在栈上的，分配和清理堆相对于栈要花费更多的时间，但 java 内部已经进行了足够的优化， ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:15","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java"],"content":"数组 不管使用什么类型的数组，存储的都是堆上对象的引用，因为数组可以显示的通过 new 进行创建，也可也隐式的通过 new 创建。对象数组和基元数组在使用上是完全相同的。唯一的不同之处就是对象数组存储的是对象的引用，而基元数组则直接存储基本数据类型的值。 ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:16","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java"],"content":"局部变量 java 和 C++ 不一样，不支持同名的局部变量，即没有同名变量 ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:17","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["算法"],"content":"Manacher 算法","date":"2022-03-21","objectID":"/posts/manacher-%E7%AE%97%E6%B3%95.html/","tags":["算法","Manacher"],"title":"Manacher 算法","uri":"/posts/manacher-%E7%AE%97%E6%B3%95.html/"},{"categories":["算法"],"content":"前言 检查字符串是否为回文序列，常用方法有 中心扩展 和 Manacher 。前者的时间复杂度为 O(n^2) ，后者算法的时间复杂度为 O(n) ，可以在线性时间的完成回文序列的判断 参考例题 剑指 Offer II 020. 回文子字符串的个数 ","date":"2022-03-21","objectID":"/posts/manacher-%E7%AE%97%E6%B3%95.html/:1:0","tags":["算法","Manacher"],"title":"Manacher 算法","uri":"/posts/manacher-%E7%AE%97%E6%B3%95.html/"},{"categories":["算法"],"content":"算法思想 Manacher 算法的主题思路是利用保存前字符串序列的最大回文半径来减少后续字符串回文与否的判定。 算法过程如下： 先将初始字符串在每个字符间增加一个间隔符号，比如 # （也包括在字符串的开头和字符串的结尾），该步骤主要是为了将偶数回文序列和奇数回文序列合并在一起进行判断。同时在字符串的开头分别加上两个不同的特殊符号，比如开头增加 $ ，结尾增加 ^ ，这两个字符充当哨兵作用 \"abab\" ---\u003e \"$#a#b#a#b$^\" 创建上述字符串的半径数组，从左往右依次计算各序号的半径，同时记录当前的字符串回文的最大右边界 rmax 和对于的序号 maxi，计算过程如下： 当该序号 i 小于等于保存的最大的右边界 rmax 时，则将当前序号的半径初始化为 r = max(rmax - i + 1, 2 * maxi - i) 反之，则直接初始化为 1 再使用 中心扩展法 判断当前半径是否为最大回文序列半径，若不是，则递增继续判断（在上一步骤中，若得到的r + i 小于最大右边界时，则 r即为当前序号的最大半径；若等于最大右边界时，则需要该步骤进行判断） 从上述步骤看，该算法是通过记录当前序号的最大半径 r 和最大右边界 rmax，减少后续序号最大半径的搜索范围，从而将时间复杂度从 O(n^2) 降低至 O(n) 。（中心扩展法 默认都是从半径为 1 依次进行判断），该算法思想与字符串KMP算法思想类似 ","date":"2022-03-21","objectID":"/posts/manacher-%E7%AE%97%E6%B3%95.html/:2:0","tags":["算法","Manacher"],"title":"Manacher 算法","uri":"/posts/manacher-%E7%AE%97%E6%B3%95.html/"},{"categories":["算法"],"content":"代码 class Solution { public int countSubstrings(String s) { int res = 0; StringBuilder sb = new StringBuilder(); sb.append(\"$#\"); for(int i = 0; i \u003c s.length(); i++){ sb.append(s.charAt(i)); sb.append(\"#\"); } sb.append('^'); int[] r = new int[sb.length()]; // 半径数组 r[0] = 1; // 最大右边界 int max = r[0]; // 最大右边界对应的索引位置 int maxi = 0; for(int i = 1; i \u003c r.length - 1; i++){ // 半径初始化 r[i] = i \u003c max ? Math.min(max - i + 1, r[2 * maxi - i]) : 1; // 半径中心扩展 while(sb.charAt(i - r[i]) == sb.charAt(i + r[i])){ r[i]++; } // 最大右边界变更判断 if(i + r[i] - 1 \u003e= max){ max = i + r[i] - 1; maxi = i; } res += r[i] / 2; } return res; } } ","date":"2022-03-21","objectID":"/posts/manacher-%E7%AE%97%E6%B3%95.html/:3:0","tags":["算法","Manacher"],"title":"Manacher 算法","uri":"/posts/manacher-%E7%AE%97%E6%B3%95.html/"},{"categories":["算法"],"content":"参考链接 Manacher 算法 回文子字符串的个数 回文串的学习与应用 最长回文子串 ","date":"2022-03-21","objectID":"/posts/manacher-%E7%AE%97%E6%B3%95.html/:4:0","tags":["算法","Manacher"],"title":"Manacher 算法","uri":"/posts/manacher-%E7%AE%97%E6%B3%95.html/"},{"categories":["算法"],"content":"前缀和的原理和基本应用场景","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"前言 382. 链表随机节点 给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 被选中的概率一样 。 实现 Solution 类： Solution(ListNode head) 使用整数数组初始化对象。 int getRandom() 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。 ","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/:1:0","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"算法思想 以下内容摘自蓄水池抽样算法（Reservoir Sampling） 给定一个数据流，数据流长度N很大，且N直到处理完所有数据之前都不可知，请问如何在只遍历一遍数据（O(N)）的情况下，能够随机选取出m个不重复的数据。 ","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/:2:0","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"原理 第i个接收到的数据最后能够留在蓄水池中的概率=*第i个数据进入过蓄水池的概率***之后第i个数据不被替换的概率（第i+1到第N次处理数据都不会被替换）。 当i\u003c=m时，数据直接放进蓄水池，所以第i个数据进入过蓄水池的概率=1。 当i\u003em时，在[1,i]内选取随机数d，如果d\u003c=m，则使用第i个数据替换蓄水池中第d个数据，因此第i个数据进入过蓄水池的概率=m/i。 当i\u003c=m时，程序从接收到第m+1个数据时开始执行替换操作，第m+1次处理会替换池中数据的为m/(m+1)，会替换掉第i个数据的概率为1/m，则第m+1次处理替换掉第i个数据的概率为(m/(m+1))(1/m)=1/(m+1)，不被替换的概率为1-1/(m+1)=m/(m+1)。依次，第m+2次处理不替换掉第i个数据概率为(m+1)/(m+2)…第N次处理不替换掉第i个数据的概率为(N-1)/N。所以，之后**第i个数据不被替换的概率=m/(m+1)(m+1)/(m+2)…(N-1)/N=m/N**。 当i\u003em时，程序从接收到第i+1个数据时开始有可能替换第i个数据。则参考上述第3点，之后第i个数据不被替换的概率=i/N。 结合第1点和第3点可知，当i\u003c=m时，第i个接收到的数据最后留在蓄水池中的概率=1m/N=m/N。结合第2点和第4点可知，当i\u003em时，第i个接收到的数据留在蓄水池中的概率=m/ii/N=m/N。综上可知，每个数据最后被选中留在蓄水池中的概率为m/N。 ","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/:2:1","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"拓展 假设有K台机器，将大数据集分成K个数据流，每台机器使用单机版蓄水池抽样处理一个数据流，抽样m个数据，并最后记录处理的数据量为N1, N2, …, Nk, …, NK(假设m\u003cNk)。N1+N2+…+NK=N。 取[1, N]一个随机数d，若d\u003cN1，则在第一台机器的蓄水池中等概率不放回地（1/m）选取一个数据；若N1\u003c=d\u003c(N1+N2)，则在第二台机器的蓄水池中等概率不放回地选取一个数据；一次类推，重复m次，则最终从N大数据集中选出m个数据。 验证如下： 第k台机器中的蓄水池数据被选取的概率为m/Nk。 从第k台机器的蓄水池中选取一个数据放进最终蓄水池的概率为Nk/N。 第k台机器蓄水池的一个数据被选中的概率为1/m。（不放回选取时等概率的） 重复m次选取，则每个数据被选中的概率为m*(m/Nk*Nk/N*1/m)=m/N ","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/:3:0","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"代码 382. 链表随机节点 class Solution { ListNode head; Random random; public Solution(ListNode head) { this.head = head; random = new Random(); } public int getRandom() { int i = 1, ans = 0; for (ListNode node = head; node != null; node = node.next) { if (random.nextInt(i) == 0) { // 1/i 的概率选中（替换为答案） ans = node.val; } ++i; } return ans; } } ","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/:4:0","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"其他 398. 随机数索引 因为蓄水池抽样法的概率为等概率时间，通常可以用来等概率采样。等概率采用方法还可以通过 ArrayList 实现，但需要额外而空间复杂度 $O(n)$，而蓄水池采样的空间复杂度为固定常数 $O(1)$ ，可以利用时间复杂度换取空间复杂度。 ","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/:5:0","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"参考链接 蓄水池抽样算法（Reservoir Sampling） 382. 链表随机节点 398. 随机数索引 ","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/:6:0","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"前缀和的原理和基本应用场景","date":"2022-03-18","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/","tags":["算法","前缀和"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/"},{"categories":["算法"],"content":"前言 在算法中，如果需要求一些连续数组成的集合，可以使用前缀和对结果进行存储，从而避免暴力搜索，利用空间复杂度换取时间复杂度 例如leetcode中的 剑指 Offer II 008. 和大于等于 target 的最短子数组 ","date":"2022-03-18","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/:1:0","tags":["算法","前缀和"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/"},{"categories":["算法"],"content":"算法思想 创建一个前缀数组 pre[n] ，其中 pre[i] 表示前 i 个数组所构成的数据结果，例如对于 剑指 Offer II 008. 和大于等于 target 的最短子数组 题目，则可以表示为前 i 个元素和。因为是求连续数组，则可以通过 pre[j] - pre[i] 表示任意第 i 个元素到第 j 个元素的的连续数组，即使用前缀和来减少暴力搜索的时间复杂度，这样算法的时间复杂度为O(N^2)，空间复杂度为 O(N) ","date":"2022-03-18","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/:2:0","tags":["算法","前缀和"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/"},{"categories":["算法"],"content":"再优化 尽管使用了前缀和思想，可以将时间复杂度降至O(N^2)，但在 n足够大时，仍然会出现超时情况。为此，可以根据题目的不同要求，在求前缀和的过程中，使用其他数据结构将所需要的数据进行保存，比如使用 HashMap 。这在后续求解时，可以使用 O(1) 的时间复杂度进行求解，例如在 剑指 Offer II 011. 0 和 1 个数相同的子数组 题目当中，使用 Key 将结果作为索引 ，位置信息作为 Value 进行保存 ","date":"2022-03-18","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/:3:0","tags":["算法","前缀和"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/"},{"categories":["算法"],"content":"代码 剑指 Offer II 008. 和大于等于 target 的最短子数组 示例参考代码如下 class Solution { public int minSubArrayLen(int s, int[] nums) { int n = nums.length; if (n == 0) { return 0; } int ans = Integer.MAX_VALUE; int[] sums = new int[n + 1]; // 为了方便计算，令 size = n + 1 // sums[0] = 0 意味着前 0 个元素的前缀和为 0 // sums[1] = A[0] 前 1 个元素的前缀和为 A[0] // 以此类推 for (int i = 1; i \u003c= n; i++) { sums[i] = sums[i - 1] + nums[i - 1]; } for (int i = 1; i \u003c= n; i++) { int target = s + sums[i - 1]; int bound = Arrays.binarySearch(sums, target); if (bound \u003c 0) { bound = -bound - 1; } if (bound \u003c= n) { ans = Math.min(ans, bound - (i - 1)); } } return ans == Integer.MAX_VALUE ? 0 : ans; } } ","date":"2022-03-18","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/:4:0","tags":["算法","前缀和"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/"},{"categories":["算法"],"content":"参考链接 剑指 Offer II 008. 和大于等于 target 的最短子数组 ","date":"2022-03-18","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/:5:0","tags":["算法","前缀和"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/"},{"categories":["常用软件"],"content":"aria2 的基本安装和使用","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["常用软件"],"content":"前言 最近节点也不知道怎么了，从谷歌云盘下载东西时，经常因为断流而导致下载中断，导致我的大文件几乎就下不下来，网上找了下解决方法，最后选择aria2，一个支持断点续传的软件 aria2 是一个轻量级的多协议和多源命令行下载实用程序。它支持 HTTP/HTTPS、FTP、BitTorrent 和 Metalink。 aria2 可以通过内置的 JSON-RPC 和 XML-RPC 接口进行操作。 ","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/:1:0","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["常用软件"],"content":"安装 aria2 可以在Arch的官方仓库找到 sudo pacman -S aria2 同时 archlinuxcn 源和 AUR 仓库都存在对原版 aria2 补丁的 aria2-fast，原版设置了16线程的上线，该补丁版本最多可以设置为128线程 yay -S aria2-fast ","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/:2:0","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["常用软件"],"content":"配置 aria2 默认配置文件位于 $HOME/.aria2/aria2.conf ，具体配置内容可以参考arch wiki 或者 P3TERX 大佬的 注意：若开启了 session,需要手动创建对应的 aria2.session 文件，否则 daemon 启动不了 ","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/:3:0","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["常用软件"],"content":"设置daemon 一般情况下，aria2 下载完成后便会退出，因此我们可以使用守护单元，在开机后自动在后台保持允许即可 用户级别的 systemd unit 位于 $HOME/.config/systemd/usr 目录下，系统级别的在 /etc/systemd/system 目录下，根据自己情况选择。本教程采用用户级别 编辑对应目下的aria2.service，配置内容如下 [Unit] Description=aria2 Daemon [Service] Type=simple ExecStart=/usr/bin/aria2c --conf-path=${HOME}/.config/aria2/aria2.conf [Install] WantedBy=default.target 接着设置后台自启并立即启动 systemctl enable --user now aria2.service ","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/:4:0","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["常用软件"],"content":"浏览器配置 AriaNG 是较为主流的 aria2 前端，其中有第三方在此基础之上实现的浏览器插件，比如 Chrome和 Firefox 根据配置文件的设置的RPC服务器的密码，在插件中配置好相应的 rpc-secret，同时可以在扩展选项中设置对浏览器的下载进行拦截，统一交给 aria2 服务进行下载 插件设置内容如下图所示 至此，完成了 aria2 的基本设置 ","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/:5:0","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["常用软件"],"content":"参考资料 Archlinux aria2 Aria2 前端面板 ( GUI、WebUI ) AriaNg 使用教程 Arch Linux 的 Aria2 食用指南 ","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/:6:0","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["Linux"],"content":"Archlinux 开机磁盘自动解密","date":"2022-03-08","objectID":"/posts/archlinux-%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%AF%86%E9%85%8D%E7%BD%AE.html/","tags":["archlinux","LUKS"],"title":"Archlinux 自动解密磁盘","uri":"/posts/archlinux-%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%AF%86%E9%85%8D%E7%BD%AE.html/"},{"categories":["Linux"],"content":"前言 由于我的Archlinux使用了LUKS进行磁盘加密，所以在启动系统时，必须输入两次密码，一次是加密磁盘的密码，另一次是用户密码 为了减少每次进入输入系统输入两次密码的麻烦，可以设置开机后自动解锁磁盘 ","date":"2022-03-08","objectID":"/posts/archlinux-%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%AF%86%E9%85%8D%E7%BD%AE.html/:1:0","tags":["archlinux","LUKS"],"title":"Archlinux 自动解密磁盘","uri":"/posts/archlinux-%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%AF%86%E9%85%8D%E7%BD%AE.html/"},{"categories":["Linux"],"content":"加密磁盘 加密磁盘操作具体可以参照Archlinux基础系统安装 ","date":"2022-03-08","objectID":"/posts/archlinux-%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%AF%86%E9%85%8D%E7%BD%AE.html/:2:0","tags":["archlinux","LUKS"],"title":"Archlinux 自动解密磁盘","uri":"/posts/archlinux-%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%AF%86%E9%85%8D%E7%BD%AE.html/"},{"categories":["Linux"],"content":"开机磁盘解密 ","date":"2022-03-08","objectID":"/posts/archlinux-%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%AF%86%E9%85%8D%E7%BD%AE.html/:3:0","tags":["archlinux","LUKS"],"title":"Archlinux 自动解密磁盘","uri":"/posts/archlinux-%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%AF%86%E9%85%8D%E7%BD%AE.html/"},{"categories":["Linux"],"content":"配置开机钩子 开机解密，需要配置开机的钩子(Hook)，根据解密钩子的方式可以分为encrypt hook和sd-encrypt hook，其中后者特性更多，因此采用后者进行解密。编辑/etc/mkinitcpio.conf文件 ，将udev更换为systemd，并添加sd-vconsole和sd-encrypt 修改前 HOOKS=(base udev autodetect keyboard modconf block filesystems fsck) 修改后为 HOOKS=(base systemd autodetect keyboard sd-vconsole modconf block sd-encrypt filesystems fsck) 在FILES=()这一栏中添加开机解密密钥的文件所在的位置 FILES=(/path/to/keyfile) 配置完后，重新生成mkinitcpio配置文件 mkinitcpio -P ","date":"2022-03-08","objectID":"/posts/archlinux-%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%AF%86%E9%85%8D%E7%BD%AE.html/:3:1","tags":["archlinux","LUKS"],"title":"Archlinux 自动解密磁盘","uri":"/posts/archlinux-%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%AF%86%E9%85%8D%E7%BD%AE.html/"},{"categories":["Linux"],"content":"配置内核参数 开机解密磁盘需要告诉内核加密磁盘所在的位置，所以需要配置对应的内核参数，编辑/etc/default/grub文件，在GRUB_CMDLINE_LINUX_DEFAULT或者GRUB_CMDLINE_LINUX参数栏中增加需要添加的内核参数，前者在每次开机都会进行加载，而后者在紧急启动进入系统时则不会加载，所以建议添加在前者栏中 rd.luks.uuid=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX，使用此标志指定要在启动时解密的设备的UUID rd.luks.name=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX=name，指定加密磁盘的UUID和解密后的磁盘名，使用了该内核参数，则可以省略上面的uuid参数 rd.luks.key=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX=/path/to/keyfile，使用keyfile进行系统解密，并传入keyfile的文件位置 rd.luks.options=options，设置解密参数，可选设置。如果是SSD，可以使用discard参数提供TRIM功能 root=/dev/mapper/cryptroot: 指定解密设备，该参数不管是encrypt还是sd-crypt，都必须要设置 其中UUID获取指令如下，获取的是解密前的磁盘UUID，而不是解密后的磁盘UUID lsblk -f └─nvme0n1p2 crypto 2 a0ea985c-f2c0-4c6c-af66-2bc10a158b0a └─cryptroot ext4 1.0 96055a51-9138-431a-8976-845ca1d09e20 上述查询结果中，a0ea985c-f2c0-4c6c-af66-2bc10a158b0a才是我们需要的UUID参数 注意：这和休眠设置的UUID参数不同，休眠需要的是解密后的UUID 如下示例: GRUB_CMDLINE_LINUX_DEFAULT=\"rd.luks.name=a0ea985c-f2c0-4c6c-af66-2bc10a158b0a=cryptroot rd.luks.options=timeout=10s,discard rd.luks.key=a0ea985c-f2c0-4c6c-af66-2bc10a158b0a=/etc/mykeyfile root=/dev/mapper/cryptroot\" 修改后，重新生成grub的配置文件 grub-mkconfig -o /boot/grub/grub.cfg 至此，重启开机便可以自动使用密钥进行解锁，而需要手动输入密码进行解锁磁盘了。 ","date":"2022-03-08","objectID":"/posts/archlinux-%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%AF%86%E9%85%8D%E7%BD%AE.html/:3:2","tags":["archlinux","LUKS"],"title":"Archlinux 自动解密磁盘","uri":"/posts/archlinux-%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%AF%86%E9%85%8D%E7%BD%AE.html/"},{"categories":["Linux"],"content":"参考资料 dm-crypt/System configuration 让系统更安全 - 系统分区加密 (Btrfs on LUKS) 操作实录 ","date":"2022-03-08","objectID":"/posts/archlinux-%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%AF%86%E9%85%8D%E7%BD%AE.html/:4:0","tags":["archlinux","LUKS"],"title":"Archlinux 自动解密磁盘","uri":"/posts/archlinux-%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%AF%86%E9%85%8D%E7%BD%AE.html/"},{"categories":["常用软件"],"content":"Yadm 对 dotfiles 文件的基本使用方法","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"前言 在linux系统下，配置文件一般都是以.符号开头的，因此也被称为 dotfles。github有他人分享的配置，我们可以从中找到适合自己的配置文件 为了方便管理自己系统系统的配置文件，可以使用工具来对这些 dotfiles 进行统一管理。根据 arch wiki，常用的管理方式主要分为两种，软链接和git跟踪点文件，以下是 github 仓库中用的较多的工具 stow: GNU产品，使用软链进行管理，arch的farseerfc大佬就是使用该工具进行管理，具体介绍可以参照他的博客使用GNU stow 管理你的点文件 git bare: 使用git bare裸仓库进行管理 yadm: Yet Another Dotfiles Manager，一个git的wrapper，底层仍然是使用git来进行管理，方法使用和git没有区别，可以对特定文件加密 chezmoi: 和git用法差不多，但是会将需要跟踪的点文件冗余存储在chezmoi特定的本地仓库，可以对特定文件加密 为了保持和 git 的使用习惯，最后选择yadm作为点文件的管理工具，yadm默认相对位置为自己的家目录($HOME) ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:1:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"安装 Archlinux sudo pacman -S yadm Ubuntu/Debian sudo apt install -y yadm OSX brew install yadm ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:2:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"仓库初始化 ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:3:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"初始化本地仓库 如果一开始没有远程的 dotfiles 仓库，则需要先初始化本地仓库 yadm init yadm add \u003cimportant file\u003e yadm commit 再将本地仓库与远程仓库进行同步 yadm remote add origin \u003curl\u003e yadm push -u origin main ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:3:1","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"同步远程仓库 若一开始就有远程仓库，或使用他人的 yadm 的远程仓库时，则将远程仓库克隆下来即可 yadm clone \u003curl\u003e yadm status ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:3:2","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"基本使用 ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:4:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"添加需要跟踪的配置文件 使用 add 方法，将 dotfile 添加至 yadm 跟踪 list 当中 yadm add /path/to/dotfile ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:4:1","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"跟踪列表查看 使用 list 方法，查看当前路径下的跟踪文件，使用 -a 参数(Optional)，可以查看所有跟踪文件 yadm list \u003c-a\u003e ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:4:2","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"推送至远程仓库 使用commit和push方法，将变化文件推送至远程仓库 git commit -m \"commit word\" git push -u origin main ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:4:3","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"文件加密和解密 在$HOME/.config/yadm/encrypt文件中设置需要加密的文件，支持正则表达式，默认文件的起始地址为%HOME目录下，$HOME/.config/yadm/encrypt参考格式如下 .ssh/*.key yadm支持gpg的对称加密和非对称加密，默认加密方式为gpg的对称加密，加密后的文件存储于 $HOME/.local/share/yadm/archive 文件当中， yadm add $HOME/.config/yadm/encrypt yadm add $HOME/.local/share/yadm/archive 也可以通过 yadm config yadm.gpg-recipient \u003crecipient-address\u003e 指令指定使用非对称加密 yadm config yadm.gpg-recipient \u003crecipient-address\u003e chezmoi 不同的是，yadm 需要将文件手动进行解密，若使用对称加密，则按提示输入密码既可进行解密 注：系统没有 gunpg 则，则无法解密 yadm decrypt ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:5:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"引导程序 yadm 支持在初始化仓库时，自动调用 Bootstrap 程序执行初始化，该文件默认位置为$HOME/.config/yadm/bootstrap，且该文件必须为可执行程序 在初始化时，如果系统本身就含有 yadm 仓库对应的点文件时，yadm 默认是不会处理该文件，即不会覆盖，需要用户自己手动处理该冲突，对于引导程序，除了初始化执行时，也可以手动执行引导程序，来进行引导程序的调试 yadm bootstrap ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:6:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"参考资料 Archlinux Dotfiles Yet Another Dotfiles Manager 使用Yadm来管理我的配置 使用GNU stow 管理你的点文件 ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:7:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"Clash 在 linux 下的的基本安装和使用","date":"2022-03-07","objectID":"/posts/clash-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html/","tags":["Clash"],"title":"Clash 安装与使用","uri":"/posts/clash-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"前言 Clash 是一个跨平台、支持 SS/V2ray 等协议、基于规则的网络代理软件 Clash 只是一个内核，为开源软件，而 Clash-premium 是闭源软件，后者多了scripts，rule-set和tun(windows只能使用该功能实现全局代理) 从clash的内核衍生了众多版本，用的最多的有 Clash for windows (简称 cfw )，Open Clash，Clashx。其中cfw不仅支持windows，还支持macos和linux，open Clash只支持路由器的openwrt系统，Clashx只支持macos ","date":"2022-03-07","objectID":"/posts/clash-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html/:1:0","tags":["Clash"],"title":"Clash 安装与使用","uri":"/posts/clash-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"安装 在 arch 的官方仓库当中有根据 clash 内核打包好的组件，aur社区有打包好的 cfw 和 clash-user。其中cfw有ui界面，与 windows 上设置没有什么区别，而 clash-user 自带 clash 用户，可以根据用户的 uid 来设置防止流量回环 由于 linux 可以使用 tproxy 实现全局代理，可以直接使用官方仓库的 clash (或者 aur 的 clash-user ），来减少 clash 的资源占用( cfw 的 gui 需要占用资源) sudo pacman -S clash 使用yacd面板对Clash管理和流量监控 yay -S yacd ","date":"2022-03-07","objectID":"/posts/clash-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html/:2:0","tags":["Clash"],"title":"Clash 安装与使用","uri":"/posts/clash-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"文件配置 clash 默认的配置文件位于用户目录下，而 clash-user 的配置位于/etc/clash目录下 配置中主要参数解释： port: http(s)代理端口 socks-port: socks5代理端口 redir-port: redir tcp代理端口 tproxy-port: tproxy udp(tcp)代理端口 mode: 代理方式，有全局代理(gloable)、规则代理(rule)和直连(direct)。其rle根据配置所提供的规则流量代理 external-controller: clash提供的api控制地址 external-ui: 外部控制ui地址 profile: clash部分存储设置模块 store-selected: 策略组节点选择后，是否需要存储选择记录，默认不存储(false) store-fake-ip: 设置为 true 是，将 fake-ip 与真实 dns 的 ip 对应记录存储在本地，以达到持久存储 dns 记录，加快 dns 解析速度 dns: clash的dns模块 enable: 设置为 true 时开启 clash 内置的dns模块 listen: dns 的监听端口 enhanced-mode: clash 提供两种 dns 查询模式，一种为正常 redir 转发模式，另一种为 fake-ip 模式，每次应用 dns 请求时，clash 将返回一个 fake 的 ip 地址，来达到加速建立 tcp 连接需求，但也会导致得到的 ip 不是真实的 ip，从而对某些网络调试带来麻烦 nameserver: dns 查询服务器，可以设置为 doh，tls 等dns查询方式。具体可以根根据个人习惯设置 fake-ip-filter: 过滤不使用 fake-ip 查来询dns的地址 proxies: 代理节点设置模块，请根据官方要求进行设置 proxy-groups: clash 的策略组，与 surge 类似。包含 relay(轮询)，url-test(ping最低优先)，load-balance(负载均衡)，fallback(按节点顺序优先使用可用节点)，select(手动选择节点) proxy-providers: 节点提供模块，一次可以提供多个级诶但，clash的1.9.0中增加了filter用来过滤节点 type: 节点组提供的类型，可选 http (远程提供)和 file (本地文件提供) filter: 节点过滤方式，支持正则 rules: 规则模块，以下是官方提供的说明，可以根据需要进行规则设置 DOMAIN: 规则会匹配与请求完全相同的地址 DOMAIN-SUFFIX: 规则会匹配与请求与主域名相同的地址，比如，google.com匹配www.google.com, mail.google.com和google.com本身，但不会匹配content-google.com DOMAIN-KEYWORD: 规则会匹配包含相应关键字的域名，除了 “apple” 会匹配 www.apple.com，“app” 同样也会匹配到 GEOIP: 规则会匹配相应国家和地区的 IP 地址 IP-CIDR: 规则会匹配规则范围内请求的 IP 地址 IP-CIDR6: 规则会匹配规则范围内请求的 IPv6 地址 SRC-IP-CIDR: 规则会匹配源 IP 地址 SRC-PORT: 规则会匹配源端口地址 DST-PORT: 规则会匹配目的地端口地址 PROCESS-NAME: 规则会匹配这个进程名的程序 MATCH: 将其余数据包路由到策略。此规则是必需的 以下为本人根据 clash 提供的官方配置进行更改的自用配置。dns 设置为 fake-ip 模式，dns 服务器均采用 doh，防止国内而 dns 污染，并使用 yacd 模块。因为 clash 开源版不支持rule-set模块(clash-premium支持)，所以不能像 surge 一样简洁书写规则，嫌规则冗长的可以使用 clash-premium 闭源软件书写，其他模块书写规则一致 mixed-port: 7890 allow-lan: true mode: Rule log-level: warning external-controller: 127.0.0.1:9090 socks-port: 7891 redir-port: 7892 tproxy-port: 7893 ipv6: false external-ui: '/usr/share/yacd' profile: store-selected: false store-fake-ip: true dns: enable: true listen: 0.0.0.0:1053 enhanced-mode: fake-ip fake-ip-range: 198.18.0.1/16 nameserver: - https://223.5.5.5/dns-query - https://doh.pub/dns-query #- 114.114.114.114 #- 223.5.5.5 fallback: - https://1.1.1.1/dns-query - https://1.0.0.1/dns-query - https://8.8.8.8/dns-query fallback-filter: geoip: true geoip-code: CN fake-ip-filter: - '*.lan' - '*.localhost' - '*.local' - 'lens.l.google.com' - 'stun.l.google.com' - '*.gitbook.io' proxy-providers: HK_LOW: type: file path: ./cordcloud.yaml interval: 3600 filter: '长沙联通转香港|广东移动转香港' health-check: enable: true url: http://wifi.vivo.com.cn/generate_204 interval: 600 HK: type: file path: ./cordcloud.yaml interval: 3600 filter: '深港专线' health-check: enable: true url: http://wifi.vivo.com.cn/generate_204 interval: 600 TW: type: file path: ./cordcloud.yaml interval: 3600 filter: '台湾' health-check: enable: true url: http://wifi.vivo.com.cn/generate_204 interval: 600 JP: type: file path: ./cordcloud.yaml interval: 3600 filter: '日本' health-check: enable: true url: http://wifi.vivo.com.cn/generate_204 interval: 600 SG: type: file path: ./cordcloud.yaml interval: 3600 filter: '新加坡' health-check: enable: true url: http://wifi.vivo.com.cn/generate_204 interval: 600 US: type: file path: ./cordcloud.yaml interval: 3600 filter: '美国' health-check: enable: true url: http://wifi.vivo.com.cn/generate_204 interval: 600 proxy-groups: - name: Final type: select proxies: - Proxies - DIRECT - name: Proxies type: select proxies: - load_balance - hk_urltest - tw_urltest - sg_urltest - us_urltest - name: StreamSE type: select proxies: - load_balance - hk_urltest - tw_urltest - sg_urltest - us_urltest - name: Google type: select proxies: - hk_fallback - hk_urltest - tw_urltest - sg_urltest - Proxies - name: Telegram type: select proxies: - sg_urltest - hk_urltest - tw_urltest - Proxies - name: load_balance type: load-balance url: http://wifi.vivo.com.cn/generate_204 interval: 300 proxies: use: - HK_LOW - name: hk_urltest type: url-test url: http://wifi.vivo.com.cn/","date":"2022-03-07","objectID":"/posts/clash-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html/:3:0","tags":["Clash"],"title":"Clash 安装与使用","uri":"/posts/clash-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"TProxy代理设置 采用clash官方推荐的wiki的防火墙设置，来拦截流量，由于udp不支持redir，所以tcp采用redir，udp采用tproxy(也都可以采用tproxy)，dns拦截端口为上述文件设置的1053，将dns的udp查询均转发至1053端口 为了防止clash代理自身流量，有两种常用方式避免流量回环，cgroup和uid。第一种方式将clash加入特定cgroup足，比如自定义的noproxy组，第二种方式为使用clash用户来启动clash进程。接着使用iptables来匹配对于流量 官方推荐wiki的iptables规则如下 #tcp iptables -t nat -N clash iptables -t nat -A clash -d 0.0.0.0/8 -j RETURN iptables -t nat -A clash -d 10.0.0.0/8 -j RETURN iptables -t nat -A clash -d 127.0.0.0/8 -j RETURN iptables -t nat -A clash -d 169.254.0.0/16 -j RETURN iptables -t nat -A clash -d 172.16.0.0/12 -j RETURN iptables -t nat -A clash -d 192.168.0.0/16 -j RETURN iptables -t nat -A clash -d 224.0.0.0/4 -j RETURN iptables -t nat -A clash -d 240.0.0.0/4 -j RETURN iptables -t nat -A clash -p tcp -j REDIRECT --to-port 7892 iptables -t nat -I PREROUTING -p tcp -d 8.8.8.8 -j REDIRECT --to-port 7892 iptables -t nat -I PREROUTING -p tcp -d 8.8.4.4 -j REDIRECT --to-port 7892 iptables -t nat -A PREROUTING -p tcp -j clash iptables -t nat -A OUTPUT -p tcp -d 198.18.0.0/16 -j REDIRECT --to-port 7892 #udp ip rule add fwmark 1 table 100 ip route add local default dev lo table 100 iptables -t mangle -N clash iptables -t mangle -A clash -d 0.0.0.0/8 -j RETURN iptables -t mangle -A clash -d 10.0.0.0/8 -j RETURN iptables -t mangle -A clash -d 127.0.0.0/8 -j RETURN iptables -t mangle -A clash -d 169.254.0.0/16 -j RETURN iptables -t mangle -A clash -d 172.16.0.0/12 -j RETURN iptables -t mangle -A clash -d 192.168.0.0/16 -j RETURN iptables -t mangle -A clash -d 224.0.0.0/4 -j RETURN iptables -t mangle -A clash -d 240.0.0.0/4 -j RETURN iptables -t mangle -A clash -p udp -j TPROXY --on-port 7893 --tproxy-mark 1 iptables -t mangle -A OUTPUT -p udp -d 198.18.0.0/16 -j MARK --set-mark 1 iptables -t mangle -A PREROUTING -p udp -j clash iptables -t nat -N CLASH_DNS iptables -t nat -F CLASH_DNS iptables -t nat -A CLASH_DNS -p udp -j REDIRECT --to-port 1053 iptables -t nat -I OUTPUT -p udp --dport 53 -j CLASH_DNS iptables -t nat -I PREROUTING -p udp --dport 53 -j REDIRECT --to 1053 # 以下二选一 # 使用noproxy的cgroup组来防止流量回环 iptables -t mangle -A OUTPUT -m cgroup --path \"noproxy.slice\" -j RETURN # 使用uid来防止流量回环 # iptables -t mangle -A clash-self -m owner --uid-owner clash -j RETURN ","date":"2022-03-07","objectID":"/posts/clash-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html/:4:0","tags":["Clash"],"title":"Clash 安装与使用","uri":"/posts/clash-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"iptables规则持久化 iptables 规则在每次系统重启后，都会进行复原，因此如果设置错误导致无法上网时，可以删除防火墙对应规则或直接重启电脑解决 为了让iptables规则持久化，可以设置一个开机自启服务，自动运行对应脚本以设置防火墙。将上述 iptables 规则保存为为 iptables.sh ，并创建 /etc/systemd/system/tproxy.service，编辑设置内容如下 [Unit] Description=Setup ip-rule and ip-route for tproxy local network traffic. Before=network-pre.target Wants=network-pre.target [Service] Type=oneshot ExecStart=/bin/bash /path/to/iptables.sh RemainAfterExit=yes [Install] WantedBy=multi-user.target 设置服务开机自启 sudo systemctl enable tproxy.service ","date":"2022-03-07","objectID":"/posts/clash-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html/:5:0","tags":["Clash"],"title":"Clash 安装与使用","uri":"/posts/clash-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"启动服务 clash 需要部分网络代理能力，编辑 clash@ 服务文件，添加 clash 的 capability 能力， sudo systemctl edit clash@.service 添加如下内容 CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW 让应用可以处理 TProxy 带来的流量 CAP_NET_BIND_SERVICE 允许应用绑定 1000 以下的端口 如果采用 cgroup 防止流量回环，还需要设置该服务所对应的 Slice，采用 UID 识别的话，则需要设置该服务的启动 USER，二选一即可，也可以同时都设置。若设置 UID 时，必须保证系统存在相应用户名 # cgroup Slice = noproxy.slice # UID User = username 同时设置 clash@$USER 服务后台自动，并立即启动 sudo systemctl enable --now clash@$USER.service ","date":"2022-03-07","objectID":"/posts/clash-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html/:6:0","tags":["Clash"],"title":"Clash 安装与使用","uri":"/posts/clash-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"docker流量问题解决 为了解决 cgproxy 代理 bridge 联网的 docker 无法联网问题，需要进行如下而外设置 sysctl -w net.bridge.bridge-nf-call-iptables=0 sysctl -w net.bridge.bridge-nf-call-ip6tables=0 sysctl -w net.bridge.bridge-nf-call-arptables=0 ","date":"2022-03-07","objectID":"/posts/clash-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html/:7:0","tags":["Clash"],"title":"Clash 安装与使用","uri":"/posts/clash-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"参考资料 Clash github Wik Unofficial Clash Wiki clash-win-docs-new 容器(docker)桥接(bridge)模式时的代理问题 如何使用 Clash 的 TPROXY 功能进行透明代理 ","date":"2022-03-07","objectID":"/posts/clash-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html/:8:0","tags":["Clash"],"title":"Clash 安装与使用","uri":"/posts/clash-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html/"},{"categories":["Linux"],"content":"Archlinux 的KDE桌面系统安装","date":"2022-03-07","objectID":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/","tags":["archlinux"],"title":"Archlinux 桌面系统安装","uri":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"前言 作为主力系统，自然需要桌面系统(DE)。主流DE有KDE和GNOME等，根据个人习惯选择系统。本文主要介绍KDE桌面系统的安装 ","date":"2022-03-07","objectID":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/:1:0","tags":["archlinux"],"title":"Archlinux 桌面系统安装","uri":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"联网 由于桌面系统还没有安装完成，所以采用iwd和dhcpcd进行网络连接，首先启动iwd和dhcpcd，在使用iwd连接无限网络。iwd参照基础系统安装教程 systemctl start iwd systemctl start dhcpcd ","date":"2022-03-07","objectID":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/:2:0","tags":["archlinux"],"title":"Archlinux 桌面系统安装","uri":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"准备普通用户 由于桌面系统需要普通用户，故先添加普通用户，并配置相应的权限 useradd -m -G wheel -s /bin/bash username passwd username 配置sudo权限 EDITOR=vim visudo 找到下面该行，并取消注释 #%wheel ALL=(ALL) ALL ","date":"2022-03-07","objectID":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/:3:0","tags":["archlinux"],"title":"Archlinux 桌面系统安装","uri":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"安装KDE环境 KDE安装有三个包组，plasma-meta、plasma和plasma-desktop。其中plasma和plasma-meta区别为，kde后续增加软件包时，plasma-meta会自动安装，而plasma不会，剩下plasma-desktop只有kde能跑起来最少的软件。推荐使用plasma-meta，防止后续缺少组件。konsole和dolphin分别为kde的常用终端和文件管理 pacman -S plasma-meta konsole dolphin ","date":"2022-03-07","objectID":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/:4:0","tags":["archlinux"],"title":"Archlinux 桌面系统安装","uri":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"启用DM kde默认自带sddm，可以根据需要更换 systemctl enable sddm ","date":"2022-03-07","objectID":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/:5:0","tags":["archlinux"],"title":"Archlinux 桌面系统安装","uri":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"启用网络管理组件 kde和gnome桌面系统一般采用NetworkManager进行网络管理 systemctl enable NetworkManager ","date":"2022-03-07","objectID":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/:6:0","tags":["archlinux"],"title":"Archlinux 桌面系统安装","uri":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"重启进入桌面系统 自此，基本的桌面系统已经安装完成，可以重启进入桌面系统 reboot ","date":"2022-03-07","objectID":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/:7:0","tags":["archlinux"],"title":"Archlinux 桌面系统安装","uri":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"AUR Helper安装 yay和paru是较为常用的aur helper组件，根据个人习惯进行选择 注：由于安装需要从github拉取文件，需要配置代理才可以进行 git clone https://aur.archlinux.org/yay.git cd yay makepkg -si ","date":"2022-03-07","objectID":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/:8:0","tags":["archlinux"],"title":"Archlinux 桌面系统安装","uri":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"输入法安装 facitx5为社区推荐输入法，安装facitx5 sudo pacman -S fcitx5-im sudo pacman -S fcitx5-chinese-addons fcitx5-pinyin-zhwiki fcitx5-material-colo 配置环境，konsole和dolphin需要环境变量的支持才可以使用输入法，使用EDITOR=vim sudoedit /etc/environment进行添加环境变量 GTK_IM_MODULE=fcitx QT_IM_MODULE=fcitx XMODIFIERS=@im=fcitx SDL_IM_MODULE=fcitx ","date":"2022-03-07","objectID":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/:9:0","tags":["archlinux"],"title":"Archlinux 桌面系统安装","uri":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"配置默认编辑器 arch默认编辑器为vi，一般使用vim，使用EDITOR=vim sudoedit /etc/profile配置环境变量 export EDITOR='vim' ","date":"2022-03-07","objectID":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/:10:0","tags":["archlinux"],"title":"Archlinux 桌面系统安装","uri":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"蓝牙配置 安装并配置蓝牙 sudo pacman -S bluez bluez-utils pulseaudio-bluetooth pavucontrol pulseaudio-alsa yay -S bluez-firmware sudo systemctl enable bluetooth.service sudo systemctl start bluetooth.service pulseaudio -k pulseaudio --start sudo usermod -a -G lp $USER 设置蓝牙自启，编辑/etc/bluetooth/main.conf文件，更改AutoEnable的值为true sudo vim /etc/bluetooth/main.conf ","date":"2022-03-07","objectID":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/:11:0","tags":["archlinux"],"title":"Archlinux 桌面系统安装","uri":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"KDE安装完成 自此，arch的KDE系统基本完成安装。 KDE是可以根据自己的需要进行高度定制化，可以根据自己的需要进行定制化 ","date":"2022-03-07","objectID":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/:12:0","tags":["archlinux"],"title":"Archlinux 桌面系统安装","uri":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"参考资料 Archlinux Installation guide Arch Linux 安装使用教程 - ArchTutorial - Arch Linux Studio 2021 Archlinux双系统安装教程（超详细） Arch Linux Monthly Install: January 2022 ","date":"2022-03-07","objectID":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/:13:0","tags":["archlinux"],"title":"Archlinux 桌面系统安装","uri":"/posts/archlinux-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"Archlinux 的基本安装","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"前言 第一次使用linux系统，查询linux各个版本的区别，最后看上了arch的aur，故选择arch作为主力linux系统(人的生命在于折腾，折腾就完事了) 这篇主要记录了基本系统的安装，不包含桌面系统 ","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/:1:0","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"EFI模式验证 首先确认安装模式是否为EFI模式 ls /sys/firmware/efi/efivars ","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/:2:0","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"系统时钟校正 timedatectl set-ntp true ","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/:3:0","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"进行网络连接 arch系统网络连接方式主要有两种，有线连接和无线连接 ","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/:4:0","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"有线连接 可以使用手机线与电脑进行连接，进行网络共享 ","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/:4:1","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"无线连接 arch live系统默认为开启iwd,使用iwd进行无线网络连接 iwctl device list station wlan0 get-networks station waln0 connect WIFI-NAME 首先进入iwctl模式，查询当前设备无线网卡设备名,比如wlan0），再使用网卡查询当前wifi网络情况，最后对目标WIFI-NAME进行连接，提示输入密码进行确认 ","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/:4:2","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"数据分区及格式化 ","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/:5:0","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"分区 常见分区工具有cfdisk,gdisk等。为了方便，可以使用GUI的cfdisk进行分区 为了防止某些异常，优先对efi进行分区，大小500M～1G即可 剩下分区方式根据个人习惯进行。 比以将home分区单独分区，缺点是home分区和其他分区大小需要控制好，防止某分区空间爆满而需要对文件系统挪动， 将剩余分区大小划分为一个分区，缺点是重装系统麻烦 为了节省存储空间，故采用第二种方式。分区完成后，对主分区进行加密(Optional) ","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/:5:1","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"加密(可选) 为了保证自己的数据安全，可以对主要分区内容进行加密，防止他人挂载直接进入系统读取文件。 使用LUKS对主分区进行加密，没有特殊要求采用默认参数即可 默认使用手动输入密码对文件进行加密 cryptsetup -y -v luksFormat /path/to/device 使用keyfile对文件进行加密 首先生成所需要的keyfile文件，根据生成keyfile文件的类型不同，可以分为密码方式和随机字符或二进制。 为了简便，采用密码对文件进行加密，并将密码制作为keyfile,用作开机自动解密。 echo -n 'your_passphrase' \u003e /etc/keyfile chown root:root /etc/keyfile; chmod 400 /etc/keyfile 解密分区 cryptroot 为解密后对应的文件名，可以自定义 cryptsetup open /path/to/device/ cryptroot ","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/:5:2","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"格式化 efi分区采用mkfs.fat进行格式化。主分区根据不同的文件类型特性进行选择格式化，比如mkfs.ext4格式化为ext4,mkfs.btrfs格式化为btrfs，其中ext4速度整体快于btrfs,而btrfs存在快照等特性。 mkfs.fat -F 32 /path/to/efi mkfs.ext4 /path/to/device ","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/:5:3","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"挂载分区，并安装基本软件 先挂载/mnt分区，在创建/mnt/boot分区，并挂载(也可以创建/mnt/efi分区并进行挂载，二者不同之处可以查看archwiki) mount /dev/mapper/cryptroot /mnt mount /path/to/efi /mnt/boot 其中cryptroot为解密后分区所对应的名字，挂载时需要选择解密后的分区名 使用pacstarp在/mnt分区中安装基本软件，并生成分区文件，最后进入安装系统(根据电脑CPU类型安装所需要的微码，intel的cpu安装intel-ucode，amd的安装amd-ucode) pacstarp /mnt base base-devel linux linux-headers linux-firmware sudo amd-ucode genfstab -U /mnt \u003e\u003e /mnt/etc/fstab arch-chroot /mnt ","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/:6:0","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"更改镜像源并启用32位库 由于国外镜像站网速限制，可以使用国内教育镜像站进行加速，镜像配置文件为/etc/pacman.d/mirrorlist，可以设置多个镜像站 Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch 由于部分软件需要32位库，比如wine,而默认32位库是注释掉了，需要取消注释才能启用，不需要32位软件的可以不进行该操作。pacman的默认库文件位/etc/pacman.conf，取消注释multilib库 [multilib] Server = /etc/pacman.d/mirrorlist ","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/:7:0","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"修改密码 修改root的密码 passwd ","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/:8:0","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"基础软件安装 安装基础软件，比如网络，编辑器等 pacman -S networkmanager vim git wget curl dhcpcd iwd bash-completion dialog wpa_supplicant ","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/:9:0","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"时区和区域设置 使用软链设置时区，比如设置位亚洲的上海时区，并同步 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc 区域设置，对应文件位/etc/locale.gen，编辑并取消所需要的区域设置，并生成对应文件 vim /etc/locale.gen # 取消en_US.UTF-8和zh_CN.UTF-8的注销 locale-gen 向/etc/locale.conf导入本地语言设置，防止乱码 echo 'LANG=en_US.UTF-8' \u003e /etc/locale.conf ","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/:10:0","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"主机名设置 编辑/etc/hostname，设置主机名，比如arch，并根据主机名设置host文件 echo arch \u003e /etc/hostname cat \u003e /etc/hosts \u003c\u003cEOF 127.0.0.1 localhost ::1 localhost 127.0.1.1 arch.localdomain arch EOF ","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/:11:0","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"安装引导文件 引导文件有grub和system-boot，system-boot需要手动写入启动文件，grub指令可以直接生成，较为方便，故采用grub(若efi分区挂载为/mnt/efi，则将efi-directory更改为/efi) pacman -S grub efibootmgr grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB grub-mkconfig -o /boot/grub/grub.cfg ","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/:12:0","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"解密参数配置(可选) 如果对磁盘设置了加密，必须设置一些hook和内核参数来告诉内核加密磁盘的位置 具体操作可以参见Archlinux自动解密磁盘 ","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/:13:0","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"完成安装 基本系统已经完成安装，退出系统，并取消文件挂载，重启既可以进入安装好的系统 exit umount -a reboot ","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/:14:0","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"参考资料 Archlinux Installation guide dm-crypt/Encrypting an entire system Arch Linux 安装使用教程 - ArchTutorial - Arch Linux Studio Arch Linux 搭建 java 开发环境 2021 Archlinux双系统安装教程（超详细） Arch Linux Monthly Install: January 2022 ","date":"2022-03-07","objectID":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/:15:0","tags":["archlinux"],"title":"Archlinux 的基础系统安装流程","uri":"/posts/archlinux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85.html/"},{"categories":null,"content":"游戏规则 点击小圆点，围住小猫。 你点击一次，小猫走一次。 直到你把小猫围住（赢），或者小猫走到边界并逃跑（输）。 ","date":"0001-01-01","objectID":"/catch-the-cat/:1:0","tags":null,"title":"逮住那只猫!","uri":"/catch-the-cat/"}]