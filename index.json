[{"categories":["Java Spring"],"content":"前言 AOP 全称为 Aspect Oriented Programming，即面向切片编程。与 OOP (Object Oriented Programming) 面向对象编程不同的是，AOP将系统看作为多个对象的交互，通过切面，对系统的不同关注点，切分为多个平面，利用 AOP ，可以更好的对过往代码进行复用。 ","date":"2022-04-05","objectID":"/posts/spring-aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:1:0","tags":["AOP"],"title":"Spring AOP学习笔记","uri":"/posts/spring-aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"AOP基础 ","date":"2022-04-05","objectID":"/posts/spring-aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:0","tags":["AOP"],"title":"Spring AOP学习笔记","uri":"/posts/spring-aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"术语 AOP 的基本用语： Target：目标类，需要代理的类 JointPoint：连接点，被代理的对象中需要增强的点，比如方法 PointCut：切入点，已经被增强的连接点 Advice：通知，代理对象执行到 连接点所需要执行的操作 Weaver：植入，把通知应用到代理对象当中的过程 Proxy ：代理类，动态代理 ","date":"2022-04-05","objectID":"/posts/spring-aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:1","tags":["AOP"],"title":"Spring AOP学习笔记","uri":"/posts/spring-aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"实现方式 AOP 的底层采用代理机制方式实现。AOP 功能实现方式主要有三种 手动实现。使用 jdk 或者 cglib 动态代理实现 使用 Spring AOP api 实现。该方法需要手动实现 AOP 的接口，并对指定方法进行增加 使用 aspectj 实现。常用方式，实现过程如下 导入 aspectjweaver 包，在 application.xml 中引入 aop 的头文件（后续可以使用配置类完成） \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!-- bean definitions here --\u003e \u003c/beans\u003e 配置切入面、切入点和通知 \u003caop:config\u003e \u003c!-- --\u003e \u003caop:aspect ref=\"myAspect\"\u003e \u003caop:pointcut id=\"mypointcut\" expression=\"execution(public boolean com.cskaoyan.dao.impl.UserServiceImpl.register(String,String))\"/\u003e \u003caop:pointcut id=\"mypointcut2\" expression=\"execution(* com..impl..*(..))\"/\u003e \u003caop:before method=\"before13\" pointcut-ref=\"mypointcut2\"/\u003e \u003caop:around method=\"myAround\" pointcut-ref=\"mypointcut2\"/\u003e \u003caop:after method=\"myAfter\" pointcut-ref=\"mypointcut2\"/\u003e \u003caop:after-throwing method=\"myAfterThrowing\" pointcut-ref=\"mypointcut2\" throwing=\"myThrowable\"/\u003e \u003caop:after-returning method=\"myAfterReturning\" pointcut-ref=\"mypointcut2\" returning=\"myReturnResult\"/\u003e \u003c/aop:aspect\u003e \u003c!-- \u003caop:aspect ref=\"myAspect2\"\u003e \u003caop:before method=\"before13\" pointcut-ref=\"mypointcut\"/\u003e \u003c/aop:aspect\u003e --\u003e \u003c/aop:config\u003e ","date":"2022-04-05","objectID":"/posts/spring-aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:2","tags":["AOP"],"title":"Spring AOP学习笔记","uri":"/posts/spring-aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"AspectJ 基于 AOP 框架，Spring2.0 之后支持了基于 AspectJ 的切入点表达式，可以在不改动原代码的的前提下，自定义开发，植入代码。 AspectJ 流程图 语法：execution（修饰符 返回值 包 类 方法名(参数类型) throws 异常 ，其中修饰符一般省略，修饰符可以使用 * 表示任意; 返回值不可以省略，但是可以使用 * 表示任意，若是非 java.lang 下的类型，需要写全类名; 方法不可以省略，可以使用 * 表示任意; 参数可以使用 (..) 表示参数任意; throws 异常可以省略。 通知类型： Before ： 在切入点之前执行。 参数类型的校验。 前置通知 AtterReturning ： 周在切入点之后执行。后置通知，可以对结果进行检查，增加log Around ：环绕通知 在切入点之前和之后都会执行。增加事务等等。 AfterThrowing ： 抛出异常的时候执行通知。正常情况下走不到。只有发生异常的情况下才会去通知，比如记录一些日志。 After ： 在finally语句里。不管切入点是否有异常发生都会执行。 实现方式： 在配置文件 xml 中书写 \u003caop:before method=\"MyBefore\" pointcut-ref=\"myPointCut\"/\u003e \u003caop:after-returning method=\"MyAfterReturning\" pointcut-ref=\"myPointCut\"/\u003e \u003caop:around method=\"MyAround\" pointcut-ref=\"myPointCut\"/\u003e \u003caop:afterthrowing method=\"MyAfterThrowing\" pointcut-ref=\"myPointCut\"/\u003e \u003caop:after method=\"MyAfter\" pointcut-ref=\"myPointCut\"/\u003e 使用注解实现 @Before(\"execution(public java.utils.list.com..*.addUser(..))\") @AfterReturning(value = \"execution(public java.utils.list.com..*.addUser(..))\"\", returning = \"res) @Around(\"execution(public java.utils.list.com..*.addUser(..))\") @AfterThrowing(value = \"execution(public java.utils.list.com..*.addUser(..))\", throwing = \"exception\") @After(\"execution(public java.utils.list.com..*.addUser(..))\") ","date":"2022-04-05","objectID":"/posts/spring-aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:0","tags":["AOP"],"title":"Spring AOP学习笔记","uri":"/posts/spring-aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["算法"],"content":"前言 在图论中，找到单点 s 到单点 t 的最大流，称为最大流问题，其中 s-t 的最大流等于 s-t 的最小割，使用 Ford–Fulkerson 算法可以确认最大流。 维基百科 最大流 ","date":"2022-04-05","objectID":"/posts/%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/:1:0","tags":["最大流最小割"],"title":"最大流和最小割","uri":"/posts/%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/"},{"categories":["算法"],"content":"最大流 求由 s 发出，t 每秒接受的最大流量，称为最大流问题。首先可以利用贪心算法，确认 s-\u003et 的一条路径，但该路径不一定是最大流。Ford–Fulkerson 算法提出了一个残余网络，也叫增广路，将之前的s-\u003et路径的流进行反转，同时原网络减去 s-\u003et 的流量，二者合并构成残余网络。同时在根据残余网络找到 s-\u003et 的路径。根据上述规则，不断的重复迭代，直到 s-\u003et 没有到达路径流，则可以得到最大流（最大流量在每次迭代的过程中都是累加的，因为只需要计算 s 到 t 的流量，终点 t 每次迭代后流入流量都是在累加）。 将流量路径反转的目的是在于可以重新规划边的流量流向，若后续还存在 s-\u003et 路径，且需要更改反转的路径大小，则表面需要调整之前的流量大小，以此提高 s 到 t 的流量大小。 ","date":"2022-04-05","objectID":"/posts/%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/:2:0","tags":["最大流最小割"],"title":"最大流和最小割","uri":"/posts/%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/"},{"categories":["算法"],"content":"最小割 图的割，指的是对于某个顶点集合 $S \\subseteq V$ ，从 S 出发指向外部那些边的集合，记为割(S, V\\S)。这些边的流量容量之和称为割的容量。通俗来说，就是将一个连通图，划分为两个不连通的子图，而割代表的是再划分时，所需要去掉的边。为了让 s 和 t 分别处于不同的子图，所需要的最小边的容量，记为最小割。当 s 和 t 处于不同的子图时，s 和 t 即不存在相连通的路径。 ","date":"2022-04-05","objectID":"/posts/%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/:3:0","tags":["最大流最小割"],"title":"最大流和最小割","uri":"/posts/%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/"},{"categories":["算法"],"content":"基本公式 记$f$为s-t的流量，则$f = (s出边的总流量)$ ，对于$v \\in S${s} 时，又有 $(v的出边的总流量) = (v的入边的总流量)$，所以 $f = (S的出边的总流量) - (S的入边的总流量)$ ，所以 $f \\le (割的流量)$。 对于残余网络来说，$f^‘$ 对应的残余网路中s 到可达 v 的的集合为 S ，因为$f^‘$ 不存在 s-\u003et 的路径，所以(S, V\\S)就是一个s-t割。根据 $f^‘ = (S的出边的总流量) - (S的入边的总流量) = (割的流量)$ ，所以$f^‘$ 为最大流。 ","date":"2022-04-05","objectID":"/posts/%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/:4:0","tags":["最大流最小割"],"title":"最大流和最小割","uri":"/posts/%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/"},{"categories":["算法"],"content":"代码实现 可以利用DFS或者BFS进行路径搜索，并不断进行迭代，直到两点之间没有路径，即可以达到最大流量。 // Ford-Fulkerson algorith in Java import java.util.LinkedList; class FordFulkerson { static final int V = 6; // Using BFS as a searching algorithm boolean bfs(int Graph[][], int s, int t, int p[]) { boolean visited[] = new boolean[V]; for (int i = 0; i \u003c V; ++i) visited[i] = false; LinkedList\u003cInteger\u003e queue = new LinkedList\u003cInteger\u003e(); queue.add(s); visited[s] = true; p[s] = -1; while (queue.size() != 0) { int u = queue.poll(); for (int v = 0; v \u003c V; v++) { if (visited[v] == false \u0026\u0026 Graph[u][v] \u003e 0) { queue.add(v); p[v] = u; visited[v] = true; } } } return (visited[t] == true); } // Applying fordfulkerson algorithm int fordFulkerson(int graph[][], int s, int t) { int u, v; int Graph[][] = new int[V][V]; for (u = 0; u \u003c V; u++) for (v = 0; v \u003c V; v++) Graph[u][v] = graph[u][v]; int p[] = new int[V]; int max_flow = 0; # Updating the residual calues of edges while (bfs(Graph, s, t, p)) { int path_flow = Integer.MAX_VALUE; for (v = t; v != s; v = p[v]) { u = p[v]; path_flow = Math.min(path_flow, Graph[u][v]); } for (v = t; v != s; v = p[v]) { u = p[v]; Graph[u][v] -= path_flow; Graph[v][u] += path_flow; } // Adding the path flows max_flow += path_flow; } return max_flow; } public static void main(String[] args) throws java.lang.Exception { int graph[][] = new int[][] { { 0, 8, 0, 0, 3, 0 }, { 0, 0, 9, 0, 0, 0 }, { 0, 0, 0, 0, 7, 2 }, { 0, 0, 0, 0, 0, 5 }, { 0, 0, 7, 4, 0, 0 }, { 0, 0, 0, 0, 0, 0 } }; FordFulkerson m = new FordFulkerson(); System.out.println(\"Max Flow: \" + m.fordFulkerson(graph, 0, 5)); } } ","date":"2022-04-05","objectID":"/posts/%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/:5:0","tags":["最大流最小割"],"title":"最大流和最小割","uri":"/posts/%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/"},{"categories":["算法"],"content":"参考资料 图论：最大流最小割详解 Ford-Fulkerson Algorithm ","date":"2022-04-05","objectID":"/posts/%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/:6:0","tags":["最大流最小割"],"title":"最大流和最小割","uri":"/posts/%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/"},{"categories":["算法"],"content":"前言 线段树擅长处理区间，形状如下图 （图片取自 维基百科 线段树)。线段树是一颗完美二叉树，其叶子存储元素值值，非叶子节点存储对应区间的值，根节点维护整个区间，对区间的操作可以在 O(log n) 时间复杂度完成。 Transformer 模型框架)\" Transformer 模型框架) ","date":"2022-04-04","objectID":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/:1:0","tags":["线段树"],"title":"线段树","uri":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/"},{"categories":["算法"],"content":"算法思想 如果要对连续区间重复多次操作时，比如求区间的最值/和等，利用线段树是可以从 O(m * n) 降低至 O(m * logn) ，m 为操作次数， n 为总区间长度。算法基本过程： 构造线段树。利用所给的区间元素，构造线段树。由于父节点需要存储两个子节点运算后的值，可以采用 自底向上 构造线段树，比如使用递归方法。 更改线段树。更改某元素的值时，也需要更改父节点以上的值，和构造阶段一样，采用 自底向上 的方法依次更改。 求区间值。求区间则使用 自顶向下 方法实现取值，根据父节点的区间范围与求取的范围，不断的递归向下取值，同时根据所求范围将区间进行拆分为若干个极大区间，直到左右区间达到所给而范围。 ","date":"2022-04-04","objectID":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/:2:0","tags":["线段树"],"title":"线段树","uri":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/"},{"categories":["算法"],"content":"再优化 当需要改变区间内某些元素值时，可以在所对应区间内（包括父节点的区间）进行标记，从而记录更改，而当需要查询到该区间时，在依次递归进行更改，减少因为更改而增加的复杂度。 ","date":"2022-04-04","objectID":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/:2:1","tags":["线段树"],"title":"线段树","uri":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/"},{"categories":["算法"],"content":"代码实现 ","date":"2022-04-04","objectID":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/:3:0","tags":["线段树"],"title":"线段树","uri":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/"},{"categories":["算法"],"content":"区间求和 307. 区域和检索 - 数组可修改 给你一个数组 nums ，请你完成两类查询。 其中一类查询要求 更新 数组 nums 下标对应的值 另一类查询要求返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 ，其中 left \u003c= right 实现 NumArray 类： NumArray(int[] nums) 用整数数组 nums 初始化对象 void update(int index, int val) 将 nums[index] 的值 更新 为 val int sumRange(int left, int right) 返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 （即，nums[left] + nums[left + 1], ..., nums[right]） 线段树各层数量为等比数量，最大需要 4n 空间。根据二叉树性质，父节点 i 的两个子节点对应的索引分别为 2 * i + 1 和 2 * i + 2 ，i 从0开始编号，从而可以使用数组来表示线段树。 class NumArray { private int[] segmentTree; private int n; public NumArray(int[] nums) { n = nums.length; segmentTree = new int[nums.length * 4]; build(0, 0, n - 1, nums); } public void update(int index, int val) { change(index, val, 0, 0, n - 1); } public int sumRange(int left, int right) { return range(left, right, 0, 0, n - 1); } private void build(int node, int s, int e, int[] nums) { if (s == e) { segmentTree[node] = nums[s]; return; } int m = s + (e - s) / 2; build(node * 2 + 1, s, m, nums); build(node * 2 + 2, m + 1, e, nums); segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2]; } private void change(int index, int val, int node, int s, int e) { if (s == e) { segmentTree[node] = val; return; } int m = s + (e - s) / 2; if (index \u003c= m) { change(index, val, node * 2 + 1, s, m); } else { change(index, val, node * 2 + 2, m + 1, e); } segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2]; } private int range(int left, int right, int node, int s, int e) { if (left == s \u0026\u0026 right == e) { return segmentTree[node]; } int m = s + (e - s) / 2; if (right \u003c= m) { return range(left, right, node * 2 + 1, s, m); } else if (left \u003e m) { return range(left, right, node * 2 + 2, m + 1, e); } else { return range(left, m, node * 2 + 1, s, m) + range(m + 1, right, node * 2 + 2, m + 1, e); } } } 链表实现，因为构造线段树采用 自顶向下 实现，所以使用了前缀和来构造线段树。 class TreeNode{ int val; int low; int high; TreeNode left; TreeNode right; TreeNode parent; } class NumArray { int n; TreeNode root; int[] prefix; int sum; public NumArray(int[] nums) { n = nums.length; root = new TreeNode(); prefix = new int[n]; prefix[0] = nums[0]; for(int i = 1; i \u003c n; i++){ prefix[i] = prefix[i - 1] + nums[i]; } root.val = prefix[n-1]; root.low = 0; root.high = n -1; root.left = init(root, nums, 0, (n-1) / 2); root.right = init(root, nums, (n-1) / 2 + 1, n - 1); } public TreeNode init(TreeNode root, int[] nums, int low, int high){ if(low \u003e high){ return null; } TreeNode child = new TreeNode(); child.parent = root; child.low = low; child.high = high; if(low == 0){ child.val = prefix[high]; }else{ child.val = prefix[high] - prefix[low - 1]; } if(low == high){ return child; }else{ child.left = init(child, nums, low, (low + high) / 2); child.right = init(child, nums, (low + high) / 2 + 1, high); return child; } } public void update(int index, int val) { TreeNode p = root; int mid = (p.low + p.high) / 2; while(p.low != index || p.high != index){ if(mid \u003c index){ p = p.right; }else{ p = p.left; } mid = (p.low + p.high) / 2; } p.val = val; while(p.parent != null){ if(p.parent.right != null){ p.parent.val = p.parent.left.val + p.parent.right.val; }else{ p.parent.val = p.parent.left.val; } p = p.parent; } } public int sumRange(int left, int right) { sum = 0; TreeNode p = root; if(left == root.low \u0026\u0026 right == root.high){ return root.val; } return getSum(p, left, right); } public void getSum(TreeNode root, int left, int right) { if(root == null){ return; } int mid = (root.low + root.high) / 2; if(root.low == left \u0026\u0026 root.high == right) { sum = root.val; return; } if(root.low == left \u0026\u0026 root.high \u003c right) { sum += root.val; return ; } if(root.low \u003e left \u0026\u0026 root.high \u003c right) { sum += root.val; return; } if(root.low \u003e left \u0026\u0026 root.high == right) { sum += root.val; return; } if(mid \u003c= right) { getSum(root.right, left, right); } getSum(root.left, left, right); } } ","date":"2022-04-04","objectID":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/:3:1","tags":["线段树"],"title":"线段树","uri":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/"},{"categories":["算法"],"content":"参考资料 线段树 OI Wiki 线段树 ","date":"2022-04-04","objectID":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/:4:0","tags":["线段树"],"title":"线段树","uri":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/"},{"categories":["算法"],"content":"动态规划","date":"2022-04-03","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/","tags":["算法","动态规划"],"title":"动态规划","uri":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/"},{"categories":["算法"],"content":"前言 动态规划与分治方法类似，通过组合子问题解决原问题。动态规划应用与子问题重叠的情况，及不同的子问题具有公共 的子子问题的解。动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。 适用情况 (摘自 维基百科 动态规划) ： 最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。 无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。 ","date":"2022-04-03","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/:1:0","tags":["算法","动态规划"],"title":"动态规划","uri":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/"},{"categories":["算法"],"content":"解题思路 动态规划算法主要通过四个步骤来设计 刻画一个最优解的结构特征 递归定义最优解 计算最优解的值（自底向上或带备忘的自顶向下，大部分使用自底向上) 利用计算的信息构造最优解 ","date":"2022-04-03","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/:2:0","tags":["算法","动态规划"],"title":"动态规划","uri":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/"},{"categories":["算法"],"content":"代码实现 以 剑指 Offer II 093. 最长斐波那契数列 题目为例 如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是 斐波那契式 的： n \u003e= 3 对于所有 i + 2 \u003c= n，都有 X_i + X_{i+1} = X_{i+2} 给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。 （回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列） 斐波纳契数列长度主要观察最后两位，若后续值可以等于最后两位的和，则表示可以将该数加入对应的数列当中。于是可以使用dp[i][j]：表示以arr[i] , arr[j]结尾的斐波那契数列的最大长度。若 arr[j] - arr[i] 存在数列当中，且索引小于 i 时，记为 k ，则 dp[i][j] 需要进行更新，dp[i][j] = max(dp[i][j], dp[k][i] + 1) 。 为了降低确认 差值 是否存在数列当中且索引低于 i ，可以先将数列存入哈希表当中，其中 Key 为值， Value 为索引。 class Solution { public int lenLongestFibSubseq(int[] arr) { int n = arr.length; Map\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); for(int i = 0; i \u003c n; i++){ map.put(arr[i], i); } int[][] dp = new int[n][n]； int max = 0; for(int i = 0; i \u003c n - 1; i++) { for(int j = i + 1; j \u003c n; j++) { int temp = arr[j] - arr[i]; int index = map.getOrDefault(temp, -1); if(index \u003e -1 \u0026\u0026 index \u003c i) { dp[i][j] = dp[index][i] + 1; max = Math.max(max, dp[i][j] + 2); } } } return max \u003e 2 ? max : 0; } } 注：解该题的重要思路就是确认 dp 数组表示的内容，即表示到达 i 和 j 的斐波纳契数列最大长度。 ","date":"2022-04-03","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/:3:0","tags":["算法","动态规划"],"title":"动态规划","uri":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/"},{"categories":["算法"],"content":"再优化 更新 dp 数组时，上述代码采用的是暴力更新。因为数列是已经排序好了的，可以采用双指针进行遍历更新，从而减少时间复杂度，同时也不在需要哈希表了。 class Solution { public int lenLongestFibSubseq(int[] arr) { int n = arr.length, max = 0; int[][] dp = new int[n][n]; for(int i = 2 ; i \u003c n ; i++){ int j = 0, k = i-1; while(j \u003c k){ if(arr[j] + arr[k] == arr[i]){ if(dp[j][k] == 0){ dp[k][i] = 3; }else{ dp[k][i] = Math.max(dp[j][k]+1, dp[k][i]); } max = Math.max(max, dp[k][i]); j++;k--; } else if(arr[j] + arr[k] \u003c arr[i]){ j++; }else { k--; } } } return max; } } ","date":"2022-04-03","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/:3:1","tags":["算法","动态规划"],"title":"动态规划","uri":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/"},{"categories":["算法"],"content":"参考资料 动态规划 状态定义很是重要！ 算法导论 ","date":"2022-04-03","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/:4:0","tags":["算法","动态规划"],"title":"动态规划","uri":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/"},{"categories":["算法"],"content":"博弈论常见案例","date":"2022-04-02","objectID":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/","tags":["算法","双博弈论"],"title":"博弈论","uri":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/"},{"categories":["算法"],"content":"前言 博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。表面上不同的相互作用可能表现出相似的激励结构（incentive structure），所以它们是同一个游戏的特例。 ","date":"2022-04-02","objectID":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/:1:0","tags":["算法","双博弈论"],"title":"博弈论","uri":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/"},{"categories":["算法"],"content":"博弈论基本解法 由于博弈论都是在考虑最优解的情况下进行的步骤，所以只需要知道在各个步骤的的必败必胜必和情况，并以此进行规划就可以知道最后的胜负状况。其中最重要的是，是确定必胜/必败/必和的条件。 ","date":"2022-04-02","objectID":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/:2:0","tags":["算法","双博弈论"],"title":"博弈论","uri":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/"},{"categories":["算法"],"content":"案例一 异或数列 ： Alice 和 Bob 正在玩一个异或数列的游戏。初始时，Alice 和 Bob 分别有一个整数 a 和 b，有一个给定的长度为 n 的公共数列 $X_1, X_2, · · · , X_n$Alice 和 Bob 轮流操作，Alice 先手，每步可以在以下两种选项中选一种： 选项 1：从数列中选一个 Xi 给 Alice 的数异或上，或者说令 a 变为 a ⊕ $X_i$。（其中 ⊕ 表示按位异或） 选项 2：从数列中选一个 Xi 给 Bob 的数异或上，或者说令 b 变为 b ⊕ $X_i$。 每个数 Xi 都只能用一次，当所有 $X_i$ 均被使用后（n 轮后）游戏结束。游戏结束时，拥有的数比较大的一方获胜，如果双方数值相同，即为平手。现在双方都足够聪明，都采用最优策略，请问谁能获胜。（$n \u003c 2^{20}$） 首先确认游戏的必胜/必败/必和情况。其中必和情况为：A=B ，所以 A^B = 0 ，所以只需要对各个数字异或判断是否为 0 即可。剩下比较异或结果的数字大小，只需要看最高位即可，故只需要统计一下各个位 1 的个数。由题目可知，各个数字都可以由 20 位表示。 必和：$X_0$ ⊕ $X_i$ ⊕ $X_n$ = 0 i = 1, 2, …, n -1 必胜/必败：最高位，1 的个数位偶数，则下一位判断。奇数时 1 的个数为 1 时，则先手获胜 大于 1 时，总数字个数位偶数时，先手必败 大于 1 时，总数字个数位奇数时，先手必胜 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); int T = in.nextInt(); int[] ans = new int[T]; long sum = 1; for(int i = 0; i \u003c T; i++) { int n = in.nextInt(); int[] count = new int[20]; sum = 0; for(int j = 0; j \u003c n; j++) { long num = in.nextLong(); int temp = 1; int k = 0; sum = sum ^ num; for(; k \u003c 20; k++) { if((num \u0026 temp) == temp) { count[k]++; } temp \u003c\u003c= 1; } } if(sum == 0) { ans[i] = 0; // System.out.println(0); continue; } int k = 19; for(; k \u003e= 0; k--) { if(count[k] == 1) { ans[i] = 1; // System.out.println(1); break; }else if(count[k] % 2 == 1 \u0026\u0026 n % 2 == 0) { ans[i] = -1; // System.out.println(-1); break; }else if(count[k] % 2 == 1 \u0026\u0026 n % 2 == 1) { ans[i] = 1; // System.out.println(1); break; } } } for(int i = 0; i \u003c T; i++) { System.out.println(ans[i]); } } } ","date":"2022-04-02","objectID":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/:2:1","tags":["算法","双博弈论"],"title":"博弈论","uri":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/"},{"categories":["算法"],"content":"案例二 著名的 Nim游戏 ： 有 n 堆石子，每堆各有 $a_i$ 颗石子。Alice 和 Bob 轮流从非空的石子堆取走至少一颗石子。Alice 先取，取光所有石子的一方获胜。当双方采取最优策略时，谁会获胜？ 同样，首先确认该游戏必胜/必败/必和情况。有如下结论成立 $$a_1 XOR a_2 XOR … XOR a_n != 0 —\u003e 必胜态 $$ $$a_1 XOR a_2 XOR … XOR a_n == 0 —\u003e 必败态 $$ 其中 XOR 表示异或。 ","date":"2022-04-02","objectID":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/:2:2","tags":["算法","双博弈论"],"title":"博弈论","uri":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/"},{"categories":["算法"],"content":"参考 博弈论 挑战程序设计竞赛 蓝桥杯2021年第十二届省赛真题-异或数列 ","date":"2022-04-02","objectID":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/:3:0","tags":["算法","双博弈论"],"title":"博弈论","uri":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/"},{"categories":["Java 基础"],"content":"Comparator类的compare方法重写","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["Java 基础"],"content":"前言 做算法题时，经常遇到需要对某些数据结构的 compare 方法重写，比如 PriorityQueue，但 Java 默认实现的优先队列为小顶堆，即最小的优先选择。但有的时候需要大顶堆或者其他数据类型比较，比如数组，类等，所以，必须对 Comparator 的 compare 方法进行重写 ","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/:1:0","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["Java 基础"],"content":"基本步骤 以下都以 PriorityQueue 优先队列实现作为参考，其他数据结构类似 ","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/:2:0","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["Java 基础"],"content":"基本数据类型 当对基本数据类型重写时，只需要对方法简单重写即可。重写方法有创建 Comparator 的子类、匿名类或者 Lambda 表达式。以下均为改写为升序优先队列，即大顶堆实现方式。 子类 继承 Comparator 子类并重写父类的方法，是最基本的实现方式 class Main{ public static void main(String[] args){ PriorityQueue\u003cInteger\u003e numbers = new PriorityQueue\u003c\u003e(new myComparator()); } } class MyComparator implements Comparator\u003cInteger\u003e { @Override public int compare(Integer number1, Integer number2) { return number2 - number1; } } 匿名类 为了减少创建不必要的类，可以直接使用匿名类完成 class Main{ public static void main(String[] args){ PriorityQueue\u003cInteger\u003e numbers = new PriorityQueue\u003c\u003e(new Comparator(){ @Override public int compare(Integer number1, Integer number2) { return number2 - number1; } }); } } Lambda 表达式 为了减少使用匿名类的代码，可以直接使用 Lambda 表达式 class Main{ public static void main(String[] args){ PriorityQueue\u003cInteger\u003e numbers = new PriorityQueue\u003c\u003e((a, b) -\u003e b - a); } } ","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/:2:1","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["Java 基础"],"content":"数组 数组重写方法基本与基本数据类似，只以匿名类写法作为参考 class Main{ public static void main(String[] args){ PriorityQueue\u003cint[]\u003e numbers = new PriorityQueue\u003c\u003e(new Comparator\u003cint[]\u003e(){ @Override public int compare(int[] o1, int[] o2){ return o1[1] - o2[1]; } }); } } 该优先队列存储数据结构类型为 int 数组，且以下数组的索引 1 为对应数据降序排序 ","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/:2:2","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["Java 基础"],"content":"二维数组 有的时候需要对二维数组的某一维度进行排序，比如需要调用 Arrays.sort() 方法对二维数组排序，但原生排序只支持一维数组，故需要重写，例如对二维数组的第一维度进行升序排序 Arrays.sort(intervals, new Comparator\u003cint[]\u003e() { @Override public int compare(int[] o1 , int[] o2){ return o1[0] - o2[0]; } }); ","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/:2:3","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["Java 基础"],"content":"参考资料 Java PriorityQueue 1606. 找到处理最多请求的服务器 ","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/:3:0","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["深度学习"],"content":"Pytorch 常用api记录","date":"2022-03-29","objectID":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/","tags":["pytorch","基础"],"title":"Pytorch 常用api","uri":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/"},{"categories":["深度学习"],"content":"前言 Pytorch 是研究生阶段深度学习常用的工具。在学习深度学习的过程中，记录一下使用 Pytorch 经常遇到 api。 ","date":"2022-03-29","objectID":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/:1:0","tags":["pytorch","基础"],"title":"Pytorch 常用api","uri":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/"},{"categories":["深度学习"],"content":"常用 API ","date":"2022-03-29","objectID":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/:2:0","tags":["pytorch","基础"],"title":"Pytorch 常用api","uri":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/"},{"categories":["深度学习"],"content":"Tensor.repeat(*sizes) -\u003e Tensor 沿指定维度重复张量 sizes 次数，可以同时指定多个维度，例如 \u003e\u003e\u003e x = torch.tensor([1, 2, 3]) \u003e\u003e\u003e x.repeat(4, 2) tensor([[ 1, 2, 3, 1, 2, 3], [ 1, 2, 3, 1, 2, 3], [ 1, 2, 3, 1, 2, 3], [ 1, 2, 3, 1, 2, 3]]) \u003e\u003e\u003e x.repeat(4, 2, 1).size() torch.Size([4, 2, 3]) 上述表达式为在第 0 维度重复四次，在第 1 维度重复两次 ","date":"2022-03-29","objectID":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/:2:1","tags":["pytorch","基础"],"title":"Pytorch 常用api","uri":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/"},{"categories":["深度学习"],"content":"torch.permute(input, dims) -\u003e Tensor 按所给顺序交换张量各个维度 \u003e\u003e\u003e x = torch.randn(2, 3, 5) \u003e\u003e\u003e x.size() torch.Size([2, 3, 5]) \u003e\u003e\u003e torch.permute(x, (2, 0, 1)).size() torch.Size([5, 2, 3]) 默认顺序从 0 开始，上述表达式为各个维度向右移动一位。 ","date":"2022-03-29","objectID":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/:2:2","tags":["pytorch","基础"],"title":"Pytorch 常用api","uri":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/"},{"categories":["深度学习"],"content":"torch.empty(size…)→ Tensor 安装所给的维度，初始化一个张量，但张量内数据未初始化（随机） \u003e\u003e\u003e torch.empty((2,3), dtype=torch.int64) tensor([[ 9.4064e+13, 2.8000e+01, 9.3493e+13], [ 7.5751e+18, 7.1428e+18, 7.5955e+18]]) ","date":"2022-03-29","objectID":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/:2:3","tags":["pytorch","基础"],"title":"Pytorch 常用api","uri":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/"},{"categories":["深度学习"],"content":"Transformer 代码分析","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"前言 Transformer 是 2017 年 Google 团队提出的新的一种 NLP 模型，采用 Encoder-Decoder （编码器-解码器）架构，使用 self-attention 机制。 其在 seq2seq 上表现出非常鲁棒的性能，并且在 Transformer 基础上，提出了众多变种类型，比较知名的有 Bert 和 GPT 。以上模型，在 github 中都有实现 State-of-the-art Machine Learning for JAX, PyTorch and TensorFlow Transformer 模型框架)\" Transformer 模型框架) ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:1:0","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"基本结构 为了更好的理解和运用 Transformer ，应理解 Transformer 代码实现过程 以下代码来自 动手学深度学习 PyTorch版 ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:2:0","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"导包 因为在如下部分代码中使用了动手学深度学习 PyTorch版 使用了自身提供的库，需要将他们的库导入 import math import pandas as pd import torch from torch import nn from d2l import torch as d2l ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:2:1","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"逐位前馈网络 逐位前馈网络 实质就是一个 MLP 网络，含有两个 全连接层 ，和一个 ReLU 层。 class PositionWiseFFN(nn.Module): \"\"\"基于位置的前馈网络\"\"\" def __init__(self, ffn_num_input, ffn_num_hiddens, ffn_num_outputs, **kwargs): super(PositionWiseFFN, self).__init__(**kwargs) self.dense1 = nn.Linear(ffn_num_input, ffn_num_hiddens) self.relu = nn.ReLU() self.dense2 = nn.Linear(ffn_num_hiddens, ffn_num_outputs) def forward(self, X): return self.dense2(self.relu(self.dense1(X))) ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:2:2","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"残差和层规范化 和 RNN 类似，残差在 Transformer 中，使用的是 batch normlization ，而不是常用的 layer normlization #@save class AddNorm(nn.Module): \"\"\"残差连接后进行层规范化\"\"\" def __init__(self, normalized_shape, dropout, **kwargs): super(AddNorm, self).__init__(**kwargs) self.dropout = nn.Dropout(dropout) self.ln = nn.LayerNorm(normalized_shape) def forward(self, X, Y): return self.ln(self.dropout(Y) + X) ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:2:3","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"编码块 Transformer 中含有 6 层 编码块和 6 层 解码 块。在每个编码块中包含有一个注意力层、两个批量规范层和一个逐位前馈网络层，在每个批量规范层中都使用了残差连接 class EncoderBlock(nn.Module): \"\"\"transformer编码器块\"\"\" def __init__(self, key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, dropout, use_bias=False, **kwargs): super(EncoderBlock, self).__init__(**kwargs) self.attention = d2l.MultiHeadAttention( key_size, query_size, value_size, num_hiddens, num_heads, dropout, use_bias) self.addnorm1 = AddNorm(norm_shape, dropout) self.ffn = PositionWiseFFN( ffn_num_input, ffn_num_hiddens, num_hiddens) self.addnorm2 = AddNorm(norm_shape, dropout) def forward(self, X, valid_lens): Y = self.addnorm1(X, self.attention(X, X, X, valid_lens)) return self.addnorm2(Y, self.ffn(Y)) ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:2:4","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"解码块 与编码块不同的是，在解码块中使用了两个注意力层，第一个注意层用来生成 Query，并将编码器的结果作为 Key 和 Value ，送入第二个注意层学习。在使用多头注意力机制时，将每个头的结果矩阵拼接起来，最后在传入全连接层计算。 class DecoderBlock(nn.Module): \"\"\"解码器中第 i 个块\"\"\" def __init__(self, key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, dropout, i, **kwargs): super(DecoderBlock, self).__init__(**kwargs) self.i = i self.attention1 = d2l.MultiHeadAttention( key_size, query_size, value_size, num_hiddens, num_heads, dropout) self.addnorm1 = AddNorm(norm_shape, dropout) self.attention2 = d2l.MultiHeadAttention( key_size, query_size, value_size, num_hiddens, num_heads, dropout) self.addnorm2 = AddNorm(norm_shape, dropout) self.ffn = PositionWiseFFN(ffn_num_input, ffn_num_hiddens, num_hiddens) self.addnorm3 = AddNorm(norm_shape, dropout) def forward(self, X, state): enc_outputs, enc_valid_lens = state[0], state[1] # 训练阶段，输出序列的所有词元都在同一时间处理， # 因此 `state[2][self.i]` 初始化为 `None`。 # 预测阶段，输出序列是通过词元一个接着一个解码的， # 因此 `state[2][self.i]` 包含着直到当前时间步第 `i` 个块解码的输出表示 if state[2][self.i] is None: key_values = X else: key_values = torch.cat((state[2][self.i], X), axis=1) state[2][self.i] = key_values if self.training: batch_size, num_steps, _ = X.shape # `dec_valid_lens` 的开头: (`batch_size`, `num_steps`), # 其中每一行是 [1, 2, ..., `num_steps`] dec_valid_lens = torch.arange( 1, num_steps + 1, device=X.device).repeat(batch_size, 1) else: dec_valid_lens = None # 自注意力 X2 = self.attention1(X, key_values, key_values, dec_valid_lens) Y = self.addnorm1(X, X2) # 编码器－解码器注意力。 # `enc_outputs` 的开头: (`batch_size`, `num_steps`, `num_hiddens`) Y2 = self.attention2(Y, enc_outputs, enc_outputs, enc_valid_lens) Z = self.addnorm2(Y, Y2) return self.addnorm3(Z, self.ffn(Z)), state ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:2:5","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"实现代码 Transformer 模型分为两大部分，编码器和解码器，根据上述基本结构，就可以实现这两大部分 ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:3:0","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"编码器 在 Transformer 的编码器包含了多个编码块。可以使用 nn.Sequential() 生成多个编码块，构成编码器 class TransformerEncoder(d2l.Encoder): \"\"\"transformer编码器\"\"\" def __init__(self, vocab_size, key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, num_layers, dropout, use_bias=False, **kwargs): super(TransformerEncoder, self).__init__(**kwargs) self.num_hiddens = num_hiddens self.embedding = nn.Embedding(vocab_size, num_hiddens) self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout) self.blks = nn.Sequential() for i in range(num_layers): self.blks.add_module(\"block\"+str(i), EncoderBlock(key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, dropout, use_bias)) def forward(self, X, valid_lens, *args): # 因为位置编码值在 -1 和 1 之间， # 因此嵌入值乘以嵌入维度的平方根进行缩放， # 然后再与位置编码相加。 X = self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens)) self.attention_weights = [None] * len(self.blks) for i, blk in enumerate(self.blks): X = blk(X, valid_lens) self.attention_weights[ i] = blk.attention.attention.attention_weights return X ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:3:1","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"解码器 同编码器一样，使用使用 nn.Sequential() 生成多个解码块，构成解码器 class TransformerDecoder(d2l.AttentionDecoder): def __init__(self, vocab_size, key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, num_layers, dropout, **kwargs): super(TransformerDecoder, self).__init__(**kwargs) self.num_hiddens = num_hiddens self.num_layers = num_layers self.embedding = nn.Embedding(vocab_size, num_hiddens) self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout) self.blks = nn.Sequential() for i in range(num_layers): self.blks.add_module(\"block\"+str(i), DecoderBlock(key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, dropout, i)) self.dense = nn.Linear(num_hiddens, vocab_size) def init_state(self, enc_outputs, enc_valid_lens, *args): return [enc_outputs, enc_valid_lens, [None] * self.num_layers] def forward(self, X, state): X = self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens)) self._attention_weights = [[None] * len(self.blks) for _ in range (2)] for i, blk in enumerate(self.blks): X, state = blk(X, state) # 解码器自注意力权重 self._attention_weights[0][ i] = blk.attention1.attention.attention_weights # “编码器－解码器”自注意力权重 self._attention_weights[1][ i] = blk.attention2.attention.attention_weights return self.dense(X), state @property def attention_weights(self): return self._attention_weights ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:3:2","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"训练与预测 # 训练 num_hiddens, num_layers, dropout, batch_size, num_steps = 32, 2, 0.1, 64, 10 lr, num_epochs, device = 0.005, 200, d2l.try_gpu() ffn_num_input, ffn_num_hiddens, num_heads = 32, 64, 4 key_size, query_size, value_size = 32, 32, 32 norm_shape = [32] train_iter, src_vocab, tgt_vocab = d2l.load_data_nmt(batch_size, num_steps) encoder = TransformerEncoder( len(src_vocab), key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, num_layers, dropout) decoder = TransformerDecoder( len(tgt_vocab), key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, num_layers, dropout) net = d2l.EncoderDecoder(encoder, decoder) d2l.train_seq2seq(net, train_iter, lr, num_epochs, tgt_vocab, device) # 预测 engs = ['go .', \"i lost .\", 'he\\'s calm .', 'i\\'m home .'] fras = ['va !', 'j\\'ai perdu .', 'il est calme .', 'je suis chez moi .'] for eng, fra in zip(engs, fras): translation, dec_attention_weight_seq = d2l.predict_seq2seq( net, eng, src_vocab, tgt_vocab, num_steps, device, True) print(f'{eng}=\u003e {translation}, ', f'bleu {d2l.bleu(translation, fra, k=2):.3f}') ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:3:3","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["算法"],"content":"计算质因子个数","date":"2022-03-25","objectID":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/","tags":["算法","质因子"],"title":"质因子个数计算","uri":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/"},{"categories":["算法"],"content":"前言 172. 阶乘后的零 该题中计算阶乘结果 0 的个数，可转换为计算 n 中含有 5 质因子的个数问题 ","date":"2022-03-25","objectID":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/:1:0","tags":["算法","质因子"],"title":"质因子个数计算","uri":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/"},{"categories":["算法"],"content":"算法思想 [1,n] 中 p 的倍数有 $n_1 = \\lfloor \\frac{n}{p} \\rfloor$ ，以此类推可以得到 $n_i = \\lfloor \\frac{n}{p^i} \\rfloor$ 可以得到 $p^i$ 质因子的个数。又因为若 n 是 $p^i$ 的倍数，则 n 必定也是 $n^{i-1}$ 的倍数，故 [1, n]的中的 p 的质因子个数为 $\\sum \\lfloor \\frac{n}{p^i} \\rfloor$ 计算结果的 0 的个数即统计 10 因子的个数，质因素分解为 2 和 5 ，根据上述公式，可以知道 2 的 个数多余 5 的个数，故只要计算 5 的质因子个数。 ","date":"2022-03-25","objectID":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/:2:0","tags":["算法","质因子"],"title":"质因子个数计算","uri":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/"},{"categories":["算法"],"content":"代码 class Solution { public int trailingZeroes(int n) { int res = 0; while(n \u003e= 5){ res += n / 5; n /= 5; } return res; } } ","date":"2022-03-25","objectID":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/:3:0","tags":["算法","质因子"],"title":"质因子个数计算","uri":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/"},{"categories":["算法"],"content":"参考资料 阶乘后的零 ","date":"2022-03-25","objectID":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/:4:0","tags":["算法","质因子"],"title":"质因子个数计算","uri":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/"},{"categories":["Java 基础"],"content":"Java 的常用数据结构","date":"2022-03-24","objectID":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/","tags":["数据结构"],"title":"Java 常用数据结构","uri":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Java 基础"],"content":"LinkedList LinkedList 链表，除了 队列 接口，还实现了 双端队列 void add(int index, E element) : 在特定位置位置插入元素 boolean add(E e) ： 在链表尾部加入元素 E remove(int index) ： 删除链表给定序号的元素 E removeLast() : 删除链表尾部元素 ","date":"2022-03-24","objectID":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:1:0","tags":["数据结构"],"title":"Java 常用数据结构","uri":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Java 基础"],"content":"HashMap HashMap 哈希表，可以存 空值 ，不保证映射后的遍历顺序，也不保证该顺序会随着时间变化而保持，迭代方式 键值迭代 import java.util.HashMap; import java.util.Map; public class Test { public static void main(String[] args) throws IOException { Map\u003cInteger, Integer\u003e map = new HashMap\u003cInteger, Integer\u003e(); map.put(1, 10); map.put(2, 20); // Iterating entries using a For Each loop for (Map.Entry\u003cInteger, Integer\u003e entry : map.entrySet()) { System.out.println(\"Key = \" + entry.getKey() + \", Value = \" + entry.getValue()); } } } 键迭代 import java.util.HashMap; import java.util.Map; public class Test { public static void main(String[] args) throws IOException { Map\u003cInteger, Integer\u003e map = new HashMap\u003cInteger, Integer\u003e(); map.put(1, 10); map.put(2, 20); // 迭代键 for (Integer key : map.keySet()) { System.out.println(\"Key = \" + key); } // 迭代值 for (Integer value : map.values()) { System.out.println(\"Value = \" + value); } } } boolean isEmpty() : 判断哈希表是否为空 boolean containsKet(Object Key) : 查询哈希表是否存在 Key ，存在返回 true Set\u003cMap.Entry \u003cK, V\u003e\u003e entrySet() ： 获取 HashMap 的迭代器，可以同时获得 Key 和 Value Set\u003cK\u003e keySet ：获取哈希表的 Key 的迭代器 V remove(Object Key) : 溢出哈希表的 Key和对于的 Value int size() : 获取哈希标的实际大小 ","date":"2022-03-24","objectID":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:2:0","tags":["数据结构"],"title":"Java 常用数据结构","uri":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Java 基础"],"content":"LinkedHashMap LinkedHashMap 与 HashMap 不同的是，该哈希表可以预测迭代顺序，因为实现了双向链表，该链表定义了迭代顺序，api 同上 ","date":"2022-03-24","objectID":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:3:0","tags":["数据结构"],"title":"Java 常用数据结构","uri":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Java 基础"],"content":"TreeSet TreeSet 为有序集合，实现了 NavigableSet 接口，默认排序顺序为升序排序，内部结构为平衡二叉树(红黑树)。可以在 O(h) 的时间复杂度完成查找、增加、删除操作。由于实现了 NavigableSet 接口，可以实现查找小于、大于某元素的结果，如没有找到则返回 null 。所以，需要使用包装类接受返回值，而不能使用基本类型接受返回数据。 E ceiling(E e) : 返回此集合中大于或等于给定元素的最小元素，如果没有这样的元素，则返回 null E floor(E e) : 返回此集合中小于或等于给定元素的最大元素，如果没有这样的元素，则返回 null E greater(E e) : 返回此集合中严格大于给定元素的最小元素，如果没有这样的元素，则返回 null E lower(E e) : 返回此集合中严格小于给定元素的最小元素，如果没有这样的元素，则返回 null boolean contains(Object o) : 查询元素是否存在有序集合当中 ","date":"2022-03-24","objectID":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:4:0","tags":["数据结构"],"title":"Java 常用数据结构","uri":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Java 基础"],"content":"PriorityQueue PriorityQueue 默认实现为小顶堆，与C++ 的优先队列默认为大顶堆不一样。 E peek() : 查看堆顶元素 E poll() : 删除顶堆元素 ","date":"2022-03-24","objectID":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:4:1","tags":["数据结构"],"title":"Java 常用数据结构","uri":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["算法"],"content":"变位词匹配 算法","date":"2022-03-24","objectID":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/","tags":["算法","变位词"],"title":"变位词","uri":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/"},{"categories":["算法"],"content":"前言 变位词 是指字符串更改字符顺序后相等的字符串（即字符串内各个字符出现的次数相等）。变位词 匹配就是将字符串数组中所有相同的变位词找出。 剑指 Offer II 033. 变位词组 ","date":"2022-03-24","objectID":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/:1:0","tags":["算法","变位词"],"title":"变位词","uri":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/"},{"categories":["算法"],"content":"算法思想 暴力求解 ：将两个字符串的各个字符查询统计并比较，这种算法的时间复杂度为 O(m*n) ，且难适用于多个字符串同时进行匹配分组 计数拼接 ： 将各个字符统计并计数，最后将各个字符与对应的次数进行拼接起来，比如 leetcode，计算得到的字符为 c1d1e3l1o1t1，接着将结果作为哈希 Key ， 该字符的索引作为 Value ，使用哈希匹配分组 素数求积 ： 将各个字符映射为一个素数，同时求得字符串的累积，并将结果作为哈希的 Key ，字符串的索引作为 Value ，使用哈希匹配分组。该思路需要考虑 大数 问题，若基本数据会溢出的话，可以使用 mod 求余，但这也需要考虑哈希冲突 ","date":"2022-03-24","objectID":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/:2:0","tags":["算法","变位词"],"title":"变位词","uri":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/"},{"categories":["算法"],"content":"代码 计数拼接代码，参考自 字母异位词分组 class Solution { public List\u003cList\u003cString\u003e\u003e groupAnagrams(String[] strs) { Map\u003cString, List\u003cString\u003e\u003e map = new HashMap\u003cString, List\u003cString\u003e\u003e(); for (String str : strs) { int[] counts = new int[26]; int length = str.length(); for (int i = 0; i \u003c length; i++) { counts[str.charAt(i) - 'a']++; } // 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键 StringBuffer sb = new StringBuffer(); for (int i = 0; i \u003c 26; i++) { if (counts[i] != 0) { sb.append((char) ('a' + i)); sb.append(counts[i]); } } String key = sb.toString(); List\u003cString\u003e list = map.getOrDefault(key, new ArrayList\u003cString\u003e()); list.add(str); map.put(key, list); } return new ArrayList\u003cList\u003cString\u003e\u003e(map.values()); } } 素数求积。根据题目所给要求，判断不会溢出，故没有取余 class Solution { public List\u003cList\u003cString\u003e\u003e groupAnagrams(String[] strs) { List\u003cList\u003cString\u003e\u003e res = new ArrayList\u003c\u003e(); Map\u003cLong, Integer\u003e map = new HashMap\u003c\u003e(); int[] primeNum = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47, 53,59,61,67,71,73,79,83,89,97,101}; long product = 1; String temp; int index; for(int i = 0; i \u003c strs.length; i++){ temp = strs[i]; product = 1; for(int j = 0; j \u003c temp.length(); j++){ product *= primeNum[temp.charAt(j) - 'a']; } if(map.containsKey(product)){ index = map.get(product); res.get(index).add(temp); }else{ List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(temp); res.add(list); map.put(product, res.size()-1); } } return res; } } ","date":"2022-03-24","objectID":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/:3:0","tags":["算法","变位词"],"title":"变位词","uri":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/"},{"categories":["算法"],"content":"参考资料 变位词问题 ","date":"2022-03-24","objectID":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/:4:0","tags":["算法","变位词"],"title":"变位词","uri":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/"},{"categories":["深度学习"],"content":"机器学习的常用缩写","date":"2022-03-23","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/","tags":["机器学习"],"title":"机器学习中常用缩写汇总","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/"},{"categories":["深度学习"],"content":"前言 阅读论文经常遇到各种缩写形式，为了方便论文阅读，故将论文常用的缩写记录下来 ","date":"2022-03-23","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/:1:0","tags":["机器学习"],"title":"机器学习中常用缩写汇总","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/"},{"categories":["深度学习"],"content":"机器学习 ","date":"2022-03-23","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/:2:0","tags":["机器学习"],"title":"机器学习中常用缩写汇总","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/"},{"categories":["深度学习"],"content":"深度学习 DNN ：Deep Neural Networks，深度神经网络，深度学习的基础 ReLU ：Rectified Linear Unit ，常用的激活函数 GMM ：Gaussian Mixture Model ，高斯混合模型，单一高斯概率密度函数的延伸，就是用多个高斯概率密度函数（正态分布曲线）精确地量化变量分布，是将变量分布分解为若干基于高斯概率密度函数（正态分布曲线）分布的统计模型。 HMM : Hidden Markov Model ，隐马尔可夫模型，用来描述一个含有隐含未知参数的马尔可夫过程 MAP ： Maximum APosteriori ，最大后验概率 MLLR ： Maximum Likelihood Linear Regression ，最大似然回归 DBN ： Deep Belief Networks ，深度置信网络 CD ： Context Dependent ，上下文相关 MFCC : Mel Frequency Cepstral Coeffcients ，梅尔倒谱系数，对语音进行编码 FBK ：Filter Bank Feature ，滤波器组特征，用于语音编码 PLP ： Perceptual Linear Prediction ，感知线性预测系数，用于语音编码 ","date":"2022-03-23","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/:3:0","tags":["机器学习"],"title":"机器学习中常用缩写汇总","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/"},{"categories":["算法"],"content":"字典树的基本原理","date":"2022-03-23","objectID":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/","tags":["算法","字典树"],"title":"字典树","uri":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/"},{"categories":["算法"],"content":"前言 字典树 ，是一种空间换时间的数据结构，又称 Trie 树、前缀树 ，是一种树形结构(字典树是一种数据结构)，用于统计、排序、和保存大量字符串 ","date":"2022-03-23","objectID":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/:1:0","tags":["算法","字典树"],"title":"字典树","uri":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/"},{"categories":["算法"],"content":"算法思想 按照题目所给的 字典序 要求，生成相应的 字典树 结构。后续查找通过公共前缀来减少查找时间，降低查找时间复杂度 字典树 的三个重要性质： 根节点不包含字符，除了根节点每个节点都只包含一个字符。root节点不含字符这样做的目的是为了能够包括所有字符串。 从根节点到某一个节点，路过字符串起来就是该节点对应的字符串。（也可以直接在该节点保存字符连接后的结果） 每个节点的子节点字符不同，也就是找到对应单词、字符是唯一的。 ","date":"2022-03-23","objectID":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/:2:0","tags":["算法","字典树"],"title":"字典树","uri":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/"},{"categories":["算法"],"content":"在优化 字典树 的空间复杂度为 O(N) ，可以根据 前序 结果推导出 后序 结果，可以不创建 字典树 ，直接使用 前序 进行迭代，相应的空间复杂度可降低至 O(1) 。例如 440. 字典序的第K小数字 ","date":"2022-03-23","objectID":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/:3:0","tags":["算法","字典树"],"title":"字典树","uri":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/"},{"categories":["算法"],"content":"代码 字典树 的实现 public class TrieNode { int count; int prefix; TrieNode[] nextNode=new TrieNode[26]; public TrieNode(){ count=0; prefix=0; } } //插入一个新单词 public static void insert(TrieNode root,String str){ if(root==null||str.length()==0){ return; } char[] c=str.toCharArray(); for(int i=0;i\u003cstr.length();i++){ //如果该分支不存在，创建一个新节点 if(root.nextNode[c[i]-'a']==null){ root.nextNode[c[i]-'a']=new TrieNode(); } root=root.nextNode[c[i]-'a']; root.prefix++;//注意，应该加在后面 } //以该节点结尾的单词数+1 root.count++; } //查找该单词是否存在，如果存在返回数量，不存在返回-1 public static int search(TrieNode root,String str){ if(root==null||str.length()==0){ return -1; } char[] c=str.toCharArray(); for(int i=0;i\u003cstr.length();i++){ //如果该分支不存在，表名该单词不存在 if(root.nextNode[c[i]-'a']==null){ return -1; } //如果存在，则继续向下遍历 root=root.nextNode[c[i]-'a']; } //如果count==0,也说明该单词不存在 if(root.count==0){ return -1; } return root.count; } //查询以str为前缀的单词数量 public static int searchPrefix(TrieNode root,String str){ if(root==null||str.length()==0){ return -1; } char[] c=str.toCharArray(); for(int i=0;i\u003cstr.length();i++){ //如果该分支不存在，表名该单词不存在 if(root.nextNode[c[i]-'a']==null){ return -1; } //如果存在，则继续向下遍历 root=root.nextNode[c[i]-'a']; } return root.prefix; } 440. 字典序的第K小数字 代码实现 class Solution { public int findKthNumber(int n, int k) { int pos = 1; k--; int step; while(k \u003e 0){ step = getStep(pos, n); if(step \u003e k){ pos *= 10; k--; }else{ k -= step; pos++; } } return pos; } public int getStep(int pos, int n){ long first = pos; long last = pos; int step = 0; while(first \u003c= n){ step += Math.min(last, n) - first + 1; first = first * 10; last = last * 10 + 9; } return step; } } ","date":"2022-03-23","objectID":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/:4:0","tags":["算法","字典树"],"title":"字典树","uri":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/"},{"categories":["算法"],"content":"参考资料 字典树 (Trie) 数据结构与算法：字典树（前缀树） 一文搞懂字典树 ","date":"2022-03-23","objectID":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/:5:0","tags":["算法","字典树"],"title":"字典树","uri":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/"},{"categories":["算法"],"content":"双指针 算法","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"前言 双指针主要用来在序列中进行遍历，其中常用方式有 快慢指针 、 对撞指针 和 滑动窗口 。可以从将暴力求解的时间复杂度 O(n^2) 降低至 O(n) ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:1:0","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"算法思想 ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:2:0","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"快慢指针 快慢指针 是指两个指针的速度移动不一致。比如一个循环内一个指针移动一位，另一个移动两位，这样在循环结束时，两个指针的移动的距离之比则是固定倍数。 快慢指针 一般用来求序列的中间位置、序列是否成环（进一步也可也求成环的初始位置），例题参考如下 剑指 Offer II 022. 链表中环的入口节点 剑指 Offer II 027. 回文链表 ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:2:1","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"对撞指针 对撞指针 是指两个指针初始在序列的不同端，并且不断的向中心进行寻找 对撞指针 一般用来求解序列两数之 ”和“（广义上指两元素之间关系） 是否满足某一条件，通常该序列一般经过特殊处理过，比如升序排列，也可以对字符串进行翻转。例题参考如下 344. 反转字符串 ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:2:2","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"滑动窗口 滑动窗口 两个指针分别为窗口的左端和右端，并按一定的条件进行有移动。 滑动窗口 按照题目的要求，可以使用固定宽度和动态宽度。该方法一般用来求解连续序列问题 ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:2:3","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"代码 快慢指针 代码参考如下 public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head; ListNode fast = head; ListNode p = head; while(fast != null){ fast = fast.next; if(fast == null){ return null; } // System.out.println(fast.val); fast = fast.next; if(fast == null){ return null; } slow = slow.next; if(fast == slow){ break; } } while(p != slow){ p = p.next; slow = slow.next; } return p; } } 对撞指针代码参考如下： class Solution { public void reverseString(char[] s) { int i=0; int j=s.length-1; while(i\u003cj){ char tmp = s[i]; s[i] = s[j]; s[j] = tmp; i++; j--; } } } 滑动窗口参考代码如下： class Solution { public int minSubArrayLen(int s, int[] nums) { int n = nums.length; if (n == 0) { return 0; } int ans = Integer.MAX_VALUE; int start = 0, end = 0; int sum = 0; while (end \u003c n) { sum += nums[end]; while (sum \u003e= s) { ans = Math.min(ans, end - start + 1); sum -= nums[start]; start++; } end++; } return ans == Integer.MAX_VALUE ? 0 : ans; } } ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:3:0","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"参考资料 和大于等于 target 的最短子数组 算法一招鲜——双指针问题 ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:4:0","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["Java 基础"],"content":"Java 一些基本优化","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java 基础"],"content":"前言 主要总结一些 java 的基本使用 持续总结中 ing ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:1:0","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java 基础"],"content":"内容 ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:0","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java 基础"],"content":"字符串拼接 字符串的拼接优先使用StringBuilder和StringBuffer类，同时在使用拼接的过程中，尽量使用一个一个的字符串进行 append ，而不是将某些字符串拼接后再 append ，例如 int n = 100; StringBuilder sb = new StringBuilder(); for(int i = 0; i \u003c n; i++){ # sb.append(i + \"#\"); sb.append(i); sb.append(\"#\"); } 不要将 i + \"#\" 拼接好后在 append ，字符串拼接后会产生的新的字符串从而产生更多的开销 ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:1","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java 基础"],"content":"Comparator类的compare方法重写 当需要在某数组某区间进行排序并且需要逆序是，则可以重写 static \u003cT\u003e void sort(T[] a, int fromIndex, int toIndex, Comparator\u003c? super T\u003e c) 方法，该方法返回类型为泛型，所以不能使用基本类型数组进行接受（数组泛型不会自动解包操作），需要使用包装类完成类型接受。 public static void mySort(Integer[] nums, int idx) { Arrays.sort(nums, 0, idx, (a, b) -\u003e Integer.compare(b, a)); } ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:2","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["算法"],"content":"Manacher 算法","date":"2022-03-21","objectID":"/posts/manacher-%E7%AE%97%E6%B3%95.html/","tags":["算法","Manacher"],"title":"Manacher 算法","uri":"/posts/manacher-%E7%AE%97%E6%B3%95.html/"},{"categories":["算法"],"content":"前言 检查字符串是否为回文序列，常用方法有 中心扩展 和 Manacher 。前者的时间复杂度为 O(n^2) ，后者算法的时间复杂度为 O(n) ，可以在线性时间的完成回文序列的判断 参考例题 剑指 Offer II 020. 回文子字符串的个数 ","date":"2022-03-21","objectID":"/posts/manacher-%E7%AE%97%E6%B3%95.html/:1:0","tags":["算法","Manacher"],"title":"Manacher 算法","uri":"/posts/manacher-%E7%AE%97%E6%B3%95.html/"},{"categories":["算法"],"content":"算法思想 Manacher 算法的主题思路是利用保存前字符串序列的最大回文半径来减少后续字符串回文与否的判定。 算法过程如下： 先将初始字符串在每个字符间增加一个间隔符号，比如 # （也包括在字符串的开头和字符串的结尾），该步骤主要是为了将偶数回文序列和奇数回文序列合并在一起进行判断。同时在字符串的开头分别加上两个不同的特殊符号，比如开头增加 $ ，结尾增加 ^ ，这两个字符充当哨兵作用 \"abab\" ---\u003e \"$#a#b#a#b$^\" 创建上述字符串的半径数组，从左往右依次计算各序号的半径，同时记录当前的字符串回文的最大右边界 rmax 和对于的序号 maxi，计算过程如下： 当该序号 i 小于等于保存的最大的右边界 rmax 时，则将当前序号的半径初始化为 r = max(rmax - i + 1, 2 * maxi - i) 反之，则直接初始化为 1 再使用 中心扩展法 判断当前半径是否为最大回文序列半径，若不是，则递增继续判断（在上一步骤中，若得到的r + i 小于最大右边界时，则 r即为当前序号的最大半径；若等于最大右边界时，则需要该步骤进行判断） 从上述步骤看，该算法是通过记录当前序号的最大半径 r 和最大右边界 rmax，减少后续序号最大半径的搜索范围，从而将时间复杂度从 O(n^2) 降低至 O(n) 。（中心扩展法 默认都是从半径为 1 依次进行判断），该算法思想与字符串KMP算法思想类似 ","date":"2022-03-21","objectID":"/posts/manacher-%E7%AE%97%E6%B3%95.html/:2:0","tags":["算法","Manacher"],"title":"Manacher 算法","uri":"/posts/manacher-%E7%AE%97%E6%B3%95.html/"},{"categories":["算法"],"content":"代码 class Solution { public int countSubstrings(String s) { int res = 0; StringBuilder sb = new StringBuilder(); sb.append(\"$#\"); for(int i = 0; i \u003c s.length(); i++){ sb.append(s.charAt(i)); sb.append(\"#\"); } sb.append('^'); int[] r = new int[sb.length()]; r[0] = 1; int max = r[0]; int maxi = 0; for(int i = 1; i \u003c r.length - 1; i++){ r[i] = i \u003c max ? Math.min(max - i + 1, r[2 * maxi - i]) : 1; while(sb.charAt(i - r[i]) == sb.charAt(i + r[i])){ r[i]++; } if(i + r[i] - 1 \u003e= max){ max = i + r[i] - 1; maxi = i; } res += r[i] / 2; } return res; } } ","date":"2022-03-21","objectID":"/posts/manacher-%E7%AE%97%E6%B3%95.html/:3:0","tags":["算法","Manacher"],"title":"Manacher 算法","uri":"/posts/manacher-%E7%AE%97%E6%B3%95.html/"},{"categories":["算法"],"content":"参考链接 Manacher 算法 回文子字符串的个数 ","date":"2022-03-21","objectID":"/posts/manacher-%E7%AE%97%E6%B3%95.html/:4:0","tags":["算法","Manacher"],"title":"Manacher 算法","uri":"/posts/manacher-%E7%AE%97%E6%B3%95.html/"},{"categories":["算法"],"content":"前缀和的原理和基本应用场景","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"前言 382. 链表随机节点 给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 被选中的概率一样 。 实现 Solution 类： Solution(ListNode head) 使用整数数组初始化对象。 int getRandom() 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。 ","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/:1:0","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"算法思想 以下内容摘自蓄水池抽样算法（Reservoir Sampling） 给定一个数据流，数据流长度N很大，且N直到处理完所有数据之前都不可知，请问如何在只遍历一遍数据（O(N)）的情况下，能够随机选取出m个不重复的数据。 ","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/:2:0","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"原理 第i个接收到的数据最后能够留在蓄水池中的概率=*第i个数据进入过蓄水池的概率***之后第i个数据不被替换的概率（第i+1到第N次处理数据都不会被替换）。 当i\u003c=m时，数据直接放进蓄水池，所以第i个数据进入过蓄水池的概率=1。 当i\u003em时，在[1,i]内选取随机数d，如果d\u003c=m，则使用第i个数据替换蓄水池中第d个数据，因此第i个数据进入过蓄水池的概率=m/i。 当i\u003c=m时，程序从接收到第m+1个数据时开始执行替换操作，第m+1次处理会替换池中数据的为m/(m+1)，会替换掉第i个数据的概率为1/m，则第m+1次处理替换掉第i个数据的概率为(m/(m+1))(1/m)=1/(m+1)，不被替换的概率为1-1/(m+1)=m/(m+1)。依次，第m+2次处理不替换掉第i个数据概率为(m+1)/(m+2)…第N次处理不替换掉第i个数据的概率为(N-1)/N。所以，之后**第i个数据不被替换的概率=m/(m+1)(m+1)/(m+2)…(N-1)/N=m/N**。 当i\u003em时，程序从接收到第i+1个数据时开始有可能替换第i个数据。则参考上述第3点，之后第i个数据不被替换的概率=i/N。 结合第1点和第3点可知，当i\u003c=m时，第i个接收到的数据最后留在蓄水池中的概率=1m/N=m/N。结合第2点和第4点可知，当i\u003em时，第i个接收到的数据留在蓄水池中的概率=m/ii/N=m/N。综上可知，每个数据最后被选中留在蓄水池中的概率为m/N。 ","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/:2:1","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"拓展 假设有K台机器，将大数据集分成K个数据流，每台机器使用单机版蓄水池抽样处理一个数据流，抽样m个数据，并最后记录处理的数据量为N1, N2, …, Nk, …, NK(假设m\u003cNk)。N1+N2+…+NK=N。 取[1, N]一个随机数d，若d\u003cN1，则在第一台机器的蓄水池中等概率不放回地（1/m）选取一个数据；若N1\u003c=d\u003c(N1+N2)，则在第二台机器的蓄水池中等概率不放回地选取一个数据；一次类推，重复m次，则最终从N大数据集中选出m个数据。 验证如下： 第k台机器中的蓄水池数据被选取的概率为m/Nk。 从第k台机器的蓄水池中选取一个数据放进最终蓄水池的概率为Nk/N。 第k台机器蓄水池的一个数据被选中的概率为1/m。（不放回选取时等概率的） 重复m次选取，则每个数据被选中的概率为m*(m/Nk*Nk/N*1/m)=m/N ","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/:3:0","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"代码 class Solution { ListNode head; Random random; public Solution(ListNode head) { this.head = head; random = new Random(); } public int getRandom() { int i = 1, ans = 0; for (ListNode node = head; node != null; node = node.next) { if (random.nextInt(i) == 0) { // 1/i 的概率选中（替换为答案） ans = node.val; } ++i; } return ans; } } ","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/:4:0","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"参考链接 蓄水池抽样算法（Reservoir Sampling） 382. 链表随机节点 ","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/:5:0","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"前缀和的原理和基本应用场景","date":"2022-03-18","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/","tags":["算法","前缀和"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/"},{"categories":["算法"],"content":"前言 在算法中，如果需要求一些连续数组成的集合，可以使用前缀和对结果进行存储，从而避免暴力搜索，利用空间复杂度换取时间复杂度 例如leetcode中的 剑指 Offer II 008. 和大于等于 target 的最短子数组 ","date":"2022-03-18","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/:1:0","tags":["算法","前缀和"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/"},{"categories":["算法"],"content":"算法思想 创建一个前缀数组 pre[n] ，其中 pre[i] 表示前 i 个数组所构成的数据结果，例如对于 剑指 Offer II 008. 和大于等于 target 的最短子数组 题目，则可以表示为前 i 个元素和。因为是求连续数组，则可以通过 pre[j] - pre[i] 表示任意第 i 个元素到第 j 个元素的的连续数组，即使用前缀和来减少暴力搜索的时间复杂度，这样算法的时间复杂度为O(N^2)，空间复杂度为 O(N) ","date":"2022-03-18","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/:2:0","tags":["算法","前缀和"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/"},{"categories":["算法"],"content":"再优化 尽管使用了前缀和思想，可以将时间复杂度降至O(N^2)，但在 n足够大时，仍然会出现超时情况。为此，可以根据题目的不同要求，在求前缀和的过程中，使用其他数据结构将所需要的数据进行保存，比如使用 HashMap 。这在后续求解时，可以使用 O(1) 的时间复杂度进行求解，例如在 剑指 Offer II 011. 0 和 1 个数相同的子数组 题目当中，使用 Key 将结果作为索引 ，位置信息作为 Value 进行保存 ","date":"2022-03-18","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/:3:0","tags":["算法","前缀和"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/"},{"categories":["算法"],"content":"代码 剑指 Offer II 008. 和大于等于 target 的最短子数组 示例参考代码如下 class Solution { public int minSubArrayLen(int s, int[] nums) { int n = nums.length; if (n == 0) { return 0; } int ans = Integer.MAX_VALUE; int[] sums = new int[n + 1]; // 为了方便计算，令 size = n + 1 // sums[0] = 0 意味着前 0 个元素的前缀和为 0 // sums[1] = A[0] 前 1 个元素的前缀和为 A[0] // 以此类推 for (int i = 1; i \u003c= n; i++) { sums[i] = sums[i - 1] + nums[i - 1]; } for (int i = 1; i \u003c= n; i++) { int target = s + sums[i - 1]; int bound = Arrays.binarySearch(sums, target); if (bound \u003c 0) { bound = -bound - 1; } if (bound \u003c= n) { ans = Math.min(ans, bound - (i - 1)); } } return ans == Integer.MAX_VALUE ? 0 : ans; } } ","date":"2022-03-18","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/:4:0","tags":["算法","前缀和"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/"},{"categories":["算法"],"content":"参考链接 剑指 Offer II 008. 和大于等于 target 的最短子数组 ","date":"2022-03-18","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/:5:0","tags":["算法","前缀和"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/"},{"categories":["常用软件"],"content":"aria2 的基本安装和使用","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["常用软件"],"content":"前言 最近节点也不知道怎么了，从谷歌云盘下载东西时，经常因为断流而导致下载中断，导致我的大文件几乎就下不下来，网上找了下解决方法，最后选择aria2，一个支持断点续传的软件 aria2 是一个轻量级的多协议和多源命令行下载实用程序。它支持 HTTP/HTTPS、FTP、BitTorrent 和 Metalink。 aria2 可以通过内置的 JSON-RPC 和 XML-RPC 接口进行操作。 ","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/:1:0","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["常用软件"],"content":"安装 aria2 可以在Arch的官方仓库找到 sudo pacman -S aria2 同时 archlinuxcn 源和 AUR 仓库都存在对原版 aria2 补丁的 aria2-fast，原版设置了16线程的上线，该补丁版本最多可以设置为128线程 yay -S aria2-fast ","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/:2:0","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["常用软件"],"content":"配置 aria2 默认配置文件位于 $HOME/.aria2/aria2.conf ，具体配置内容可以参考arch wiki 或者 P3TERX 大佬的 注意：若开启了 session,需要手动创建对应的 aria2.session 文件，否则 daemon 启动不了 ","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/:3:0","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["常用软件"],"content":"设置daemon 一般情况下，aria2 下载完成后便会退出，因此我们可以使用守护单元，在开机后自动在后台保持允许即可 用户级别的 systemd unit 位于 $HOME/.config/systemd/usr 目录下，系统级别的在 /etc/systemd/system 目录下，根据自己情况选择。本教程采用用户级别 编辑对应目下的aria2.service，配置内容如下 [Unit] Description=aria2 Daemon [Service] Type=simple ExecStart=/usr/bin/aria2c --conf-path=${HOME}/.config/aria2/aria2.conf [Install] WantedBy=default.target 接着设置后台自启并立即启动 systemctl enable --user now aria2.service ","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/:4:0","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["常用软件"],"content":"浏览器配置 AriaNG 是较为主流的 aria2 前端，其中有第三方在此基础之上实现的浏览器插件，比如 Chrome和 Firefox 根据配置文件的设置的RPC服务器的密码，在插件中配置好相应的 rpc-secret，同时可以在扩展选项中设置对浏览器的下载进行拦截，统一交给 aria2 服务进行下载 插件设置内容如下图所示 }} -- 至此，完成了 aria2 的基本设置 ","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/:5:0","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["常用软件"],"content":"参考资料 Archlinux aria2 Aria2 前端面板 ( GUI、WebUI ) AriaNg 使用教程 Arch Linux 的 Aria2 食用指南 ","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/:6:0","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["Linux"],"content":"Archlinux 开机磁盘自动解密","date":"2022-03-08","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/","tags":["archlinux","LUKS"],"title":"Archlinux自动解密磁盘","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"前言 由于我的Archlinux使用了LUKS进行磁盘加密，所以在启动系统时，必须输入两次密码，一次是加密磁盘的密码，另一次是用户密码 为了减少每次进入输入系统输入两次密码的麻烦，可以设置开机后自动解锁磁盘 ","date":"2022-03-08","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:1:0","tags":["archlinux","LUKS"],"title":"Archlinux自动解密磁盘","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"加密磁盘 加密磁盘操作具体可以参照Archlinux基础系统安装 ","date":"2022-03-08","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:2:0","tags":["archlinux","LUKS"],"title":"Archlinux自动解密磁盘","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"开机磁盘解密 ","date":"2022-03-08","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:3:0","tags":["archlinux","LUKS"],"title":"Archlinux自动解密磁盘","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"配置开机钩子 开机解密，需要配置开机的钩子(Hook)，根据解密钩子的方式可以分为encrypt hook和sd-encrypt hook，其中后者特性更多，因此采用后者进行解密。编辑/etc/mkinitcpio.conf文件 ，将udev更换为systemd，并添加sd-vconsole和sd-encrypt 修改前 HOOKS=(base udev autodetect keyboard modconf block filesystems fsck) 修改后为 HOOKS=(base systemd autodetect keyboard sd-vconsole modconf block sd-encrypt filesystems fsck) 在FILES=()这一栏中添加开机解密密钥的文件所在的位置 FILES=(/path/to/keyfile) 配置完后，重新生成mkinitcpio配置文件 mkinitcpio -P ","date":"2022-03-08","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:3:1","tags":["archlinux","LUKS"],"title":"Archlinux自动解密磁盘","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"配置内核参数 开机解密磁盘需要告诉内核加密磁盘所在的位置，所以需要配置对应的内核参数，编辑/etc/default/grub文件，在GRUB_CMDLINE_LINUX_DEFAULT或者GRUB_CMDLINE_LINUX参数栏中增加需要添加的内核参数，前者在每次开机都会进行加载，而后者在紧急启动进入系统时则不会加载，所以建议添加在前者栏中 rd.luks.uuid=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX，使用此标志指定要在启动时解密的设备的UUID rd.luks.name=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX=name，指定加密磁盘的UUID和解密后的磁盘名，使用了该内核参数，则可以省略上面的uuid参数 rd.luks.key=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX=/path/to/keyfile，使用keyfile进行系统解密，并传入keyfile的文件位置 rd.luks.options=options，设置解密参数，可选设置。如果是SSD，可以使用discard参数提供TRIM功能 root=/dev/mapper/cryptroot: 指定解密设备，该参数不管是encrypt还是sd-crypt，都必须要设置 其中UUID获取指令如下，获取的是解密前的磁盘UUID，而不是解密后的磁盘UUID lsblk -f └─nvme0n1p2 crypto 2 a0ea985c-f2c0-4c6c-af66-2bc10a158b0a └─cryptroot ext4 1.0 96055a51-9138-431a-8976-845ca1d09e20 上述查询结果中，a0ea985c-f2c0-4c6c-af66-2bc10a158b0a才是我们需要的UUID参数 注意：这和休眠设置的UUID参数不同，休眠需要的是解密后的UUID 如下示例: GRUB_CMDLINE_LINUX_DEFAULT=\"rd.luks.name=a0ea985c-f2c0-4c6c-af66-2bc10a158b0a=cryptroot rd.luks.options=timeout=10s,discard rd.luks.key=a0ea985c-f2c0-4c6c-af66-2bc10a158b0a=/etc/mykeyfile root=/dev/mapper/cryptroot\" 修改后，重新生成grub的配置文件 grub-mkconfig -o /boot/grub/grub.cfg 至此，重启开机便可以自动使用密钥进行解锁，而需要手动输入密码进行解锁磁盘了。 ","date":"2022-03-08","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:3:2","tags":["archlinux","LUKS"],"title":"Archlinux自动解密磁盘","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"参考资料 dm-crypt/System configuration 让系统更安全 - 系统分区加密 (Btrfs on LUKS) 操作实录 ","date":"2022-03-08","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:4:0","tags":["archlinux","LUKS"],"title":"Archlinux自动解密磁盘","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["YADM"],"content":"Yadm 对 dotfiles 文件的基本使用方法","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["YADM"],"content":"前言 在linux系统下，配置文件一般都是以.符号开头的，因此也被称为 dotfles。github有他人分享的配置，我们可以从中找到适合自己的配置文件 为了方便管理自己系统系统的配置文件，可以使用工具来对这些 dotfiles 进行统一管理。根据 arch wiki，常用的管理方式主要分为两种，软链接和git跟踪点文件，以下是 github 仓库中用的较多的工具 stow: GNU产品，使用软链进行管理，arch的farseerfc大佬就是使用该工具进行管理，具体介绍可以参照他的博客使用GNU stow 管理你的点文件 git bare: 使用git bare裸仓库进行管理 yadm: Yet Another Dotfiles Manager，一个git的wrapper，底层仍然是使用git来进行管理，方法使用和git没有区别，可以对特定文件加密 chezmoi: 和git用法差不多，但是会将需要跟踪的点文件冗余存储在chezmoi特定的本地仓库，可以对特定文件加密 为了保持和 git 的使用习惯，最后选择yadm作为点文件的管理工具，yadm默认相对位置为自己的家目录($HOME) ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:1:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["YADM"],"content":"安装 Archlinux sudo pacman -S yadm Ubuntu/Debian sudo apt install -y yadm OSX brew install yadm ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:2:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["YADM"],"content":"仓库初始化 ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:3:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["YADM"],"content":"初始化本地仓库 如果一开始没有远程的 dotfiles 仓库，则需要先初始化本地仓库 yadm init yadm add \u003cimportant file\u003e yadm commit 再将本地仓库与远程仓库进行同步 yadm remote add origin \u003curl\u003e yadm push -u origin main ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:3:1","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["YADM"],"content":"同步远程仓库 若一开始就有远程仓库，或使用他人的 yadm 的远程仓库时，则将远程仓库克隆下来即可 yadm clone \u003curl\u003e yadm status ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:3:2","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["YADM"],"content":"基本使用 ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:4:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["YADM"],"content":"添加需要跟踪的配置文件 使用 add 方法，将 dotfile 添加至 yadm 跟踪 list 当中 yadm add /path/to/dotfile ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:4:1","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["YADM"],"content":"跟踪列表查看 使用 list 方法，查看当前路径下的跟踪文件，使用 -a 参数(Optional)，可以查看所有跟踪文件 yadm list \u003c-a\u003e ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:4:2","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["YADM"],"content":"推送至远程仓库 使用commit和push方法，将变化文件推送至远程仓库 git commit -m \"commit word\" git push -u origin main ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:4:3","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["YADM"],"content":"文件加密和解密 在$HOME/.config/yadm/encrypt文件中设置需要加密的文件，支持正则表达式，默认文件的起始地址为%HOME目录下，$HOME/.config/yadm/encrypt参考格式如下 .ssh/*.key yadm支持gpg的对称加密和非对称加密，默认加密方式为gpg的对称加密，加密后的文件存储于 $HOME/.local/share/yadm/archive 文件当中， yadm add $HOME/.config/yadm/encrypt yadm add $HOME/.local/share/yadm/archive 也可以通过 yadm config yadm.gpg-recipient \u003crecipient-address\u003e 指令指定使用非对称加密 yadm config yadm.gpg-recipient \u003crecipient-address\u003e chezmoi 不同的是，yadm 需要将文件手动进行解密，若使用对称加密，则按提示输入密码既可进行解密 注：系统没有 gunpg 则，则无法解密 yadm decrypt ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:5:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["YADM"],"content":"引导程序 yadm 支持在初始化仓库时，自动调用 Bootstrap 程序执行初始化，该文件默认位置为$HOME/.config/yadm/bootstrap，且该文件必须为可执行程序 在初始化时，如果系统本身就含有 yadm 仓库对应的点文件时，yadm 默认是不会处理该文件，即不会覆盖，需要用户自己手动处理该冲突，对于引导程序，除了初始化执行时，也可以手动执行引导程序，来进行引导程序的调试 yadm bootstrap ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:6:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["YADM"],"content":"参考资料 Archlinux Dotfiles Yet Another Dotfiles Manager 使用Yadm来管理我的配置 使用GNU stow 管理你的点文件 ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:7:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"Clash 在 linux 下的的基本安装和使用","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/","tags":["Clash"],"title":"Clash安装与使用","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["常用软件"],"content":"前言 Clash 是一个跨平台、支持 SS/V2ray 等协议、基于规则的网络代理软件 Clash 只是一个内核，为开源软件，而 Clash-premium 是闭源软件，后者多了scripts，rule-set和tun(windows只能使用该功能实现全局代理) 从clash的内核衍生了众多版本，用的最多的有 Clash for windows (简称 cfw )，Open Clash，Clashx。其中cfw不仅支持windows，还支持macos和linux，open Clash只支持路由器的openwrt系统，Clashx只支持macos ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:1:0","tags":["Clash"],"title":"Clash安装与使用","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["常用软件"],"content":"安装 在 arch 的官方仓库当中有根据 clash 内核打包好的组件，aur社区有打包好的 cfw 和 clash-user。其中cfw有ui界面，与 windows 上设置没有什么区别，而 clash-user 自带 clash 用户，可以根据用户的 uid 来设置防止流量回环 由于 linux 可以使用 tproxy 实现全局代理，可以直接使用官方仓库的 clash (或者 aur 的 clash-user ），来减少 clash 的资源占用( cfw 的 gui 需要占用资源) sudo pacman -S clash 使用yacd面板对Clash管理和流量监控 yay -S yacd ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:2:0","tags":["Clash"],"title":"Clash安装与使用","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["常用软件"],"content":"文件配置 clash 默认的配置文件位于用户目录下，而 clash-user 的配置位于/etc/clash目录下 配置中主要参数解释： port: http(s)代理端口 socks-port: socks5代理端口 redir-port: redir tcp代理端口 tproxy-port: tproxy udp(tcp)代理端口 mode: 代理方式，有全局代理(gloable)、规则代理(rule)和直连(direct)。其rle根据配置所提供的规则流量代理 external-controller: clash提供的api控制地址 external-ui: 外部控制ui地址 profile: clash部分存储设置模块 store-selected: 策略组节点选择后，是否需要存储选择记录，默认不存储(false) store-fake-ip: 设置为 true 是，将 fake-ip 与真实 dns 的 ip 对应记录存储在本地，以达到持久存储 dns 记录，加快 dns 解析速度 dns: clash的dns模块 enable: 设置为 true 时开启 clash 内置的dns模块 listen: dns 的监听端口 enhanced-mode: clash 提供两种 dns 查询模式，一种为正常 redir 转发模式，另一种为 fake-ip 模式，每次应用 dns 请求时，clash 将返回一个 fake 的 ip 地址，来达到加速建立 tcp 连接需求，但也会导致得到的 ip 不是真实的 ip，从而对某些网络调试带来麻烦 nameserver: dns 查询服务器，可以设置为 doh，tls 等dns查询方式。具体可以根根据个人习惯设置 fake-ip-filter: 过滤不使用 fake-ip 查来询dns的地址 proxies: 代理节点设置模块，请根据官方要求进行设置 proxy-groups: clash 的策略组，与 surge 类似。包含 relay(轮询)，url-test(ping最低优先)，load-balance(负载均衡)，fallback(按节点顺序优先使用可用节点)，select(手动选择节点) proxy-providers: 节点提供模块，一次可以提供多个级诶但，clash的1.9.0中增加了filter用来过滤节点 type: 节点组提供的类型，可选 http (远程提供)和 file (本地文件提供) filter: 节点过滤方式，支持正则 rules: 规则模块，以下是官方提供的说明，可以根据需要进行规则设置 DOMAIN: 规则会匹配与请求完全相同的地址 DOMAIN-SUFFIX: 规则会匹配与请求与主域名相同的地址，比如，google.com匹配www.google.com, mail.google.com和google.com本身，但不会匹配content-google.com DOMAIN-KEYWORD: 规则会匹配包含相应关键字的域名，除了 “apple” 会匹配 www.apple.com，“app” 同样也会匹配到 GEOIP: 规则会匹配相应国家和地区的 IP 地址 IP-CIDR: 规则会匹配规则范围内请求的 IP 地址 IP-CIDR6: 规则会匹配规则范围内请求的 IPv6 地址 SRC-IP-CIDR: 规则会匹配源 IP 地址 SRC-PORT: 规则会匹配源端口地址 DST-PORT: 规则会匹配目的地端口地址 PROCESS-NAME: 规则会匹配这个进程名的程序 MATCH: 将其余数据包路由到策略。此规则是必需的 以下为本人根据 clash 提供的官方配置进行更改的自用配置。dns 设置为 fake-ip 模式，dns 服务器均采用 doh，防止国内而 dns 污染，并使用 yacd 模块。因为 clash 开源版不支持rule-set模块(clash-premium支持)，所以不能像 surge 一样简洁书写规则，嫌规则冗长的可以使用 clash-premium 闭源软件书写，其他模块书写规则一致 mixed-port:7890allow-lan:truemode:Rulelog-level:warningexternal-controller:127.0.0.1:9090socks-port:7891redir-port:7892tproxy-port:7893ipv6:falseexternal-ui:'/usr/share/yacd'profile:store-selected:falsestore-fake-ip:truedns:enable:truelisten:0.0.0.0:1053enhanced-mode:fake-ipfake-ip-range:198.18.0.1/16nameserver:- https://223.5.5.5/dns-query- https://doh.pub/dns-query#- 114.114.114.114#- 223.5.5.5fallback:- https://1.1.1.1/dns-query- https://1.0.0.1/dns-query- https://8.8.8.8/dns-queryfallback-filter:geoip:truegeoip-code:CNfake-ip-filter:- '*.lan'- '*.localhost'- '*.local'- 'lens.l.google.com'- 'stun.l.google.com'- '*.gitbook.io'proxy-providers:HK_LOW:type:filepath:./cordcloud.yamlinterval:3600filter:'长沙联通转香港|广东移动转香港'health-check:enable:trueurl:http://wifi.vivo.com.cn/generate_204interval:600HK:type:filepath:./cordcloud.yamlinterval:3600filter:'深港专线'health-check:enable:trueurl:http://wifi.vivo.com.cn/generate_204interval:600TW:type:filepath:./cordcloud.yamlinterval:3600filter:'台湾'health-check:enable:trueurl:http://wifi.vivo.com.cn/generate_204interval:600JP:type:filepath:./cordcloud.yamlinterval:3600filter:'日本'health-check:enable:trueurl:http://wifi.vivo.com.cn/generate_204interval:600SG:type:filepath:./cordcloud.yamlinterval:3600filter:'新加坡'health-check:enable:trueurl:http://wifi.vivo.com.cn/generate_204interval:600US:type:filepath:./cordcloud.yamlinterval:3600filter:'美国'health-check:enable:trueurl:http://wifi.vivo.com.cn/generate_204interval:600proxy-groups:- name:Finaltype:selectproxies:- Proxies- DIRECT- name:Proxiestype:selectproxies:- load_balance- hk_urltest- tw_urltest- sg_urltest- us_urltest- name:StreamSEtype:selectproxies:- load_balance- hk_urltest- tw_urltest- sg_urltest- us_urltest- name:Googletype:selectproxies:- hk_fallback- hk_urltest- tw_urltest- sg_urltest- Proxies- name:Telegramtype:selectproxies:- sg_urltest- hk_urltest- tw_urltest- Proxies- name:load_balancetype:load-balanceurl:http://wifi.vivo.com.cn/generate_204interval:300proxies:use:- HK_LOW- name:hk_urltesttype:url-testurl:http://wifi.vivo.com.cn/generate_204interval:300proxies:use:- HK_LOW- name:hk_fallbacktype:fallbackurl:http://wifi.vivo.com.cn/generate_204interval:300proxies:use:- HK- name:us_urltesttype:url-testurl:http://wifi.vivo.com.cn/generate_204in","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:3:0","tags":["Clash"],"title":"Clash安装与使用","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["常用软件"],"content":"TProxy代理设置 采用clash官方推荐的wiki的防火墙设置，来拦截流量，由于udp不支持redir，所以tcp采用redir，udp采用tproxy(也都可以采用tproxy)，dns拦截端口为上述文件设置的1053，将dns的udp查询均转发至1053端口 为了防止clash代理自身流量，有两种常用方式避免流量回环，cgroup和uid。第一种方式将clash加入特定cgroup足，比如自定义的noproxy组，第二种方式为使用clash用户来启动clash进程。接着使用iptables来匹配对于流量 官方推荐wiki的iptables规则如下 #tcp iptables -t nat -N clash iptables -t nat -A clash -d 0.0.0.0/8 -j RETURN iptables -t nat -A clash -d 10.0.0.0/8 -j RETURN iptables -t nat -A clash -d 127.0.0.0/8 -j RETURN iptables -t nat -A clash -d 169.254.0.0/16 -j RETURN iptables -t nat -A clash -d 172.16.0.0/12 -j RETURN iptables -t nat -A clash -d 192.168.0.0/16 -j RETURN iptables -t nat -A clash -d 224.0.0.0/4 -j RETURN iptables -t nat -A clash -d 240.0.0.0/4 -j RETURN iptables -t nat -A clash -p tcp -j REDIRECT --to-port 7892 iptables -t nat -I PREROUTING -p tcp -d 8.8.8.8 -j REDIRECT --to-port 7892 iptables -t nat -I PREROUTING -p tcp -d 8.8.4.4 -j REDIRECT --to-port 7892 iptables -t nat -A PREROUTING -p tcp -j clash iptables -t nat -A OUTPUT -p tcp -d 198.18.0.0/16 -j REDIRECT --to-port 7892 #udp ip rule add fwmark 1 table 100 ip route add local default dev lo table 100 iptables -t mangle -N clash iptables -t mangle -A clash -d 0.0.0.0/8 -j RETURN iptables -t mangle -A clash -d 10.0.0.0/8 -j RETURN iptables -t mangle -A clash -d 127.0.0.0/8 -j RETURN iptables -t mangle -A clash -d 169.254.0.0/16 -j RETURN iptables -t mangle -A clash -d 172.16.0.0/12 -j RETURN iptables -t mangle -A clash -d 192.168.0.0/16 -j RETURN iptables -t mangle -A clash -d 224.0.0.0/4 -j RETURN iptables -t mangle -A clash -d 240.0.0.0/4 -j RETURN iptables -t mangle -A clash -p udp -j TPROXY --on-port 7893 --tproxy-mark 1 iptables -t mangle -A OUTPUT -p udp -d 198.18.0.0/16 -j MARK --set-mark 1 iptables -t mangle -A PREROUTING -p udp -j clash iptables -t nat -N CLASH_DNS iptables -t nat -F CLASH_DNS iptables -t nat -A CLASH_DNS -p udp -j REDIRECT --to-port 1053 iptables -t nat -I OUTPUT -p udp --dport 53 -j CLASH_DNS iptables -t nat -I PREROUTING -p udp --dport 53 -j REDIRECT --to 1053 # 以下二选一 # 使用noproxy的cgroup组来防止流量回环 iptables -t mangle -A OUTPUT -m cgroup --path \"noproxy.slice\" -j RETURN # 使用uid来防止流量回环 # iptables -t mangle -A clash-self -m owner --uid-owner clash -j RETURN ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:4:0","tags":["Clash"],"title":"Clash安装与使用","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["常用软件"],"content":"iptables规则持久化 iptables 规则在每次系统重启后，都会进行复原，因此如果设置错误导致无法上网时，可以删除防火墙对应规则或直接重启电脑解决 为了让iptables规则持久化，可以设置一个开机自启服务，自动运行对应脚本以设置防火墙。将上述 iptables 规则保存为为 iptables.sh ，并创建 /etc/systemd/system/tproxy.service，编辑设置内容如下 [Unit] Description=Setup ip-rule and ip-route for tproxy local network traffic. Before=network-pre.target Wants=network-pre.target [Service] Type=oneshot ExecStart=/bin/bash /path/to/iptables.sh RemainAfterExit=yes [Install] WantedBy=multi-user.target 设置服务开机自启 sudo systemctl enable tproxy.service ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:5:0","tags":["Clash"],"title":"Clash安装与使用","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["常用软件"],"content":"启动服务 clash 需要部分网络代理能力，编辑 clash@ 服务文件，添加 clash 的 capability 能力， sudo systemctl edit clash@.service 添加如下内容 CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW 让应用可以处理 TProxy 带来的流量 CAP_NET_BIND_SERVICE 允许应用绑定 1000 以下的端口 如果采用 cgroup 防止流量回环，还需要设置该服务所对应的 Slice，采用 UID 识别的话，则需要设置该服务的启动 USER，二选一即可，也可以同时都设置。若设置 UID 时，必须保证系统存在相应用户名 # cgroup Slice = noproxy.slice # UID User = username 同时设置 clash@$USER 服务后台自动，并立即启动 sudo systemctl enable --now clash@$USER.service ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:6:0","tags":["Clash"],"title":"Clash安装与使用","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["常用软件"],"content":"docker流量问题解决 为了解决 cgproxy 代理 bridge 联网的 docker 无法联网问题，需要进行如下而外设置 sysctl -w net.bridge.bridge-nf-call-iptables=0 sysctl -w net.bridge.bridge-nf-call-ip6tables=0 sysctl -w net.bridge.bridge-nf-call-arptables=0 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:7:0","tags":["Clash"],"title":"Clash安装与使用","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["常用软件"],"content":"参考资料 Clash github Wik Unofficial Clash Wiki clash-win-docs-new 容器(docker)桥接(bridge)模式时的代理问题 如何使用 Clash 的 TPROXY 功能进行透明代理 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:8:0","tags":["Clash"],"title":"Clash安装与使用","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"Archlinux 的KDE桌面系统安装","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"前言 作为主力系统，自然需要桌面系统(DE)。主流DE有KDE和GNOME等，根据个人习惯选择系统。本文主要介绍KDE桌面系统的安装 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:1:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"联网 由于桌面系统还没有安装完成，所以采用iwd和dhcpcd进行网络连接，首先启动iwd和dhcpcd，在使用iwd连接无限网络。iwd参照基础系统安装教程 systemctl start iwd systemctl start dhcpcd ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:2:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"准备普通用户 由于桌面系统需要普通用户，故先添加普通用户，并配置相应的权限 useradd -m -G wheel -s /bin/bash username passwd username 配置sudo权限 EDITOR=vim visudo 找到下面该行，并取消注释 #%wheel ALL=(ALL) ALL ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:3:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"安装KDE环境 KDE安装有三个包组，plasma-meta、plasma和plasma-desktop。其中plasma和plasma-meta区别为，kde后续增加软件包时，plasma-meta会自动安装，而plasma不会，剩下plasma-desktop只有kde能跑起来最少的软件。推荐使用plasma-meta，防止后续缺少组件。konsole和dolphin分别为kde的常用终端和文件管理 pacman -S plasma-meta konsole dolphin ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:4:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"启用DM kde默认自带sddm，可以根据需要更换 systemctl enable sddm ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:5:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"启用网络管理组件 kde和gnome桌面系统一般采用NetworkManager进行网络管理 systemctl enable NetworkManager ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:6:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"重启进入桌面系统 自此，基本的桌面系统已经安装完成，可以重启进入桌面系统 reboot ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:7:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"AUR Helper安装 yay和paru是较为常用的aur helper组件，根据个人习惯进行选择 注：由于安装需要从github拉取文件，需要配置代理才可以进行 git clone https://aur.archlinux.org/yay.git cd yay makepkg -si ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:8:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"输入法安装 facitx5为社区推荐输入法，安装facitx5 sudo pacman -S fcitx5-im sudo pacman -S fcitx5-chinese-addons fcitx5-pinyin-zhwiki fcitx5-material-colo 配置环境，konsole和dolphin需要环境变量的支持才可以使用输入法，使用EDITOR=vim sudoedit /etc/environment进行添加环境变量 GTK_IM_MODULE=fcitx QT_IM_MODULE=fcitx XMODIFIERS=@im=fcitx SDL_IM_MODULE=fcitx ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:9:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"配置默认编辑器 arch默认编辑器为vi，一般使用vim，使用EDITOR=vim sudoedit /etc/profile配置环境变量 export EDITOR='vim' ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:10:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"蓝牙配置 安装并配置蓝牙 sudo pacman -S bluez bluez-utils pulseaudio-bluetooth pavucontrol pulseaudio-alsa yay -S bluez-firmware sudo systemctl enable bluetooth.service sudo systemctl start bluetooth.service pulseaudio -k pulseaudio --start sudo usermod -a -G lp $USER 设置蓝牙自启，编辑/etc/bluetooth/main.conf文件，更改AutoEnable的值为true sudo vim /etc/bluetooth/main.conf ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:11:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"KDE安装完成 自此，arch的KDE系统基本完成安装。 KDE是可以根据自己的需要进行高度定制化，可以根据自己的需要进行定制化 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:12:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"参考资料 Archlinux Installation guide Arch Linux 安装使用教程 - ArchTutorial - Arch Linux Studio 2021 Archlinux双系统安装教程（超详细） Arch Linux Monthly Install: January 2022 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:13:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"Archlinux 的基本安装","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"前言 第一次使用linux系统，查询linux各个版本的区别，最后看上了arch的aur，故选择arch作为主力linux系统(人的生命在于折腾，折腾就完事了) 这篇主要记录了基本系统的安装，不包含桌面系统 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:1:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"EFI模式验证 首先确认安装模式是否为EFI模式 ls /sys/firmware/efi/efivars ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:2:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"系统时钟校正 timedatectl set-ntp true ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:3:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"进行网络连接 arch系统网络连接方式主要有两种，有线连接和无线连接 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:4:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"有线连接 可以使用手机线与电脑进行连接，进行网络共享 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:4:1","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"无线连接 arch live系统默认为开启iwd,使用iwd进行无线网络连接 iwctl device list station wlan0 get-networks station waln0 connect WIFI-NAME 首先进入iwctl模式，查询当前设备无线网卡设备名,比如wlan0），再使用网卡查询当前wifi网络情况，最后对目标WIFI-NAME进行连接，提示输入密码进行确认 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:4:2","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"数据分区及格式化 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:5:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"分区 常见分区工具有cfdisk,gdisk等。为了方便，可以使用GUI的cfdisk进行分区 为了防止某些异常，优先对efi进行分区，大小500M～1G即可 剩下分区方式根据个人习惯进行。 比以将home分区单独分区，缺点是home分区和其他分区大小需要控制好，防止某分区空间爆满而需要对文件系统挪动， 将剩余分区大小划分为一个分区，缺点是重装系统麻烦 为了节省存储空间，故采用第二种方式。分区完成后，对主分区进行加密(Optional) ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:5:1","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"加密(可选) 为了保证自己的数据安全，可以对主要分区内容进行加密，防止他人挂载直接进入系统读取文件。 使用LUKS对主分区进行加密，没有特殊要求采用默认参数即可 默认使用手动输入密码对文件进行加密 cryptsetup -y -v luksFormat /path/to/device 使用keyfile对文件进行加密 首先生成所需要的keyfile文件，根据生成keyfile文件的类型不同，可以分为密码方式和随机字符或二进制。 为了简便，采用密码对文件进行加密，并将密码制作为keyfile,用作开机自动解密。 echo -n 'your_passphrase' \u003e /etc/keyfile chown root:root /etc/keyfile; chmod 400 /etc/keyfile 解密分区 cryptroot 为解密后对应的文件名，可以自定义 cryptsetup open /path/to/device/ cryptroot ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:5:2","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"格式化 efi分区采用mkfs.fat进行格式化。主分区根据不同的文件类型特性进行选择格式化，比如mkfs.ext4格式化为ext4,mkfs.btrfs格式化为btrfs，其中ext4速度整体快于btrfs,而btrfs存在快照等特性。 mkfs.fat -F 32 /path/to/efi mkfs.ext4 /path/to/device ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:5:3","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"挂载分区，并安装基本软件 先挂载/mnt分区，在创建/mnt/boot分区，并挂载(也可以创建/mnt/efi分区并进行挂载，二者不同之处可以查看archwiki) mount /dev/mapper/cryptroot /mnt mount /path/to/efi /mnt/boot 其中cryptroot为解密后分区所对应的名字，挂载时需要选择解密后的分区名 使用pacstarp在/mnt分区中安装基本软件，并生成分区文件，最后进入安装系统(根据电脑CPU类型安装所需要的微码，intel的cpu安装intel-ucode，amd的安装amd-ucode) pacstarp /mnt base base-devel linux linux-headers linux-firmware sudo amd-ucode genfstab -U /mnt \u003e\u003e /mnt/etc/fstab arch-chroot /mnt ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:6:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"更改镜像源并启用32位库 由于国外镜像站网速限制，可以使用国内教育镜像站进行加速，镜像配置文件为/etc/pacman.d/mirrorlist，可以设置多个镜像站 Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch 由于部分软件需要32位库，比如wine,而默认32位库是注释掉了，需要取消注释才能启用，不需要32位软件的可以不进行该操作。pacman的默认库文件位/etc/pacman.conf，取消注释multilib库 [multilib] Server = /etc/pacman.d/mirrorlist ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:7:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"修改密码 修改root的密码 passwd ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:8:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"基础软件安装 安装基础软件，比如网络，编辑器等 pacman -S networkmanager vim git wget curl dhcpcd iwd bash-completion dialog wpa_supplicant ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:9:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"时区和区域设置 使用软链设置时区，比如设置位亚洲的上海时区，并同步 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc 区域设置，对应文件位/etc/locale.gen，编辑并取消所需要的区域设置，并生成对应文件 vim /etc/locale.gen # 取消en_US.UTF-8和zh_CN.UTF-8的注销 locale-gen 向/etc/locale.conf导入本地语言设置，防止乱码 echo 'LANG=en_US.UTF-8' \u003e /etc/locale.conf ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:10:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"主机名设置 编辑/etc/hostname，设置主机名，比如arch，并根据主机名设置host文件 echo arch \u003e /etc/hostname cat \u003e /etc/hosts \u003c\u003cEOF 127.0.0.1 localhost ::1 localhost 127.0.1.1 arch.localdomain arch EOF ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:11:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"安装引导文件 引导文件有grub和system-boot，system-boot需要手动写入启动文件，grub指令可以直接生成，较为方便，故采用grub(若efi分区挂载为/mnt/efi，则将efi-directory更改为/efi) pacman -S grub efibootmgr grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB grub-mkconfig -o /boot/grub/grub.cfg ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:12:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"解密参数配置(可选) 如果对磁盘设置了加密，必须设置一些hook和内核参数来告诉内核加密磁盘的位置 具体操作可以参见Archlinux自动解密磁盘 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:13:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"完成安装 基本系统已经完成安装，退出系统，并取消文件挂载，重启既可以进入安装好的系统 exit umount -a reboot ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:14:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"参考资料 Archlinux Installation guide dm-crypt/Encrypting an entire system Arch Linux 安装使用教程 - ArchTutorial - Arch Linux Studio Arch Linux 搭建 java 开发环境 2021 Archlinux双系统安装教程（超详细） Arch Linux Monthly Install: January 2022 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:15:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":null,"content":"游戏规则 点击小圆点，围住小猫。 你点击一次，小猫走一次。 直到你把小猫围住（赢），或者小猫走到边界并逃跑（输）。 ","date":"0001-01-01","objectID":"/catch-the-cat/:1:0","tags":null,"title":"逮住那只猫!","uri":"/catch-the-cat/"}]