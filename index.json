[{"categories":["Java Spring"],"content":"前言 Spring MVC 框架帮我们做了参数封装，动作解耦，结果视图的转向，json结果的生成等，但参数和合法性验证没有实现，需要自己手动实现。而参数校验属于业务逻辑以外的项目，为了将这些代码解耦出来，可以使用 Hibernate Validator 框架提供的参数校验注解功能。 hibernate_validator 验证逻辑 ","date":"2022-04-14","objectID":"/posts/hibernate-validator-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/:1:0","tags":["Hibernate"],"title":"Hibernate Validator 基本使用","uri":"/posts/hibernate-validator-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/"},{"categories":["Java Spring"],"content":"使用流程 ","date":"2022-04-14","objectID":"/posts/hibernate-validator-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/:2:0","tags":["Hibernate"],"title":"Hibernate Validator 基本使用","uri":"/posts/hibernate-validator-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/"},{"categories":["Java Spring"],"content":"导入依赖 \u003c!-- validation --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.hibernate\u003c/groupId\u003e \u003cartifactId\u003ehibernate-validator\u003c/artifactId\u003e \u003cversion\u003e5.1.0.Final\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.validation\u003c/groupId\u003e \u003cartifactId\u003evalidation-api\u003c/artifactId\u003e \u003cversion\u003e1.1.0.Final\u003c/version\u003e \u003c/dependency\u003e ","date":"2022-04-14","objectID":"/posts/hibernate-validator-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/:2:1","tags":["Hibernate"],"title":"Hibernate Validator 基本使用","uri":"/posts/hibernate-validator-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/"},{"categories":["Java Spring"],"content":"注册 在 application.xml （或者application-mvc.xml）配置文件中添加配置，即向 Spring MVC 容器中注册 validator 对象，并添加验证驱动。 \u003cbean id=\"validator\" class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\"\u003e \u003cproperty name=\"providerClass\" value=\"org.hibernate.validator.HibernateValidator\"/\u003e \u003c/bean\u003e \u003cmvc:annotation-driven validator=\"validator\"/\u003e ","date":"2022-04-14","objectID":"/posts/hibernate-validator-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/:2:2","tags":["Hibernate"],"title":"Hibernate Validator 基本使用","uri":"/posts/hibernate-validator-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/"},{"categories":["Java Spring"],"content":"数据验证 在向需要验证的 Bean 的属性字段上添加所需要验证方式的注解。 @Size(min = 6, max = 8, message = \"size error\") String password; 其中 message 为验证错误时给出的错误信息，并在需要验证的传入参数添加 @Valid 注解 @Controller public class UserController { @RequestMapping(\"login\") public String login(@Valid User user){ return \"/WEB-INF/view/show.jsp\"; } } ","date":"2022-04-14","objectID":"/posts/hibernate-validator-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/:2:3","tags":["Hibernate"],"title":"Hibernate Validator 基本使用","uri":"/posts/hibernate-validator-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/"},{"categories":["Java Spring"],"content":"常用注解 @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式 Hibernate Validator 附加的 constraint @NotBlank(message =) 验证字符串非null，且长度必须大于0 @Email 被注释的元素必须是电子邮箱地址 @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内 ","date":"2022-04-14","objectID":"/posts/hibernate-validator-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/:3:0","tags":["Hibernate"],"title":"Hibernate Validator 基本使用","uri":"/posts/hibernate-validator-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html/"},{"categories":["Java Spring"],"content":"前言 Druid 是 Alibab 开源的数据连接池，目前Java社区使用广泛的的数据库连接池，在功能、性能、扩展性方面，都超过其他数据库连接池，包括DBCP、C3P0、BoneCP、Proxool、JBoss DataSource。 ","date":"2022-04-14","objectID":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.html/:1:0","tags":["Druid"],"title":"Druid 数据库连接池","uri":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.html/"},{"categories":["Java Spring"],"content":"使用流程 ","date":"2022-04-14","objectID":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.html/:2:0","tags":["Druid"],"title":"Druid 数据库连接池","uri":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.html/"},{"categories":["Java Spring"],"content":"导入依赖 在 pom 文件导入 druid 相关依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid\u003c/artifactId\u003e \u003cversion\u003e${druid-version}\u003c/version\u003e \u003c/dependency\u003e ","date":"2022-04-14","objectID":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.html/:2:1","tags":["Druid"],"title":"Druid 数据库连接池","uri":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.html/"},{"categories":["Java Spring"],"content":"更改连接池 之前学习 Spring 框架时候用的是 c3p0 连接池，现在只需要更换连接池类就可以了。 \u003cbean id=\"datasource\" class=\"com.alibaba.druid.pool.DruidDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/j13_jdbc_template?serverTimezone=GMT\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"admin\"/\u003e \u003cproperty name=\"filters\" value=\"stat\"/\u003e \u003c/bean\u003e ","date":"2022-04-14","objectID":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.html/:2:2","tags":["Druid"],"title":"Druid 数据库连接池","uri":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.html/"},{"categories":["Java Spring"],"content":"开启性能监控 在 web.xml 文件中添加如下配置内容 \u003cservlet\u003e \u003cservlet-name\u003eDruidStatView\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.alibaba.druid.support.http.StatViewServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eDruidStatView\u003c/servlet-name\u003e \u003curl-pattern\u003e/druid/*\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003c!-- 配置druid监控--\u003e \u003cfilter\u003e \u003cfilter-name\u003eDruidWebStatFilter\u003c/filter-name\u003e \u003cfilter-class\u003ecom.alibaba.druid.support.http.WebStatFilter\u003c/filter-class\u003e \u003cinit-param\u003e \u003cparam-name\u003eexclusions\u003c/param-name\u003e \u003cparam-value\u003e*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*\u003c/param-value\u003e \u003c/init-param\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eDruidWebStatFilter\u003c/filter-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e ","date":"2022-04-14","objectID":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.html/:2:3","tags":["Druid"],"title":"Druid 数据库连接池","uri":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.html/"},{"categories":["Java Spring"],"content":"查看 启动服务器，在 http://localhost/yourproject/druid/index.html 访问监控页面。 ","date":"2022-04-14","objectID":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.html/:2:4","tags":["Druid"],"title":"Druid 数据库连接池","uri":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.html/"},{"categories":["Java Spring"],"content":"参考资料 官方仓库 ","date":"2022-04-14","objectID":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.html/:3:0","tags":["Druid"],"title":"Druid 数据库连接池","uri":"/posts/druid-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.html/"},{"categories":["Java Spring"],"content":"前言 SSM 框架缩写是由 Spring 、 Spring MVC 和 Mybatis 三个单词首字母组合而成，将三者组合一起使用，就是常说的 SSM 框架。 ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:1:0","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Java Spring"],"content":"通过 xml 文件整合 ssm ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:2:0","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Java Spring"],"content":"导包 导入三个组件的依赖，其中 mybatis 提供了整合 spring 的 jar 包（mybatis-spring） \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e \u003cartifactId\u003ejavax.servlet-api\u003c/artifactId\u003e \u003cversion\u003e3.1.0\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.3.17\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.12\u003c/version\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.4.6\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e2.0.1\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.3.17\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.mchange\u003c/groupId\u003e \u003cartifactId\u003ec3p0\u003c/artifactId\u003e \u003cversion\u003e0.9.5.2\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:2:1","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Java Spring"],"content":"配置 sqlSessionFactory 在 application.xml 配置文件中，向容器中注册连接池 datasource，配置 c3p0 的datasource 连接池（后续更换 druid 连接池，性能更换好）。在向 spring 容器中注册 sqlSessionFactoryBean，后续通过其获得 sqlSession对象。 \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"typeAliasesPackage\" value=\"com.cskaoyan.bean\"/\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\"/\u003e \u003c/bean\u003e \u003cbean id=\"datasource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"\u003e \u003cproperty name=\"driverClass\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/j13_jdbc_template?serverTimezone=GMT\"/\u003e \u003cproperty name=\"user\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"admin\"/\u003e \u003c/bean\u003e ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:2:2","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Java Spring"],"content":"获取 mapper 对象 通过 mapper 接口的实现类。 @Repository public class UserMapperImpl implements UserMapper { @Autowired SqlSessionFactory sqlSessionFactory; @Override public User queryUserById(int id) { SqlSession sqlSession = sqlSessionFactory.openSession(); return null; } } 通过配置文件 在 application.xml 向容器中注册 MapperFactoryBean 对象。 \u003cbean class=\"org.mybatis.spring.mapper.MapperFactoryBean\"\u003e \u003cproperty name=\"mapperInterface\" value=\"com.cskaoyan.mapper.UserMapper\"/\u003e \u003cproperty name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/\u003e \u003c/bean\u003e 该方法缺点是每个 mapper 接口都需要在配置文件中编写 MapperFactoryBean。 注册 MapperScannerConfigurer 对象（常用方法，后续换成注解方式） 向容器中注册映射接口扫描对象，并配置扫描范围，使用 sqlSessionFactory 来生成映射对象。 \u003cbean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"\u003e \u003cproperty name=\"basePackage\" value=\"com.cskaoyan.mapper\"/\u003e \u003cproperty name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/\u003e \u003c/bean\u003e ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:2:3","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Java Spring"],"content":"配置 Spring MVC 在 web.xml 文件中配置 DispatherServlet \u003cservlet\u003e \u003cservlet-name\u003edispatcherServlet\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:application.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003edispatcherServlet\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 在 application.xml 注册 mvc 扫描驱动和 事务驱动 \u003ccontext:component-scan base-package=\"com.cskaoyan\"/\u003e \u003cmvc:annotation-driven/\u003e \u003cbean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\"/\u003e \u003c/bean\u003e \u003ctx:annotation-driven transaction-manager=\"txManger\"/\u003e ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:2:4","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Java Spring"],"content":"父子容器配置 上述过程将 spring 和 spring mvc 配置在一块，可以将二者分来开来，其中 spring 作为主容器，spring mvc 作为子容器。 在 web.xml 文件中使用 listener 标签加载 spring 容器，并设置 mvc 子容器的配置文件所在位置。 \u003clistener\u003e \u003clistener-class\u003eorg.springframework.web.context.ContextLoaderListener\u003c/listener-class\u003e \u003c/listener\u003e \u003ccontext-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:application.xml\u003c/param-value\u003e \u003c/context-param\u003e \u003cservlet\u003e \u003cservlet-name\u003edispatcherServlet\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:application_mvc.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003edispatcherServlet\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 父容器的配置文件为 applicatio.xml，子容器的配置为 application.xml。 父容器的配置内容为：其中 SpringBean 为 spring 容器的配置类，用来向 Spring 容器中注册类。 \u003ccontext:component-scan base-package=\"com.cskaoyan\"\u003e \u003ccontext:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/\u003e \u003c/context:component-scan\u003e \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"typeAliasesPackage\" value=\"com.cskaoyan.bean\"/\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\"/\u003e \u003c/bean\u003e \u003cbean id=\"datasource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"\u003e \u003cproperty name=\"driverClass\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/j13_jdbc_template?serverTimezone=GMT\"/\u003e \u003cproperty name=\"user\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"admin\"/\u003e \u003c/bean\u003e \u003cbean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"\u003e \u003cproperty name=\"basePackage\" value=\"com.cskaoyan.mapper\"/\u003e \u003cproperty name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/\u003e \u003c/bean\u003e \u003cbean class=\"com.cskaoyan.bean.SpringBean\"/\u003e 子容器配置内容为：其中 SpringMvcBean 容器的配置类，用来向 Spring MVC 容器中注册类。 \u003ccontext:component-scan base-package=\"com.cskaoyan.controller\"/\u003e \u003cmvc:annotation-driven/\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"\u003e \u003cproperty name=\"prefix\" value=\"/WEB-INF/view/\"/\u003e \u003cproperty name=\"suffix\" value=\".jsp\"/\u003e \u003c/bean\u003e \u003cbean class=\"com.cskaoyan.bean.SpringMvcBean\"/\u003e ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:2:5","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Java Spring"],"content":"通过配置类整合 ssm 上面通过配置 xml 文件来实现 ssm 整合，也可以通过配置类来实现 ssm 整合。 ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:3:0","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Java Spring"],"content":"配置启动器类 新建一个启动类，继承抽象类 AbstractAnnotationConfigDispatcherServletInitializer ，并重写父类方法的三个方法。getRootConfigClasses 方法是获得 Spring 容器配置类对象，getServletConfigClasses 方法获得 Spring MVC 容器配置类对象，getServletMappings 设置 DispatcherServlet 的启动路径。 public class ApplicationInitialize extends AbstractAnnotationConfigDispatcherServletInitializer { @Override protected Class\u003c?\u003e[] getRootConfigClasses() { return new Class[]{SpringConfig.class}; } @Override protected Class\u003c?\u003e[] getServletConfigClasses() { return new Class[]{SpringMvcConfig.class}; } @Override protected String[] getServletMappings() { return new String[]{\"/\"}; } } ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:3:1","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Java Spring"],"content":"配置 Spring 配置类 配置类上使用 @Configuration 和 @ComponentScan 注解，第一个注解是表示该类为一个配置类，第二个配置扫描注解的范围，若在扫描范围内，且含有对应注解，则向 Spring 容器中注册，要注意排除 Spring MVC 注册类扫描的范围 ，否则会向容器生成两个对象。并向 Spring 容器中注册 SqlSessionFactoryBean 、ComboPooledDataSource 和 MapperScannerConfigurer 对象。 @Configuration @ComponentScan(basePackages = \"com.cskaoyan\", excludeFilters = {@ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class, EnableWebMvc.class})}) public class SpringConfig { @Bean(\"sqlSessionFactoryBean\") public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){ SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setTypeAliasesPackage(\"com.cskaoyan.bean\"); sqlSessionFactoryBean.setDataSource(dataSource); return sqlSessionFactoryBean; } @Bean public DataSource dataSource() throws PropertyVetoException { ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(); comboPooledDataSource.setDriverClass(\"com.mysql.cj.jdbc.Driver\"); comboPooledDataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/j13_jdbc_template?serverTimezone=GMT\"); comboPooledDataSource.setUser(\"root\"); comboPooledDataSource.setPassword(\"admin\"); return comboPooledDataSource; } @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); mapperScannerConfigurer.setSqlSessionFactoryBeanName(\"sqlSessionFactoryBean\"); mapperScannerConfigurer.setBasePackage(\"com.cskaoyan.mapper\"); return mapperScannerConfigurer; } } ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:3:2","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Java Spring"],"content":"配置 Spring MVC 配置类 在配置类上使用 EnableWebMvc 和 ComponentScan 注解，并实现 WebMvcConfigurer 接口。第一个注解表示该类为 Spring MVC 配置类，第二个配置为扫描注解范围，在 Spring MVC 配置类上配置视图解析器。 @EnableWebMvc @ComponentScan(basePackages = \"com.cskaoyan.controller\") public class SpringMvcConfig implements WebMvcConfigurer { @Bean public ViewResolver viewResolver(){ InternalResourceViewResolver internalResourceViewResolver = new InternalResourceViewResolver(); internalResourceViewResolver.setSuffix(\".jsp\"); internalResourceViewResolver.setPrefix(\"/WEB-INF/view/\"); return internalResourceViewResolver; } } ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:3:3","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Java Spring"],"content":"其他组件 Encoding Filter 为了防止中文传输乱码，在启动类配置文件编码格式 @Override protected Filter[] getServletFilers(){ CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter(); encodingFilter.setEncoding(\"utf-8\"); encodingFilter.setForceEncoding(true); return new Filter[]{encodingFilter}; } Converter 数据转换器，在 Spring MVC 配置类中注册转换器 @Configuration @EnableWebMvc @ComponentScan(basePackages = \"com.cskaoyan.controller\") public class SpringMvcConfig implements WebMvcConfigurer { @Autowired ConfigurableConversionService configurableConversionService; @Bean @Primary public ConfigurableConversionService configurableConversionService(){ return configurableConversionService; } @PostConstruct public void addConverterToService(){ configurableConversionService.addConverter(new MyConverter()); } } File upload 可以通过注册 bean 进行文件上传 @Bean public CommonMultipartResolver multipartResolver(){ CommonMultipartResolver commonMultipartResolver = new CommonMultipartResolver(); commonMultipartResolver.setMaxUploadSize(500000); return commonMultipartResolver; } ","date":"2022-04-14","objectID":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/:3:4","tags":["ssm"],"title":"SSM 框架整合","uri":"/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html/"},{"categories":["Java Spring"],"content":"前言 为了记录代码的工作信息，入门操作通常是使用控制台输出来查看记录。而当代码需要长时间工作时，则需要持久化记录。 log4j 是 apache 下日志记录的常用软件，可以在终端输出和在文本内记录应用的工作记录。 ","date":"2022-04-14","objectID":"/posts/log4j-%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE.html/:1:0","tags":["log4j"],"title":"log4j 日志配置","uri":"/posts/log4j-%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE.html/"},{"categories":["Java Spring"],"content":"使用流程 ","date":"2022-04-14","objectID":"/posts/log4j-%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE.html/:2:0","tags":["log4j"],"title":"log4j 日志配置","uri":"/posts/log4j-%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE.html/"},{"categories":["Java Spring"],"content":"导包 导入 log4j 的依赖 log4j 1.x 版本导入 \u003cdependency\u003e \u003cgroupId\u003elog4j\u003c/groupId\u003e \u003cartifactId\u003elog4j\u003c/artifactId\u003e \u003cversion\u003e1.2.17\u003c/version\u003e \u003c/dependency\u003e log4j 2.x 版本导入 \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-api\u003c/artifactId\u003e \u003cversion\u003e2.17.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-core\u003c/artifactId\u003e \u003cversion\u003e2.17.2\u003c/version\u003e \u003c/dependency\u003e ","date":"2022-04-14","objectID":"/posts/log4j-%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE.html/:2:1","tags":["log4j"],"title":"log4j 日志配置","uri":"/posts/log4j-%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE.html/"},{"categories":["Java Spring"],"content":"配置 log4j 的配置文件 log4j 1.x ### DEBUG?INFO?WARN?ERROR?FATAL #????+??appender log4j.rootLogger=debug ,file,stdout,file2 #Appender #org.apache.log4j.ConsoleAppender????? #org.apache.log4j.FileAppender???? #org.apache.log4j.DailyRollingFileAppender???????????? #org.apache.log4j.RollingFileAppender??????????????????????? #org.apache.log4j.WriterAppender????????????????????? ### direct log messages to stdout ### log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.Target=System.out log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n ### direct messages to file hibernate.log ### log4j.appender.file=org.apache.log4j.FileAppender log4j.appender.file.File=/home/swq/Desktop/11mybatis.log log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n #org.apache.log4j.HTMLLayout??HTML??????? #org.apache.log4j.PatternLayout????????????? #org.apache.log4j.SimpleLayout????????????????? #org.apache.log4j.TTCCLayout???????????????????? log4j.appender.file2 = org.apache.log4j.FileAppender log4j.appender.file2.File=/home/swq/Desktop/file2.log log4j.appender.file2.layout=org.apache.log4j.SimpleLayout #log4j.appender.file2.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n log4j 2.x 2.x 已经放弃了 properties 方式，而是采用 xml, json 或者 jsn 格式。 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!-- log4j2 配置文件 --\u003e \u003c!-- 日志级别 trace\u003cdebug\u003cinfo\u003cwarn\u003cerror\u003cfatal --\u003e \u003cconfiguration status=\"debug\"\u003e \u003c!-- 自定义属性 --\u003e \u003cProperties\u003e \u003c!-- 日志格式(控制台) --\u003e \u003cProperty name=\"pattern1\"\u003e[%-5p] %d %c - %m%n\u003c/Property\u003e \u003c!-- 日志格式(文件) --\u003e \u003cProperty name=\"pattern2\"\u003e =========================================%n 日志级别：%p%n 日志时间：%d%n 所属类名：%c%n 所属线程：%t%n 日志信息：%m%n \u003c/Property\u003e \u003c!-- 日志文件路径 --\u003e \u003cProperty name=\"filePath\"\u003elogs/myLog.log\u003c/Property\u003e \u003c/Properties\u003e \u003cappenders\u003e \u003cConsole name=\"Console\" target=\"SYSTEM_OUT\"\u003e \u003cPatternLayout pattern=\"${pattern1}\"/\u003e \u003c/Console\u003e \u003cRollingFile name=\"RollingFile\" fileName=\"${filePath}\" filePattern=\"logs/$${date:yyyy-MM}/app-%d{MM-dd-yyyy}-%i.log.gz\"\u003e \u003cPatternLayout pattern=\"${pattern2}\"/\u003e \u003cSizeBasedTriggeringPolicy size=\"5 MB\"/\u003e \u003c/RollingFile\u003e \u003c/appenders\u003e \u003cloggers\u003e \u003croot level=\"debug\"\u003e \u003cappender-ref ref=\"Console\"/\u003e \u003cappender-ref ref=\"RollingFile\"/\u003e \u003c/root\u003e \u003c/loggers\u003e \u003c/configuration\u003e ","date":"2022-04-14","objectID":"/posts/log4j-%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE.html/:2:2","tags":["log4j"],"title":"log4j 日志配置","uri":"/posts/log4j-%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE.html/"},{"categories":["Java Spring"],"content":"使用 log4j 1.x Logger logger = Logger.getLogger(LogTest.class); logger.debug(\"debug\"); logger.warn(\"warn\"); logger.info(\"info\"); logger.error(\"error\"); logger.fatal(\"fatal\"); log4j 2.x Logger logger = LogManager.getLogger(LogTest.class); logger.trace(\"trace level\"); logger.debug(\"debug level\"); logger.info(\"info level\"); logger.warn(\"warn level\"); logger.error(\"error level\"); logger.fatal(\"fatal level\"); 通过传入类名获得其 logger 对象，并使用其打印日志。 ","date":"2022-04-14","objectID":"/posts/log4j-%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE.html/:2:3","tags":["log4j"],"title":"log4j 日志配置","uri":"/posts/log4j-%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE.html/"},{"categories":["Java Spring"],"content":"前言 MyBatis 是一款优秀的持久层框架**，它支持定制化 SQL（灵活的修改）、存储过程（函数）以及高级**映射（javabean和数据库对象的映射-\u003e输入映射和输出映射）。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。 MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJO 映射成数据库中的记录。（ORM和持久化） mybatis 流程图 ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:1:0","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"使用流程 ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:0","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"导包 导入 mybatis 和 mysql 的依赖。 \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.4.6\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.12\u003c/version\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:1","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"配置数据库连接 在 mybatis.xml 配置配置数据库的参数设置连接。主要配置内容为数据库驱动jdbc driver 、 数据库的连接信息和查询映射文件。 映射文件配置有两种方式： 配置 mapper 标签处对应的为 Mapper 配置文件所在的位置rsource 。（配置文件需要与对应的映射接口处于同一个包下） ，如果没有配置，则后续 sql 语句第一个参数为 全类名.sql方法 ， 书写较为复杂。 在 mapper 标签内配置 package 参数，该参数表示配置文件所在的包目录。（主要使用） \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003c!--Managed--\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003c!--UNPooled--\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/j13_jdbc_template?serverTimezone=GMT\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"admin\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003cmapper resource=\"com/cskaoyan/dao/UserDao.xml\"/\u003e \u003c!--\u003cpackage name=\"com.cskaoyan.dao\"/\u003e--\u003e \u003c/mappers\u003e \u003c/configuration\u003e ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:2","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"生成 sqlSession 对象 使用 构建者 模式生成 sqlSession 对象。 public class MainTest { SqlSessionFactory sqlSessionFactory; SqlSession sqlSession; @Before public void init() throws IOException { InputStream inputStream = Resources.getResourceAsStream(\"mybatis.xml\"); //通过建造者创建工厂 sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } @After public void after(){ sqlSession.commit(); sqlSession.close(); } @Test public void mytest(){ sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.queryUserByid(1); System.out.println(user); } } ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:3","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"配置查询语句 在 UserDao.xml 配置文件中使用标签配置 sql 语句，同名的映射接口配置 sql 操作方法，该方法名为 sql 语句的 id 。 \u003cmapper namespace=\"com.cskaoyan.mapper.UserMapper\"\u003e \u003cinsert id=\"insertUser\"\u003e insert into j13_user_t (id, username, password, email) values (#{id}, #{username}, #{password}, #{email}) \u003c/insert\u003e \u003cdelete id=\"deleteUser\"\u003e delete from j13_user_t where id = #{id} \u003c/delete\u003e \u003cupdate id=\"updateUser\"\u003e update j13_user_t set username = #{username} where id = #{id} \u003c/update\u003e \u003c/mapper\u003e public interface UserMapper { User queryUserByid(int id); int insertUser(User user); int deleteUser(int id); int updateUser(User user); } insert 操作的必须配置 resultType（或者 resultMap） ，其他 sql 操作没有该参数选项。 sql 语句中传入的参数如果为基本类型时，则任意写，如果为 javabean 类型，则使用 #{类.属性} 进行选择。可以在调用 sql 语句中，使用注解 @Param 来限制后续选择，比如 int deleteUser(@Param(\"id\")int id); ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:4","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"映射关系 ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:0","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"输入映射 则在配置文件书写 sql 语句时，必须使用 #{id} 来访问传入参数 id 。 简单类型。对应简单基本类型来说，如果没有配置注解 @Param ，则使用名称小写即可（内部以实现映射）。使用了注解，则根据注解使用。 \u003cupdate id=\"updateUser\"\u003e update j13_user_t set username = #{username} where id = #{id} \u003c/update\u003e POJO ：没有使用注解时，使用类的小写即可（其中配置文件必须与类在同一个包下）。使用注解时，根据注解使用。如果传入类型为多个 pojo 类型时，且没有使用注解时，则使用 param1 、param2 来选择参数。使用了注解后，则使用注解对应的名字。（使用注解更加清晰），后续使用 . 来访问类内的属性。 \u003cupdate id=\"updateUser\"\u003e update j13_user_t set username = #{username} where id = #{param1.id} \u003c/update\u003e \u003cupdate id=\"updateUser\"\u003e update j13_user_t set username = #{username} where id = #{user.id} \u003c/update\u003e Map ：若只有一个传入参数，直接使用 Key 获取 Value 。若存在多个传入参数，则使用 param1 、param2 来选择。使用注解后根据注解使用。 \u003cupdate id=\"updateUser\"\u003e update j13_user_t set username = #{username} where id = #{param1.key} \u003c/update\u003e \u003cupdate id=\"updateUser\"\u003e update j13_user_t set username = #{username} where id = #{map.key} \u003c/update\u003e 凡是使用了注解 @Param ，都根据注解进行匹配，尽量使用注解，使用注解可以提高代码可读性。 使用$符号访问参数时，有注入风险，使用#则mybatis会帮我们进行参数预处理 ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:1","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"输出映射 简单类型。查询列必须为单列，才能使用简单类型映射 \u003cselect id=\"selectUser\" resultType=\"string\"\u003e select id from j13_user_t where username = #{user.username} \u003c/update\u003e pojo 对象映射。在 ResultType 字段配置 pojo 对象（因为映射接口和配置文件在同一包下，直接使用类小写即可），且查询列名必须与映射的类的属性名一一对应才能映射成功，如果某属性映射不成功，则设置为null。resultType 为类名的小写（配置文件必须与类在一个包内）。 public class User{ int id; String username; String password; String email; } \u003cselect id=\"selectUser\" resultType=\"user\"\u003e select id,username,password,email from j13_user_t where username = #{user.username} \u003c/update\u003e ResultMap 对象映射。查询的列名不再需要与对象的属性名一一对应，但是需要通过 ResultMap 标签来设置列名和属性名进行映射，其中 column 设置查询的结果的列名，property 设置属性名。 \u003cresultMap id=\"userMap\" type=\"user\"\u003e \u003cresult column=\"id\" property=\"idz\"/\u003e \u003cresult column=\"username\" property=\"usernames\"/\u003e \u003cresult column=\"password\" property=\"passwordw\"/\u003e \u003cresult column=\"email\" property=\"emaill\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"queryUserById\" resultMap=\"userMap\"\u003e select id,username,password,email from j13_user_t where id=#{id} \u003c/select\u003e 上述类中的属性名分别为 idz 、usernames 、passwordw 和 emaill ，将查询结果与对应属性映射起来。 ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:2","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"动态 sql 标签 常用的标签有 where 、 if 、sql 和 foreach 。标签的主要作用是将 sql 语句分成若干段，可以使用 inclde 标签和 refid 属性引用 sql 语句段，从而代码重用，减少冗余代码。 ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:0","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"where 标签 \u003cselect id=\"selectUser\" resultType=\"string\"\u003e select id from j13_user_t \u003cwhere\u003e username = #{user.username} \u003c/where\u003e \u003c/update\u003e ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:1","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"if 标签。 需要注意的是除了第一个 if 标签，后续 if 标签都需要添加 and 或者 or ，来表示层次关系。 \u003cselect id=\"selectUser\" resultType=\"string\"\u003e select id from j13_user_t \u003cwhere\u003e \u003cif test=\"username != null\"\u003e username = #{username} \u003c/if\u003e \u003cif test=\"age != 0\"\u003e and age = #{age} \u003c/if\u003e \u003c/where\u003e \u003c/update\u003e ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:2","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"sql 标签。 主要是用作片段，给其他语句 include 使用。 \u003csql id=\"selectAll\"\u003e select id,username,password,email from j13_user_t \u003c/sql\u003e ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:3","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"foreach 标签。 用来遍历链表或者数组。 未使用注解的数组。collection 使用 array , item 表示每次迭代的对象，separator 表示每次迭代后的连接符号，index 表示索引，从 0 开始。 \u003cinsert id=\"insertArray\"\u003e insert into j13_user_t (id,username,password,email) values \u003cforeach collection=\"array\" item=\"user\" sepatrtor=\",\" index=\"index\"\u003e (#{user.id}, #{user.username},#{user.password},#{user.email}) \u003c/foreach\u003e \u003c/insert\u003e 未使用注解的List。collection 使用 list 。open 和 close 表示迭代后的字符串左右两边的符号。若不使用的这两个属性，需要手动增加两个括号，代码不够优雅。 \u003cinsert id=\"selectUserById\" resultType=\"user\"\u003e select id,username,password,email from j13_uset_t \u003cwhere\u003e id in \u003cforeach collection=\"list\" item=\"userid\" open=\"(\" close\")\"\u003e #(userid) \u003c/foreach\u003e \u003c/where\u003e \u003c/insert\u003e 使用注解的数组和List。 \u003cinsert id=\"insertArray\"\u003e insert into j13_user_t (id,username,password,email) values \u003cforeach collection=\"users\" item=\"user\" sepatrtor=\",\"\u003e (#{user.id}, #{user.username},#{user.password},#{user.email}) \u003c/foreach\u003e \u003c/insert\u003e \u003cinsert id=\"selectUserById\" resultType=\"user\"\u003e select id,username,password,email from j13_uset_t \u003cwhere\u003e id in \u003cforeach collection=\"ids\" item=\"id\" open=\"(\" close\")\"\u003e #(id) \u003c/foreach\u003e \u003c/where\u003e \u003c/insert\u003e ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:4","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"Mybatis 的优化 ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:5:0","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"懒加载 根据数据的使用情况，按需加载 sql 语句。当某个 sql 语句执行完成后，没有书用到其中的数据时，则可以暂时不执行该语句。Mybatis 默认是没有懒加载的，需要在 Myabis 的 mybatis.xml 配置文件中手动开启，同时在映射文件中设置 fetchType 启用懒加载。（连接查询是没有懒加载的） \u003cconfiguration\u003e \u003csettings\u003e \u003csetting name=\"lazyLoadingEnabled\" value=\"true\"/\u003e \u003csetting name=\"cacheEnabled\" value=\"true\"/\u003e \u003c/settings\u003e \u003c/configuration\u003e \u003cresultMap id=\"userMap\" type=\"user\"\u003e \u003cresult column=\"id\" property=\"id\"/\u003e \u003cresult column=\"username\" property=\"username\"/\u003e \u003cresult column=\"password\" property=\"password\"/\u003e \u003cresult column=\"email\" property=\"email\"/\u003e \u003c!--property是我们1的成员变量名--\u003e \u003c!--colume是来源于第一次查询结果的列名，并且为第二次查询提供参数--\u003e \u003cassociation property=\"userDetail\" fetchType=\"lazy\" column=\"id\" select=\"com.cskaoyan.mapper.UserDetailMapper.selectUserDetailByUid\"/\u003e \u003c/resultMap\u003e ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:5:1","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"缓存 为了减少磁盘的IO，mybatis 提供了缓存机制。 mybatis 缓存 一级缓存 一级缓存默认是开启的，一级缓存级别是 sqlSession 级别的，即不同的 sqlSession 不会共享缓存。当 sqlSession commit 提交之后，缓存失效。同时若数据库的数据发生更改、添加和删除时，则缓存失效。 二级缓存 二级缓存默认是关闭的，二级缓存级别是 mapper 级别的，当 sqlSession 提交之后，二级缓存才生成 ，同时不同的 sqlSession 对象（同一个类的不同 sqlSession 对象）的 mapper 也共享当前缓存，如果对数据库进行了增删改操作是，如果没有提交事务，则缓存不会失效，即可能造成幻读，只有提交事务之后缓存才失效，需要注意。 二级缓存需要在 mybatis.xml 配置文件中开启 \u003csettings\u003e \u003csetting name=\"lazyLoadingEnabled\" value=\"true\"/\u003e \u003csetting name=\"cacheEnabled\" value=\"true\"/\u003e \u003c/settings\u003e 如果要对某一个类的进行二级缓存查询时，必须实现序列化接口，进行序列化，否则无法缓存，同时在该类的映射文件在添加 cache 标签。 public class User implements Serializable{ ... } \u003ccache/\u003e ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:5:2","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"逆向工程 为了减少映射文件的书写，可以使用逆向工程生成映射文件。 ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:6:0","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"导包 导包逆向工程的依赖和数据库的依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.generator\u003c/groupId\u003e \u003cartifactId\u003emybatis-generator-core\u003c/artifactId\u003e \u003cversion\u003e1.4.1\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.12\u003c/version\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:6:1","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"配置文件设置 在项目的根目录下配置逆向工程的配置 generatorConfig.xml 。 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"\u003e \u003cgeneratorConfiguration\u003e \u003ccontext id=\"testTables\" targetRuntime=\"MyBatis3\"\u003e \u003ccommentGenerator\u003e \u003c!-- 是否去除自动生成的注释 true：是 ： false:否 --\u003e \u003cproperty name=\"suppressAllComments\" value=\"true\" /\u003e \u003c/commentGenerator\u003e \u003c!--数据库连接的信息：驱动类、连接地址、用户名、密码 --\u003e \u003cjdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/j13_jdbc_template?serverTimezone=GMT\" userId=\"root\" password=\"admin\"\u003e \u003cproperty name=\"nullCatalogMeansCurrent\" value=\"true\"/\u003e \u003c/jdbcConnection\u003e \u003c!--\u0026lt;!\u0026ndash; for oracle \u0026ndash;\u0026gt; \u003cjdbcConnection driverClass=\"oracle.jdbc.OracleDriver\" connectionURL=\"jdbc:oracle:thin:@127.0.0.1:1521:yycg\" userId=\"yycg\" password=\"yycg\"\u003e \u003c/jdbcConnection\u003e--\u003e \u003c!-- 默认false， 为false把JDBC DECIMAL 和 NUMERIC 类型解析为Integer， 为 true把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --\u003e \u003c!--\u003cjavaTypeResolver\u003e \u003cproperty name=\"forceBigDecimals\" value=\"false\" /\u003e \u003c/javaTypeResolver\u003e--\u003e \u003c!-- javaModelGenerator javaBean生成的配置信息 targetProject:生成PO类的位置 targetPackage：生成PO类的类名--\u003e \u003cjavaModelGenerator targetPackage=\"com.cskaoyan.bean\" targetProject=\"./mybatis_demo8/src/main/java\"\u003e \u003c!-- enableSubPackages:是否允许子包,是否让schema作为包的后缀 即targetPackage.schemaName.tableName --\u003e \u003cproperty name=\"enableSubPackages\" value=\"true\" /\u003e \u003c!-- 从数据库返回的值是否清理前后的空格 --\u003e \u003cproperty name=\"trimStrings\" value=\"true\" /\u003e \u003c/javaModelGenerator\u003e \u003c!-- sqlMapGenerator Mapper映射文件的配置信息 targetProject:mapper映射文件生成的位置 targetPackage:生成mapper映射文件放在哪个包下--\u003e \u003csqlMapGenerator targetPackage=\"com.cskaoyan.mapper\" targetProject=\"./mybatis_demo8/src/main/resources\"\u003e \u003c!-- enableSubPackages:是否让schema作为包的后缀 --\u003e \u003cproperty name=\"enableSubPackages\" value=\"true\" /\u003e \u003c/sqlMapGenerator\u003e \u003c!-- javaClientGenerator 生成 Model对象(JavaBean)和 mapper XML配置文件 对应的Dao代码 targetProject:mapper接口生成的位置 targetPackage:生成mapper接口放在哪个包下 ANNOTATEDMAPPER XMLMAPPER MIXEDMAPPER --\u003e \u003cjavaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.cskaoyan.mapper\" targetProject=\"./mybatis_demo8/src/main/java\"\u003e \u003c!-- enableSubPackages:是否让schema作为包的后缀 --\u003e \u003cproperty name=\"enableSubPackages\" value=\"true\" /\u003e \u003c/javaClientGenerator\u003e\u003c!----\u003e \u003c!-- 指定数据库表 --\u003e \u003c!-- 指定所有数据库表 --\u003e \u003c!--\u003ctable tableName=\"%\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"false\" enableInsert=\"false\" enableDeleteByPrimaryKey=\"true\" enableSelectByPrimaryKey=\"true\" selectByExampleQueryId=\"false\" \u003e\u003c/table\u003e--\u003e \u003c!-- 指定数据库表，要生成哪些表，就写哪些表，要和数据库中对应，不能写错！ --\u003e \u003ctable tableName=\"j13_user_t\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"false\" enableInsert=\"true\" enableDeleteByPrimaryKey=\"true\" enableSelectByPrimaryKey=\"true\" selectByExampleQueryId=\"false\" domainObjectName=\"User\" \u003e \u003c/table\u003e \u003ctable tableName=\"j13_student_t\" domainObjectName=\"Student\"/\u003e \u003ctable tableName=\"j13_course_t\" domainObjectName=\"Course\"/\u003e \u003c!-- \u003ctable schema=\"\" tableName=\"orders\"\u003e\u003c/table\u003e \u003ctable schema=\"\" tableName=\"items\"\u003e\u003c/table\u003e \u003ctable schema=\"\" tableName=\"orderdetail\"\u003e\u003c/table\u003e --\u003e \u003c!-- 有些表的字段需要指定java类型 \u003ctable schema=\"\" tableName=\"\"\u003e \u003ccolumnOverride column=\"\" javaType=\"\" /\u003e \u003c/table\u003e --\u003e \u003c/context\u003e \u003c/generatorConfiguration\u003e ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:6:2","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"引入逆向工程的 main 方法 配置 main 方法，并运行，即可以生成配置文件中设置好的映射配置文件。 public class Generator { public void generator() throws Exception{ List\u003cString\u003e warnings = new ArrayList\u003cString\u003e(); boolean overwrite = true; //指向逆向工程配置文件 File configFile = new File(\"mybatis/generatorConfig.xml\"); System.out.println(configFile.getAbsolutePath()); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); } public static void main(String[] args) throws Exception { try { Generator generatorSqlmap = new Generator(); generatorSqlmap.generator(); } catch (Exception e) { e.printStackTrace(); } } } ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:6:3","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"其他 若映射文件和映射类在同一个包下，且名字相同时，则在映射文件中 resultType 通常用类名小写来代表返回类型。也可以在类名上使用 @Alias 注解，来规定返回使用类型别名。 @Alias(\"fruit\") public class Apple{ ... } \u003cselect id=\"selectApple\" resultType=\"fruit\"\u003e select * from j13_apple_t \u003c/select\u003e 对于简单的 sql 语句时，可以直接在映射接口上使用注解来完成 public interface AppleManager{ @Select(\"select * from j13_apple_t where id #{id}\") Apple selectAppleById(@Param(\"id\") int id); } ","date":"2022-04-11","objectID":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:7:0","tags":["Mybatis"],"title":"Mybatis 学习笔记","uri":"/posts/mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"前言 在 Spring MVC 中，视图默认使用 jsp 文件，导致每次加载视图时，都需要对文件进行编译，从而浪费服务器的资源。为了减少对服务器资源使用，可以使用静态文件，提前将视图渲染为 html 文件。 FreeMarker 是一种是一款 模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件 freemarker 工作流程图 ","date":"2022-04-11","objectID":"/posts/freemarker-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html/:1:0","tags":["FreeMarker"],"title":"Freemarker 学习记录","uri":"/posts/freemarker-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html/"},{"categories":["Java Spring"],"content":"使用流程 导入依赖。导入 spring-context-support 和 freemarker 依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.freemarker\u003c/groupId\u003e \u003cartifactId\u003efreemarker\u003c/artifactId\u003e \u003cversion\u003e2.3.31\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-context-support\u003c/artifactId\u003e \u003cversion\u003e5.3.17\u003c/version\u003e \u003c/dependency\u003e 在 appliction.xml 文件中配置对应的 bean对象。 \u003cbean class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer\"\u003e \u003cproperty name=\"templateLoaderPath\" value=\"/WEB-INF/freemarker\"/\u003e \u003cproperty name=\"defaultEncoding\" value=\"utf-8\"/\u003e \u003c/bean\u003e \u003cbean class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver\"\u003e \u003cproperty name=\"suffix\" value=\".ftl\"/\u003e \u003cproperty name=\"contentType\" value=\"text/html;ch araset=utf-8\"/\u003e \u003cproperty name=\"order\" value=\"1\"/\u003e \u003c/bean\u003e 在需要渲染的视图中中，配置模板对象。 public class MainTest{ @Test public void myTest() throws IOException, TemplateException { // 使用freemark版本号，创建 Configuration 对象 Configuration configuration = new Configuration(Configuration.getVersion()); File file = new File(\"src/main/resources\"); // 设置模板对象所在路径 configuration.setDirectoryForTemplateLoading(file); // 设置模板编码格式 configuration.setDefaultEncoding(\"utf-8\"); // 创建模板对象 Template template = configuration.getTemplate(\"hello.ftl\"); // 创建模板使用的数据集合，可以是 pojo 也可以是哈希表 HashMap\u003cString, Object\u003e stringObjectHashMap = new HashMap\u003c\u003e(); User user = new User(\"java\", \"pass\", 10); stringObjectHashMap.put(\"user\", user); stringObjectHashMap.put(\"code\", \"freemarker\"); // 创建一个 Writer对象，一般创建 FileWriter 对象，生成指定文件 FileWriter fileWriter = new FileWriter(new File(\"src/main/resources/hello.html\")); // 调用 process 方法，输出指定文件 template.process(stringObjectHashMap, fileWriter); // 关闭流 fileWriter.close(); } } ","date":"2022-04-11","objectID":"/posts/freemarker-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html/:2:0","tags":["FreeMarker"],"title":"Freemarker 学习记录","uri":"/posts/freemarker-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html/"},{"categories":["Java Spring"],"content":"基本语法 访问哈希表中 key 所对应的 value 时，同 jsp 一样，使用 ${key} 访问。 访问 pojo 中的属性：使用 ${类名.属性} 访问 访问集合中的数据： 使用 #list 标签遍历访问 User user1 = new User(\"admin1\", \"123\"); User user2 = new User(\"admin2\", \"123\"); User user3 = new User(\"admin3\", \"123\"); List\u003cUser\u003e list = new ArrayList\u003c\u003e(); list.add(user1); list.add(user2); list.add(user3); dataMap.put(\"userlist\", list); \u003c#list userlist as users\u003e ${users.username} ${users.password} \u003c/#list\u003e 判断语法和比较语法 \u003c#if hello==\"java\"\u003e ${hello} \u003c#elseif hello==\"python\"\u003e ${hello} \u003c/#if\u003e 日期类处理 ${date?string(\"yyyy/MM/dd HH:mm:ss\")} null值处理：使用 ?? 判断是否为空，使用 ！ 表示为空使用默认值，后面什么都不跟的化，则使用空字符串。（若为空使用的则会抛出异常，且会输出到默认的指定文件当中） \u003c#if hello??\u003e ${hello! \"默认值\"} 引入其他模板文件。使用 include 引入其他模板文件。 \u003c#inclde \"foo.ftl\"\u003e ","date":"2022-04-11","objectID":"/posts/freemarker-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html/:2:1","tags":["FreeMarker"],"title":"Freemarker 学习记录","uri":"/posts/freemarker-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html/"},{"categories":["Java Spring"],"content":"前言 MVC 三个单词分别为 Model 、 View 和 Controller ，MVC 模式是一种常用的web开发模式，比如python的 django 也是采用该模式。Spring 框架也提供了该模式，负责表示层。 spring mvc流程图 ","date":"2022-04-09","objectID":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:1:0","tags":["MVC"],"title":"Spring MVC学习笔记","uri":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"工作流程 Spring MVC 提供了四大组件，前端控制器（DispatcherServlet）、处理器映射器（HandlerMapping）、处理器适配器（HandlerAdapter）以及视图解析器（ViewResolver）。 用户请求发送到前端控制器 DispatcherServlet。 前端控制器 DispatcherServlet 接收到请求后，DispatcherServlet 会使用 HandlerMapping 来处理，HandlerMapping 会查找到具体进行处理请求的 Handler 对象。 HandlerMapping 找到对应的 Handler 之后，并不是返回一个 Handler 原始对象，而是一个 Handler 执行链（HandlerExecutionChain），在这个执行链中包括了拦截器和处理请求的 Handler。HandlerMapping 返回一个执行链给 DispatcherServlet。 DispatcherServlet 接收到执行链之后，会调用 Handler 适配器去执行 Handler。 Handler 适配器执行完成 Handler（也就是 Controller）之后会得到一个 ModelAndView，并返回给 DispatcherServlet。 DispatcherServlet 接收到 HandlerAdapter 返回的 ModelAndView 之后，会根据其中的视图名调用 ViewResolver。 ViewResolver 根据逻辑视图名解析成一个真正的 View 视图，并返回给 DispatcherServlet。 DispatcherServlet 接收到视图之后，会根据上面的 ModelAndView 中的 model 来进行视图中数据的填充，也就是所谓的视图渲染。 渲染完成之后，DispatcherServlet 就可以将结果返回给用户了。 ","date":"2022-04-09","objectID":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:0","tags":["MVC"],"title":"Spring MVC学习笔记","uri":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"使用流程 ","date":"2022-04-09","objectID":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:0","tags":["MVC"],"title":"Spring MVC学习笔记","uri":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"导包 导入 spring-webmvc 依赖，该依赖依赖于 spring-context ，所以可以不用手动导入 spring-context。 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.3.17\u003c/version\u003e \u003c/dependency\u003e ","date":"2022-04-09","objectID":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:1","tags":["MVC"],"title":"Spring MVC学习笔记","uri":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"配置前端控制器 \u003cservlet\u003e \u003cservlet-name\u003edispatcher\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:application.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003edispatcher\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e ","date":"2022-04-09","objectID":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:2","tags":["MVC"],"title":"Spring MVC学习笔记","uri":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"配置 HandlerMapping 和 HandlerAdapter 可以通过配置文件配置也可以通过注解配置。 通过配置文件 在配置文件中配置 springmvc 的所需要的 bean 。 \u003cbean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"\u003e\u003c/bean\u003e \u003cbean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"\u003e\u003c/bean\u003e 通过注解方式（常用） 在配置文件进行驱动注册（需要使用 spring-context 的注解扫描） \u003ccontext:component-scan base-package=\"com.cskaoyan\"/\u003e \u003cmvc:annotation-driven/\u003e ","date":"2022-04-09","objectID":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:3","tags":["MVC"],"title":"Spring MVC学习笔记","uri":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"配置Controller和Url 可以通过实现接口实现，也可以通过注解实现. 实现接口实现。实现 Controller 接口，并重写 handlerRequest 方法。并在配置文件配置 url 映射。 public class HelloController implements Controller{ @Overriders public ModelView handleRequest(HttpServletRequest request, HttpServeletResponce responce){ } } \u003cbean name=\"hello\" class=\"com.cskaoyan.controller.HelloController\"\u003e\u003c/bean\u003e 通过注解实现。（常用） @Controller public class HelloController{ @RequestMapping(\"/hello\") public ModelAndView login(){ } } 可以通过 application.xml 配置文件设置 url 路径的前缀和后缀，减少路径名书写。 \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"\u003e \u003cproperty name=\"prefix\" value=\"/WEB-INF/view/\"/\u003e \u003cproperty name=\"suffix\" value=\".jsp\"/\u003e \u003c/bean\u003e ","date":"2022-04-09","objectID":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:4","tags":["MVC"],"title":"Spring MVC学习笔记","uri":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"拦截器配置（可选） SpringMVC 的处理器拦截器类似于Servlet 开发中的过滤器Filter，用于对处理器进行预处理和后处理。 实现 HandlerIntercepter 接口，并重写 preHandler 、 postHandler 和 afterCompletion 方法。 在 application.xml 文件中配置拦截器。其中 mapping 表示配置的内容对应拦截的 url 范围。 \u003cmvc:interceptors\u003e \u003cmvc:interceptor\u003e \u003cmvc:mapping path=\"/user/*\"/\u003e \u003cbean class=\"com.cskaoyan.hander.Myhandeler\"/\u003e \u003c/mvc:interceptor\u003e \u003c/mvc:interceptors\u003e preHandler ：预处理回调方法，实现处理器的预处理（如登录检查），第三个参数为响应的处理器。返回值为 boolean ，true表示继续流程（如调用下一个拦截器或处理器），false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过response来产生响应 postHandler ： 后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。 afterCompletion ： 整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中preHandle返回true的拦截器的afterCompletion 可以配置多个拦截器，拦截范围相同时，则按注册顺序执行。只要 preHandler 返回为 true 时，afterCompletion 一定会执行到。 ","date":"2022-04-09","objectID":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:5","tags":["MVC"],"title":"Spring MVC学习笔记","uri":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"其他设置 ","date":"2022-04-09","objectID":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:0","tags":["MVC"],"title":"Spring MVC学习笔记","uri":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"RequestMapping功能 url 路径映射 窄化请求。可以在 Controller 类上同时配置 RequestMapping ，类里面的所有方法都在父路径里面。 请求方法限定。使用 Request.Method 来限制请求方法。同时也可以通过其他参数配置限定其他参数。 ","date":"2022-04-09","objectID":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:1","tags":["MVC"],"title":"Spring MVC学习笔记","uri":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"Controller 方法的返回值 返回值类型可以为如下三种： ModelAndView : 返回模型视图对象，可以使用该对象来设置请求的视图。 Void ： 请求参数中必须使用 (HttpServletRequest request, HttpServeletResponce responce) ，使用 request 来设置请求视图。 String ： 返回视图对应的字符串。会自动转发到对应的视图文件上，也可也手动使用 forward 或者 redirect 转发到对应的视图的解析器上，也可以转发到其他 Controller 的 url 路径上。 return \"forward:hello.jsp\"; return \"redirect:hello.jsp\"; return \"redirct:/user/login\"; ","date":"2022-04-09","objectID":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:2","tags":["MVC"],"title":"Spring MVC学习笔记","uri":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"请求参数封装 使用 request 对象提取 在请求参数中，增加 (HttpServletRequest request, HttpServeletResponce responce) 参数，利用 request 对象根据 key 获取对应的 value 。 String str = request.getParameter(\"id\"); 基本数据类型获取 需要与请求参数 key 一一对应，即形参必须同名，通过相同的参数名提取。 将请求参数封装到 JavaBean 对象当中（常用） 需要在视图页面使用 对象.属性 来设置传递过来的 value ，如果存在多个对象时，可以封装一个含有多个对象的对象。 \u003cinput type=\"text\" name=\"user.id\"\u003e 如果在提交的过程中，使用了中文数据，则会导致，需要在配置文件 web.xml 中配置传输数据的编码格式。 \u003cfilter\u003e \u003cfilter-name\u003eebcoding\u003c/filter-name\u003e \u003cfilter-class\u003eorg.springframework.web.filter.CharacterEncodingFilter\u003c/filter-class\u003e \u003cinit-param\u003e \u003cparam-name\u003eencoding\u003c/param-name\u003e \u003cparam-value\u003eutf-8\u003c/param-value\u003e \u003c/init-param\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eebcoding\u003c/filter-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e ","date":"2022-04-09","objectID":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:3","tags":["MVC"],"title":"Spring MVC学习笔记","uri":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"请求参数类型转换 当请求的参数需要进行转换才能使用时，比如时间格式，需要对传入的数据进行格式转换。 首先配置自定义的类型转换器。通过实现 Converter 接口，重写 convert 方法来实现类型转换器。 public class MyDateCOnverter implements Converter\u003cString, Date\u003e { @Override public Date convert(String value) { SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yy-MM-dd\"); try { Date parse = simpleDateFormat.parse(value); return parse; } catch (ParseException e) { e.printStackTrace(); } return null; } } 在 application.xml 文件中，配置类型转换器。 \u003cmvc:annotation-driven conversion-service=\"myConvertorService\"/\u003e \u003cbean id=\"myConvertorService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"\u003e \u003cproperty name=\"converters\"\u003e \u003cset\u003e \u003cbean class=\"com.cskaoyan.converter.MyDateCOnverter\"/\u003e \u003cbean class=\"com.cskaoyan.converter.UserConverter\"/\u003e \u003c/set\u003e \u003c/property\u003e \u003c/bean\u003e ","date":"2022-04-09","objectID":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:4","tags":["MVC"],"title":"Spring MVC学习笔记","uri":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"请求参数集合封装 数组封装 使用 checkbox，传递多个值 \u003ch2\u003e封装数组获取参数\u003c/h2\u003e \u003cform action=\"submitArray\" method=\"post\"\u003e id1:\u003cinput type=\"checkbox\" name=\"ids\" value=\"1\"\u003e\u003cbr\u003e id2:\u003cinput type=\"checkbox\" name=\"ids\" value=\"2\"\u003e\u003cbr\u003e id3:\u003cinput type=\"checkbox\" name=\"ids\" value=\"3\"\u003e\u003cbr\u003e id4:\u003cinput type=\"checkbox\" name=\"ids\" value=\"4\"\u003e\u003cbr\u003e id5:\u003cinput type=\"checkbox\" name=\"ids\" value=\"5\"\u003e\u003cbr\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e 集合封装 使用索引设置 ArrayList 各个元素属性。同时构建一个 JavaBean 对象来接受请求参数，该对象含有对应的 List\u003cT\u003e 成员属性。 public class QueryVo { User user; String content; int count; List\u003cUser\u003e users; @Override public String toString() { return \"QueryVo{\" + \"user=\" + user + \", content='\" + content + '\\'' + \", count=\" + count + \", users=\" + users + '}'; } public List\u003cUser\u003e getUsers() { return users; } public void setUsers(List\u003cUser\u003e users) { this.users = users; } public QueryVo(User user, String content, int count) { this.user = user; this.content = content; this.count = count; } public User getUser() { return user; } public void setUser(User user) { this.user = user; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public int getCount() { return count; } public void setCount(int count) { this.count = count; } } \u003ch2\u003e封装集合获取参数\u003c/h2\u003e \u003cform action=\"submitCollection\" method=\"post\"\u003e id:\u003cinput type=\"text\" name=\"user.id\"\u003e\u003cbr\u003e username:\u003cinput type=\"text\" name=\"user.username\"\u003e\u003cbr\u003e password:\u003cinput type=\"password\" name=\"user.password\"\u003e\u003cbr\u003e phoneNumber:\u003cinput type=\"text\" name=\"user.phoneNumber\"\u003e\u003cbr\u003e content:\u003cinput type=\"text\" name=\"content\"\u003e\u003cbr\u003e count:\u003cinput type=\"text\" name=\"count\"\u003e\u003cbr\u003e user1:id:\u003cinput type=\"text\" name=\"users[0].id\"\u003e\u003cbr\u003e user1:username:\u003cinput type=\"text\" name=\"users[0].username\"\u003e\u003cbr\u003e user1:password:\u003cinput type=\"password\" name=\"users[0].password\"\u003e\u003cbr\u003e user1:phoneNumber:\u003cinput type=\"text\" name=\"users[0].phoneNumber\"\u003e\u003cbr\u003e user2:id:\u003cinput type=\"text\" name=\"users[1].id\"\u003e\u003cbr\u003e user2:username:\u003cinput type=\"text\" name=\"users[1].username\"\u003e\u003cbr\u003e user2:password:\u003cinput type=\"password\" name=\"users[1].password\"\u003e\u003cbr\u003e user2:phoneNumber:\u003cinput type=\"text\" name=\"users[1].phoneNumber\"\u003e\u003cbr\u003e user3:id:\u003cinput type=\"text\" name=\"users[2].id\"\u003e\u003cbr\u003e user3:username:\u003cinput type=\"text\" name=\"users[2].username\"\u003e\u003cbr\u003e user3:password:\u003cinput type=\"password\" name=\"users[2].password\"\u003e\u003cbr\u003e user3:phoneNumber:\u003cinput type=\"text\" name=\"users[2].phoneNumber\"\u003e\u003cbr\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e ","date":"2022-04-09","objectID":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:5","tags":["MVC"],"title":"Spring MVC学习笔记","uri":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"文件上传 图片上传需要外部依赖。 导包。导入 commons-io 和 commons-fileupload 依赖。 \u003cdependency\u003e \u003cgroupId\u003ecommons-io\u003c/groupId\u003e \u003cartifactId\u003ecommons-io\u003c/artifactId\u003e \u003cversion\u003e2.6\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-fileupload\u003c/groupId\u003e \u003cartifactId\u003ecommons-fileupload\u003c/artifactId\u003e \u003cversion\u003e1.4\u003c/version\u003e \u003c/dependency\u003e 配置解析器。在 application.xml 配置解析器。（id 必须固定，否则异常） \u003cbean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"\u003e \u003c/bean\u003e 接受参数中，增加 MultipartFile myfile 参数，使用 transferTo 方法传输的文件写入本地。 String filePath = \"path/to/file\"; File file = new File(filePath); myfile.transferTo(file); ","date":"2022-04-09","objectID":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:4:6","tags":["MVC"],"title":"Spring MVC学习笔记","uri":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"参考资料 [深入源码分析SpringMVC执行过程] ","date":"2022-04-09","objectID":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:5:0","tags":["MVC"],"title":"Spring MVC学习笔记","uri":"/posts/spring-mvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"前言 在 Spring 框架中，需要使用事务管理对数据库进行操作，以实现事务的 ACID 特性。 ","date":"2022-04-05","objectID":"/posts/spring-transaction%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:1:0","tags":["Transaction"],"title":"Spring Transaction学习笔记","uri":"/posts/spring-transaction%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"事务的基本实现 Spring 框架提供了三个对象来管理事务。 PlatformTransactionManager ：平台事务管理器，spring要管理事务，必须使用事务管理器。事务配置的过程中，也必须配置事务管理器，常见的事务管理器有： DataSourceTransactionManager ，在jdbc开发中采用 JdbcTemplate 。(常用) HibernateTransactionManage ，hibernate开发时事务管理器，整合hibernate。 常用 api 有三个： TransactionStatus getTransaction(TransactionDefinition definition) ： 事务管理器 通过“事务详情”，获得“事务状态”，从而管理事务。 获取事务状态后，Spring根据传播行为来决定如何开启事务 void commit(TransactionStatus status) ： 根据状态提交 void rollback(TransactionStatus status) ： 根据状态回滚 TransactionDefinition ：这个接口的作用就是定义事务的名称、隔离级别、传播行为、超时时间长短、只读属性等。 TransactionStatus ： 这个接口的作用就是获取事务的状态（回滚点、是否完成、是否新事物、是否回滚）属性 ","date":"2022-04-05","objectID":"/posts/spring-transaction%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:0","tags":["Transaction"],"title":"Spring Transaction学习笔记","uri":"/posts/spring-transaction%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"基本流程 首先需要导入 spring-tx 包。 实现方式有四种： 使用事务模板完成 向容器中注册 TransactionTemplate 对象，然后在Service 类中引入事务管理器 \u003cbean id=\"myUserServiceImpl\" class=\"com.cskaoyan.service.UserServiceImpl\"\u003e \u003cproperty name=\"dao\" ref=\"accountdaoImpl\"\u003e\u003c/property\u003e \u003cproperty name=\"transactionTemplate\" ref=\"myTransactionTemplate\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003cbean id=\"myTransactionTemplate\" class=\"org.springframework.transaction.support.TransactionTemplate\"\u003e \u003cproperty name=\"transactionmanager\" ref=\"myTransactionmanager\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003cbean id=\"myTransactionmanager\" class=\"org.springframework.transaction.support.TransactionManager\"\u003e \u003cproperty name=\"datasource\" ref=\"mydatasource\"\u003e\u003c/property\u003e \u003c/bean\u003e @Autowired TransactionTemplate transactionTemplate; public void setTransactionTemplate(TransactionTemplate transactionTemplate){ this.transactionTemplate = transactionTemplate; } 在需要执行的事务业务中，使用 transactionTemplate 对象执行 execute(new TransactionCallbackWithoutResult(){})方法。在匿名类中写事务代码。 transactionTemplate.execute(new TransactionCallbackWithoutResult(){ // 执行所需要的事务 }) 使用配置文件配置事务 \u003cbean id=\"myServiceProxyFactoryBean\" class=\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\"\u003e \u003cproperty name=\"proxyInterface\" value=\"com.cskaoyan.service.UserService\"\u003e\u003c/property\u003e \u003cproperty name=\"target\" ref=\"myServiceImpl\"\u003e\u003c/property\u003e \u003cproperty name=\"transactionManager\" ref=\"myTransactionManager\"\u003e\u003c/property\u003e \u003cpreoerty name=\"transactionAttribues\"\u003e \u003cprops\u003e \u003cprop ket=\"transferMoney\"\u003ePROPAGATION_REQUIRED,ISOLATION_REPEATABLE_READ\u003c/prop\u003e \u003c/props\u003e \u003c/preoerty\u003e \u003c/bean\u003e \u003cbean id=\"myTransactionManager\" class=\"org.springframework.transaction.support.TransactionManager\"\u003e \u003cproperty name=\"datasource\" ref=\"mydatasource\"\u003e\u003c/property\u003e \u003c/bean\u003e 使用事务模板实现，通过使用 spring-tx 配置，首先使用 spring-tx 的schema \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!-- bean definitions here --\u003e \u003c/beans\u003e 接着配置事务，与 aop:advisor 配合一起使用。 \u003caop:config\u003e \u003caop:point-cut id=\"mypointcut\" expression=\"execution(* com..impl...*(..))\"/\u003e \u003caop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"mypointcut\"/\u003e \u003c/aop:config\u003e \u003ctx:advice id=\"txAdvice\" transaction-manager=\"myTransactionManager\"\u003e \u003ctx:attribues\u003e \u003ctx:method name=\"transferMoney\" propagation=\"REQUIRED\" isolation=\"DEFAULT\"/\u003e \u003c/tx:attribues\u003e \u003c/tx:advice\u003e 通过spring tx 注解实现，在需要执行事务而方法中使用注解。（常用方式） 首先配置注解驱动 \u003ctx:annotation-direver transaction-manager=\"txManager\"/\u003e 接着在所需要执行事务的方法中配置注解 @Transactional(isolation=Isolation.Default, propagation=Propagation.REQUIRED) ","date":"2022-04-05","objectID":"/posts/spring-transaction%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:1","tags":["Transaction"],"title":"Spring Transaction学习笔记","uri":"/posts/spring-transaction%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"前言 Spring 提供了 JDBCTemplate 来操作jdbc，而让用户只需要关注sql语句即可。 ","date":"2022-04-05","objectID":"/posts/spring-jdbc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:1:0","tags":["JDBC"],"title":"Spring JDBC学习笔记","uri":"/posts/spring-jdbc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"JDBC使用流程 ","date":"2022-04-05","objectID":"/posts/spring-jdbc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:0","tags":["JDBC"],"title":"Spring JDBC学习笔记","uri":"/posts/spring-jdbc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"使用JDBCTemplate 导包。jdbc 所需要而依赖不在 spring 四个核心当中，需要额外导包。需要导入一个数据库驱动、一个连接池取代、 spring-jdbc 。数据库以 mysql 为例 \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.12\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.mchange\u003c/groupId\u003e \u003cartifactId\u003ec3p0\u003c/artifactId\u003e \u003cversion\u003e0.9.5.5\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.3.17\u003c/version\u003e \u003c/dependency\u003e 创建连接池 ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(); comboPooledDataSource.setDriverClass(\"com.mysql.cj.jdbc.Driver\"); comboPooledDataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/j13_jdbc_template?serverTimezone=GMT\"); comboPooledDataSource.setUser(\"root\"); comboPooledDataSource.setPassword(\"admin\"); 创建 jdbc 模板 JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(comboPooledDataSource); 模板使用 String s = jdbcTemplate.queryForObject(sql, String.class, 0); ","date":"2022-04-05","objectID":"/posts/spring-jdbc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:1","tags":["JDBC"],"title":"Spring JDBC学习笔记","uri":"/posts/spring-jdbc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"使用JDBCDaoSupport 方法与上述不同 首先每个DAO都需要声明template 而且要写set方法 在配置文件中配置JDBC连接池 \u003cbean id=\"myDatasource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"\u003e \u003cproperty name=\"driverClass\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/j13_jdbc_template?serverTimezone=GMT\"/\u003e \u003cproperty name=\"user\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"admin\"/\u003e \u003c/bean\u003e \u003cbean\u003e \u003cproperty name=\"jdbcTemplate\" ref=\"myJDBCTemplate\"\u003e\u003c/property\u003e \u003cproperty name=\"datasource\" ref=\"myDatasource\"\u003e\u003c/property\u003e \u003c/bean\u003e JDBCDaoSupport 中含有 JdbcTemplate 对象，直接使用即可 ","date":"2022-04-05","objectID":"/posts/spring-jdbc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:2","tags":["JDBC"],"title":"Spring JDBC学习笔记","uri":"/posts/spring-jdbc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"前言 AOP 全称为 Aspect Oriented Programming，即面向切片编程。与 OOP (Object Oriented Programming) 面向对象编程不同的是，AOP将系统看作为多个对象的交互，通过切面，对系统的不同关注点，切分为多个平面，利用 AOP ，可以更好的对过往代码进行复用。 ","date":"2022-04-05","objectID":"/posts/spring-aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:1:0","tags":["AOP"],"title":"Spring AOP学习笔记","uri":"/posts/spring-aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"AOP基础 ","date":"2022-04-05","objectID":"/posts/spring-aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:0","tags":["AOP"],"title":"Spring AOP学习笔记","uri":"/posts/spring-aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"术语 AOP 的基本用语： Target：目标类，需要代理的类 JointPoint：连接点，被代理的对象中需要增强的点，比如方法 PointCut：切入点，已经被增强的连接点 Advice：通知，代理对象执行到 连接点所需要执行的操作 Weaver：植入，把通知应用到代理对象当中的过程 Proxy ：代理类，动态代理 ","date":"2022-04-05","objectID":"/posts/spring-aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:1","tags":["AOP"],"title":"Spring AOP学习笔记","uri":"/posts/spring-aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"实现方式 AOP 的底层采用代理机制方式实现。AOP 功能实现方式主要有三种 手动实现。使用 jdk 或者 cglib 动态代理实现 使用 Spring AOP api 实现。该方法需要手动实现 AOP 的接口，并对指定方法进行增加 使用 aspectj 实现。常用方式，实现过程如下 导入 aspectjweaver 包，在 application.xml 中引入 aop 的头文件（后续可以使用配置类完成） \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!-- bean definitions here --\u003e \u003c/beans\u003e 配置切入面、切入点和通知 \u003caop:config\u003e \u003c!-- --\u003e \u003caop:aspect ref=\"myAspect（切片的id）\"\u003e \u003caop:pointcut id=\"mypointcut\" expression=\"execution(public boolean com.cskaoyan.dao.impl.UserServiceImpl.register(String,String))\"/\u003e \u003caop:pointcut id=\"mypointcut2\" expression=\"execution(* com..impl..*(..))\"/\u003e \u003caop:before method=\"before13\" pointcut-ref=\"mypointcut2\"/\u003e \u003caop:around method=\"myAround\" pointcut-ref=\"mypointcut2\"/\u003e \u003caop:after method=\"myAfter\" pointcut-ref=\"mypointcut2\"/\u003e \u003caop:after-throwing method=\"myAfterThrowing\" pointcut-ref=\"mypointcut2\" throwing=\"myThrowable\"/\u003e \u003caop:after-returning method=\"myAfterReturning\" pointcut-ref=\"mypointcut2\" returning=\"myReturnResult\"/\u003e \u003c/aop:aspect\u003e \u003c!-- \u003caop:aspect ref=\"myAspect2\"\u003e \u003caop:before method=\"before13\" pointcut-ref=\"mypointcut\"/\u003e \u003c/aop:aspect\u003e --\u003e \u003c/aop:config\u003e ","date":"2022-04-05","objectID":"/posts/spring-aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:2","tags":["AOP"],"title":"Spring AOP学习笔记","uri":"/posts/spring-aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"AspectJ 基于 AOP 框架，Spring2.0 之后支持了基于 AspectJ 的切入点表达式，可以在不改动原代码的的前提下，自定义开发，植入代码。 AspectJ 流程图 语法：execution（修饰符 返回值 包 类 方法名(参数类型) throws 异常 ，其中修饰符一般省略，修饰符可以使用 * 表示任意; 返回值不可以省略，但是可以使用 * 表示任意，若是非 java.lang 下的类型，需要写全类名; 方法不可以省略，可以使用 * 表示任意; 参数可以使用 (..) 表示参数任意; throws 异常可以省略。 通知类型： Before ： 在切入点之前执行。 参数类型的校验。 前置通知 AtterReturning ： 周在切入点之后执行。后置通知，可以对结果进行检查，增加log Around ：环绕通知 在切入点之前和之后都会执行。增加事务等等。 AfterThrowing ： 抛出异常的时候执行通知。正常情况下走不到。只有发生异常的情况下才会去通知，比如记录一些日志。 After ： 在finally语句里。不管切入点是否有异常发生都会执行。 实现方式： 在配置文件 xml 中书写 \u003caop:before method=\"MyBefore\" pointcut-ref=\"myPointCut\"/\u003e \u003caop:after-returning method=\"MyAfterReturning\" pointcut-ref=\"myPointCut\"/\u003e \u003caop:around method=\"MyAround\" pointcut-ref=\"myPointCut\"/\u003e \u003caop:afterthrowing method=\"MyAfterThrowing\" pointcut-ref=\"myPointCut\"/\u003e \u003caop:after method=\"MyAfter\" pointcut-ref=\"myPointCut\"/\u003e 使用注解实现，需要现在配置文件中引入自动代理 \u003caop:aspectj-autoproxy/\u003e @Before(\"execution(public java.utils.list.com..*.addUser(..))\") @AfterReturning(value = \"execution(public java.utils.list.com..*.addUser(..))\"\", returning = \"res) @Around(\"execution(public java.utils.list.com..*.addUser(..))\") @AfterThrowing(value = \"execution(public java.utils.list.com..*.addUser(..))\", throwing = \"exception\") @After(\"execution(public java.utils.list.com..*.addUser(..))\") ","date":"2022-04-05","objectID":"/posts/spring-aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:3:0","tags":["AOP"],"title":"Spring AOP学习笔记","uri":"/posts/spring-aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"前言 IOC 全称为 Inverse of control ，即控制反转。通过向 Spring 的IOC容器中注册，从而使得获得对象的过程进行反转，即不再手动生成所需要的对象，而是IOC容器向应用程序注入某个对象。 ","date":"2022-04-05","objectID":"/posts/spring-ioc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:1:0","tags":["IOC"],"title":"Spring IOC学习笔记","uri":"/posts/spring-ioc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"IOC基础 ","date":"2022-04-05","objectID":"/posts/spring-ioc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:0","tags":["IOC"],"title":"Spring IOC学习笔记","uri":"/posts/spring-ioc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"对象注册 首先需要导入 spring-contex 包，该包包含四个核心和一个依赖，剩余三个核心分别为 spring-aop 、spring-bean 和 spring-core，一个依赖为 spring-expression。 同时在配置中引入头文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003c!-- bean definitions here --\u003e \u003c/beans\u003e 接着在配置文件中进行对象注册 \u003cbean name=\"userService\" class=\"com.cskaoyan.service.impl.UserServiceImpl\"/\u003e 此时，IOC容器中就包含了所该类的一个的对象。 ","date":"2022-04-05","objectID":"/posts/spring-ioc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:1","tags":["IOC"],"title":"Spring IOC学习笔记","uri":"/posts/spring-ioc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"对象设置 在配置文件中设置对象。利用 property 标签设置，name 表示为类中的 set 方法的后缀。如果设置的为对象，则使用 ref= 来设置对象，若是值，则使用 value= 来设置。 \u003cbean name=\"userService\" class=\"com.cskaoyan.service.impl.UserServiceImpl\"\u003e \u003cproperty name=\"userDao\" ref=\"UserDao\"/\u003e \u003cbean\u003e 默认是通过无参构造方法创建对象（也是主要使用方法），如没有无参构造方法时，需要使用有参构造方法，配置 \u003cconstructor-arg\u003e 标签来通过调用有参构造方法来创建对象。 \u003cbean name=\"userService\" class=\"com.cskaoyan.service.impl.UserServiceImpl\"\u003e \u003cconstructor-arg name=\"id\" value=\"001\"/\u003e \u003cconstructor-arg name=\"name\" value=\"java\"/\u003e \u003cbean\u003e 也可以通过实例工厂或静态工厂来获得对象（了解即可） 在IOC容器注册的对象是单例模式，可以通过不同的ID来创建同一个类的不同的对象，也可以更改Bean的作用域（singleton更改为prototype），使得每次获得的对象都是一个新的实例。 ","date":"2022-04-05","objectID":"/posts/spring-ioc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:2","tags":["IOC"],"title":"Spring IOC学习笔记","uri":"/posts/spring-ioc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"注解装配对象 通过配置文件，自动扫描带有注解的类，将类进行注册。配置文件设置如下 \u003ccontext:component-scan base-package=\"com.cskaoyan\"\u003e\u003c/context:component-scan\u003e @Component取代，@Component(“id”) 取代 在 web 开发中，使用衍生注解取代 @Repository ：dao层 @Service：service层 @Controller：web层 属性注入 普通值：@Value(\"\") 引用值：@Autowired、 @Autowired @Qualifier(“名称”) 或 @Resource(name = “名称”) ","date":"2022-04-05","objectID":"/posts/spring-ioc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:3","tags":["IOC"],"title":"Spring IOC学习笔记","uri":"/posts/spring-ioc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["Java Spring"],"content":"Test配置 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(\"classpath:application.xml\") ","date":"2022-04-05","objectID":"/posts/spring-ioc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/:2:4","tags":["IOC"],"title":"Spring IOC学习笔记","uri":"/posts/spring-ioc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/"},{"categories":["算法"],"content":"前言 在图论中，找到单点 s 到单点 t 的最大流，称为最大流问题，其中 s-t 的最大流等于 s-t 的最小割，使用 Ford–Fulkerson 算法可以确认最大流。 维基百科 最大流 ","date":"2022-04-05","objectID":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/:1:0","tags":["最大流最小割"],"title":"图论 最大流和最小割","uri":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/"},{"categories":["算法"],"content":"最大流 求由 s 发出，t 每秒接受的最大流量，称为最大流问题。首先可以利用贪心算法，确认 s-\u003et 的一条路径，但该路径不一定是最大流。Ford–Fulkerson 算法提出了一个残余网络，也叫增广路，将之前的s-\u003et路径的流进行反转，同时原网络减去 s-\u003et 的流量，二者合并构成残余网络。同时在根据残余网络找到 s-\u003et 的路径。根据上述规则，不断的重复迭代，直到 s-\u003et 没有到达路径流，则可以得到最大流（最大流量在每次迭代的过程中都是累加的，因为只需要计算 s 到 t 的流量，终点 t 每次迭代后流入流量都是在累加）。 将流量路径反转的目的是在于可以重新规划边的流量流向，若后续还存在 s-\u003et 路径，且需要更改反转的路径大小，则表面需要调整之前的流量大小，以此提高 s 到 t 的流量大小。 ","date":"2022-04-05","objectID":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/:2:0","tags":["最大流最小割"],"title":"图论 最大流和最小割","uri":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/"},{"categories":["算法"],"content":"最小割 图的割，指的是对于某个顶点集合 $S \\subseteq V$ ，从 S 出发指向外部那些边的集合，记为割(S, V\\S)。这些边的流量容量之和称为割的容量。通俗来说，就是将一个连通图，划分为两个不连通的子图，而割代表的是再划分时，所需要去掉的边。为了让 s 和 t 分别处于不同的子图，所需要的最小边的容量，记为最小割。当 s 和 t 处于不同的子图时，s 和 t 即不存在相连通的路径。 ","date":"2022-04-05","objectID":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/:3:0","tags":["最大流最小割"],"title":"图论 最大流和最小割","uri":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/"},{"categories":["算法"],"content":"基本公式 记$f$为s-t的流量，则$f = (s出边的总流量)$ ，对于$v \\in S${s} 时，又有 $(v的出边的总流量) = (v的入边的总流量)$，所以 $f = (S的出边的总流量) - (S的入边的总流量)$ ，所以 $f \\le (割的流量)$。 对于残余网络来说，$f^‘$ 对应的残余网路中s 到可达 v 的的集合为 S ，因为$f^‘$ 不存在 s-\u003et 的路径，所以(S, V\\S)就是一个s-t割。根据 $f^‘ = (S的出边的总流量) - (S的入边的总流量) = (割的流量)$ ，所以$f^‘$ 为最大流。 ","date":"2022-04-05","objectID":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/:4:0","tags":["最大流最小割"],"title":"图论 最大流和最小割","uri":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/"},{"categories":["算法"],"content":"代码实现 可以利用DFS或者BFS进行路径搜索，并不断进行迭代，直到两点之间没有路径，即可以达到最大流量。 // Ford-Fulkerson algorith in Java import java.util.LinkedList; class FordFulkerson { static final int V = 6; // Using BFS as a searching algorithm boolean bfs(int Graph[][], int s, int t, int p[]) { boolean visited[] = new boolean[V]; for (int i = 0; i \u003c V; ++i) visited[i] = false; LinkedList\u003cInteger\u003e queue = new LinkedList\u003cInteger\u003e(); queue.add(s); visited[s] = true; p[s] = -1; while (queue.size() != 0) { int u = queue.poll(); for (int v = 0; v \u003c V; v++) { if (visited[v] == false \u0026\u0026 Graph[u][v] \u003e 0) { queue.add(v); p[v] = u; visited[v] = true; } } } return (visited[t] == true); } // Applying fordfulkerson algorithm int fordFulkerson(int graph[][], int s, int t) { int u, v; int Graph[][] = new int[V][V]; for (u = 0; u \u003c V; u++) for (v = 0; v \u003c V; v++) Graph[u][v] = graph[u][v]; int p[] = new int[V]; int max_flow = 0; # Updating the residual calues of edges while (bfs(Graph, s, t, p)) { int path_flow = Integer.MAX_VALUE; for (v = t; v != s; v = p[v]) { u = p[v]; path_flow = Math.min(path_flow, Graph[u][v]); } for (v = t; v != s; v = p[v]) { u = p[v]; Graph[u][v] -= path_flow; Graph[v][u] += path_flow; } // Adding the path flows max_flow += path_flow; } return max_flow; } public static void main(String[] args) throws java.lang.Exception { int graph[][] = new int[][] { { 0, 8, 0, 0, 3, 0 }, { 0, 0, 9, 0, 0, 0 }, { 0, 0, 0, 0, 7, 2 }, { 0, 0, 0, 0, 0, 5 }, { 0, 0, 7, 4, 0, 0 }, { 0, 0, 0, 0, 0, 0 } }; FordFulkerson m = new FordFulkerson(); System.out.println(\"Max Flow: \" + m.fordFulkerson(graph, 0, 5)); } } ","date":"2022-04-05","objectID":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/:5:0","tags":["最大流最小割"],"title":"图论 最大流和最小割","uri":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/"},{"categories":["算法"],"content":"参考资料 图论：最大流最小割详解 Ford-Fulkerson Algorithm ","date":"2022-04-05","objectID":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/:6:0","tags":["最大流最小割"],"title":"图论 最大流和最小割","uri":"/posts/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%89%B2.html/"},{"categories":["算法"],"content":"前言 线段树擅长处理区间，形状如下图 （图片取自 维基百科 线段树)。线段树是一颗完美二叉树，其叶子存储元素值值，非叶子节点存储对应区间的值，根节点维护整个区间，对区间的操作可以在 O(log n) 时间复杂度完成。 Transformer 模型框架)\" Transformer 模型框架) ","date":"2022-04-04","objectID":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/:1:0","tags":["线段树"],"title":"线段树","uri":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/"},{"categories":["算法"],"content":"算法思想 如果要对连续区间重复多次操作时，比如求区间的最值/和等，利用线段树是可以从 O(m * n) 降低至 O(m * logn) ，m 为操作次数， n 为总区间长度。算法基本过程： 构造线段树。利用所给的区间元素，构造线段树。由于父节点需要存储两个子节点运算后的值，可以采用 自底向上 构造线段树，比如使用递归方法。 更改线段树。更改某元素的值时，也需要更改父节点以上的值，和构造阶段一样，采用 自底向上 的方法依次更改。 求区间值。求区间则使用 自顶向下 方法实现取值，根据父节点的区间范围与求取的范围，不断的递归向下取值，同时根据所求范围将区间进行拆分为若干个极大区间，直到左右区间达到所给而范围。 ","date":"2022-04-04","objectID":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/:2:0","tags":["线段树"],"title":"线段树","uri":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/"},{"categories":["算法"],"content":"再优化 当需要改变区间内某些元素值时，可以在所对应区间内（包括父节点的区间）进行标记，从而记录更改，而当需要查询到该区间时，在依次递归进行更改，减少因为更改而增加的复杂度。 ","date":"2022-04-04","objectID":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/:2:1","tags":["线段树"],"title":"线段树","uri":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/"},{"categories":["算法"],"content":"代码实现 ","date":"2022-04-04","objectID":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/:3:0","tags":["线段树"],"title":"线段树","uri":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/"},{"categories":["算法"],"content":"区间求和 307. 区域和检索 - 数组可修改 给你一个数组 nums ，请你完成两类查询。 其中一类查询要求 更新 数组 nums 下标对应的值 另一类查询要求返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 ，其中 left \u003c= right 实现 NumArray 类： NumArray(int[] nums) 用整数数组 nums 初始化对象 void update(int index, int val) 将 nums[index] 的值 更新 为 val int sumRange(int left, int right) 返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 （即，nums[left] + nums[left + 1], ..., nums[right]） 线段树各层数量为等比数量，最大需要 4n 空间。根据二叉树性质，父节点 i 的两个子节点对应的索引分别为 2 * i + 1 和 2 * i + 2 ，i 从0开始编号，从而可以使用数组来表示线段树。 class NumArray { private int[] segmentTree; private int n; public NumArray(int[] nums) { n = nums.length; segmentTree = new int[nums.length * 4]; build(0, 0, n - 1, nums); } public void update(int index, int val) { change(index, val, 0, 0, n - 1); } public int sumRange(int left, int right) { return range(left, right, 0, 0, n - 1); } private void build(int node, int s, int e, int[] nums) { if (s == e) { segmentTree[node] = nums[s]; return; } int m = s + (e - s) / 2; build(node * 2 + 1, s, m, nums); build(node * 2 + 2, m + 1, e, nums); segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2]; } private void change(int index, int val, int node, int s, int e) { if (s == e) { segmentTree[node] = val; return; } int m = s + (e - s) / 2; if (index \u003c= m) { change(index, val, node * 2 + 1, s, m); } else { change(index, val, node * 2 + 2, m + 1, e); } segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2]; } private int range(int left, int right, int node, int s, int e) { if (left == s \u0026\u0026 right == e) { return segmentTree[node]; } int m = s + (e - s) / 2; if (right \u003c= m) { return range(left, right, node * 2 + 1, s, m); } else if (left \u003e m) { return range(left, right, node * 2 + 2, m + 1, e); } else { return range(left, m, node * 2 + 1, s, m) + range(m + 1, right, node * 2 + 2, m + 1, e); } } } 链表实现，因为构造线段树采用 自顶向下 实现，所以使用了前缀和来构造线段树。 class TreeNode{ int val; int low; int high; TreeNode left; TreeNode right; TreeNode parent; } class NumArray { int n; TreeNode root; int[] prefix; int sum; public NumArray(int[] nums) { n = nums.length; root = new TreeNode(); prefix = new int[n]; prefix[0] = nums[0]; for(int i = 1; i \u003c n; i++){ prefix[i] = prefix[i - 1] + nums[i]; } root.val = prefix[n-1]; root.low = 0; root.high = n -1; root.left = init(root, nums, 0, (n-1) / 2); root.right = init(root, nums, (n-1) / 2 + 1, n - 1); } public TreeNode init(TreeNode root, int[] nums, int low, int high){ if(low \u003e high){ return null; } TreeNode child = new TreeNode(); child.parent = root; child.low = low; child.high = high; if(low == 0){ child.val = prefix[high]; }else{ child.val = prefix[high] - prefix[low - 1]; } if(low == high){ return child; }else{ child.left = init(child, nums, low, (low + high) / 2); child.right = init(child, nums, (low + high) / 2 + 1, high); return child; } } public void update(int index, int val) { TreeNode p = root; int mid = (p.low + p.high) / 2; while(p.low != index || p.high != index){ if(mid \u003c index){ p = p.right; }else{ p = p.left; } mid = (p.low + p.high) / 2; } p.val = val; while(p.parent != null){ if(p.parent.right != null){ p.parent.val = p.parent.left.val + p.parent.right.val; }else{ p.parent.val = p.parent.left.val; } p = p.parent; } } public int sumRange(int left, int right) { sum = 0; TreeNode p = root; if(left == root.low \u0026\u0026 right == root.high){ return root.val; } return getSum(p, left, right); } public void getSum(TreeNode root, int left, int right) { if(root == null){ return; } int mid = (root.low + root.high) / 2; if(root.low == left \u0026\u0026 root.high == right) { sum = root.val; return; } if(root.low == left \u0026\u0026 root.high \u003c right) { sum += root.val; return ; } if(root.low \u003e left \u0026\u0026 root.high \u003c right) { sum += root.val; return; } if(root.low \u003e left \u0026\u0026 root.high == right) { sum += root.val; return; } if(mid \u003c= right) { getSum(root.right, left, right); } getSum(root.left, left, right); } } ","date":"2022-04-04","objectID":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/:3:1","tags":["线段树"],"title":"线段树","uri":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/"},{"categories":["算法"],"content":"参考资料 线段树 OI Wiki 线段树 ","date":"2022-04-04","objectID":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/:4:0","tags":["线段树"],"title":"线段树","uri":"/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91.html/"},{"categories":["算法"],"content":"动态规划","date":"2022-04-03","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/","tags":["算法","动态规划"],"title":"动态规划","uri":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/"},{"categories":["算法"],"content":"前言 动态规划与分治方法类似，通过组合子问题解决原问题。动态规划应用与子问题重叠的情况，及不同的子问题具有公共 的子子问题的解。动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。 适用情况 (摘自 维基百科 动态规划) ： 最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。 无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。 ","date":"2022-04-03","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/:1:0","tags":["算法","动态规划"],"title":"动态规划","uri":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/"},{"categories":["算法"],"content":"解题思路 动态规划算法主要通过四个步骤来设计 刻画一个最优解的结构特征 递归定义最优解 计算最优解的值（自底向上或带备忘的自顶向下，大部分使用自底向上) 利用计算的信息构造最优解 ","date":"2022-04-03","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/:2:0","tags":["算法","动态规划"],"title":"动态规划","uri":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/"},{"categories":["算法"],"content":"代码实现 以 剑指 Offer II 093. 最长斐波那契数列 题目为例 如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是 斐波那契式 的： n \u003e= 3 对于所有 i + 2 \u003c= n，都有 X_i + X_{i+1} = X_{i+2} 给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。 （回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列） 斐波纳契数列长度主要观察最后两位，若后续值可以等于最后两位的和，则表示可以将该数加入对应的数列当中。于是可以使用dp[i][j]：表示以arr[i] , arr[j]结尾的斐波那契数列的最大长度。若 arr[j] - arr[i] 存在数列当中，且索引小于 i 时，记为 k ，则 dp[i][j] 需要进行更新，dp[i][j] = max(dp[i][j], dp[k][i] + 1) 。 为了降低确认 差值 是否存在数列当中且索引低于 i ，可以先将数列存入哈希表当中，其中 Key 为值， Value 为索引。 class Solution { public int lenLongestFibSubseq(int[] arr) { int n = arr.length; Map\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); for(int i = 0; i \u003c n; i++){ map.put(arr[i], i); } int[][] dp = new int[n][n]； int max = 0; for(int i = 0; i \u003c n - 1; i++) { for(int j = i + 1; j \u003c n; j++) { int temp = arr[j] - arr[i]; int index = map.getOrDefault(temp, -1); if(index \u003e -1 \u0026\u0026 index \u003c i) { dp[i][j] = dp[index][i] + 1; max = Math.max(max, dp[i][j] + 2); } } } return max \u003e 2 ? max : 0; } } 注：解该题的重要思路就是确认 dp 数组表示的内容，即表示到达 i 和 j 的斐波纳契数列最大长度。 ","date":"2022-04-03","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/:3:0","tags":["算法","动态规划"],"title":"动态规划","uri":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/"},{"categories":["算法"],"content":"再优化 更新 dp 数组时，上述代码采用的是暴力更新。因为数列是已经排序好了的，可以采用双指针进行遍历更新，从而减少时间复杂度，同时也不在需要哈希表了。 class Solution { public int lenLongestFibSubseq(int[] arr) { int n = arr.length, max = 0; int[][] dp = new int[n][n]; for(int i = 2 ; i \u003c n ; i++){ int j = 0, k = i-1; while(j \u003c k){ if(arr[j] + arr[k] == arr[i]){ if(dp[j][k] == 0){ dp[k][i] = 3; }else{ dp[k][i] = Math.max(dp[j][k]+1, dp[k][i]); } max = Math.max(max, dp[k][i]); j++;k--; } else if(arr[j] + arr[k] \u003c arr[i]){ j++; }else { k--; } } } return max; } } ","date":"2022-04-03","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/:3:1","tags":["算法","动态规划"],"title":"动态规划","uri":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/"},{"categories":["算法"],"content":"参考资料 动态规划 状态定义很是重要！ 算法导论 ","date":"2022-04-03","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/:4:0","tags":["算法","动态规划"],"title":"动态规划","uri":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html/"},{"categories":["算法"],"content":"博弈论常见案例","date":"2022-04-02","objectID":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/","tags":["算法","双博弈论"],"title":"博弈论","uri":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/"},{"categories":["算法"],"content":"前言 博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。表面上不同的相互作用可能表现出相似的激励结构（incentive structure），所以它们是同一个游戏的特例。 ","date":"2022-04-02","objectID":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/:1:0","tags":["算法","双博弈论"],"title":"博弈论","uri":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/"},{"categories":["算法"],"content":"博弈论基本解法 由于博弈论都是在考虑最优解的情况下进行的步骤，所以只需要知道在各个步骤的的必败必胜必和情况，并以此进行规划就可以知道最后的胜负状况。其中最重要的是，是确定必胜/必败/必和的条件。 ","date":"2022-04-02","objectID":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/:2:0","tags":["算法","双博弈论"],"title":"博弈论","uri":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/"},{"categories":["算法"],"content":"案例一 异或数列 ： Alice 和 Bob 正在玩一个异或数列的游戏。初始时，Alice 和 Bob 分别有一个整数 a 和 b，有一个给定的长度为 n 的公共数列 $X_1, X_2, · · · , X_n$Alice 和 Bob 轮流操作，Alice 先手，每步可以在以下两种选项中选一种： 选项 1：从数列中选一个 Xi 给 Alice 的数异或上，或者说令 a 变为 a ⊕ $X_i$。（其中 ⊕ 表示按位异或） 选项 2：从数列中选一个 Xi 给 Bob 的数异或上，或者说令 b 变为 b ⊕ $X_i$。 每个数 Xi 都只能用一次，当所有 $X_i$ 均被使用后（n 轮后）游戏结束。游戏结束时，拥有的数比较大的一方获胜，如果双方数值相同，即为平手。现在双方都足够聪明，都采用最优策略，请问谁能获胜。（$n \u003c 2^{20}$） 首先确认游戏的必胜/必败/必和情况。其中必和情况为：A=B ，所以 A^B = 0 ，所以只需要对各个数字异或判断是否为 0 即可。剩下比较异或结果的数字大小，只需要看最高位即可，故只需要统计一下各个位 1 的个数。由题目可知，各个数字都可以由 20 位表示。 必和：$X_0$ ⊕ $X_i$ ⊕ $X_n$ = 0 i = 1, 2, …, n -1 必胜/必败：最高位，1 的个数位偶数，则下一位判断。奇数时 1 的个数为 1 时，则先手获胜 大于 1 时，总数字个数位偶数时，先手必败 大于 1 时，总数字个数位奇数时，先手必胜 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); int T = in.nextInt(); int[] ans = new int[T]; long sum = 1; for(int i = 0; i \u003c T; i++) { int n = in.nextInt(); int[] count = new int[20]; sum = 0; for(int j = 0; j \u003c n; j++) { long num = in.nextLong(); int temp = 1; int k = 0; sum = sum ^ num; for(; k \u003c 20; k++) { if((num \u0026 temp) == temp) { count[k]++; } temp \u003c\u003c= 1; } } if(sum == 0) { ans[i] = 0; // System.out.println(0); continue; } int k = 19; for(; k \u003e= 0; k--) { if(count[k] == 1) { ans[i] = 1; // System.out.println(1); break; }else if(count[k] % 2 == 1 \u0026\u0026 n % 2 == 0) { ans[i] = -1; // System.out.println(-1); break; }else if(count[k] % 2 == 1 \u0026\u0026 n % 2 == 1) { ans[i] = 1; // System.out.println(1); break; } } } for(int i = 0; i \u003c T; i++) { System.out.println(ans[i]); } } } ","date":"2022-04-02","objectID":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/:2:1","tags":["算法","双博弈论"],"title":"博弈论","uri":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/"},{"categories":["算法"],"content":"案例二 著名的 Nim游戏 ： 有 n 堆石子，每堆各有 $a_i$ 颗石子。Alice 和 Bob 轮流从非空的石子堆取走至少一颗石子。Alice 先取，取光所有石子的一方获胜。当双方采取最优策略时，谁会获胜？ 同样，首先确认该游戏必胜/必败/必和情况。有如下结论成立 $$a_1 XOR a_2 XOR … XOR a_n != 0 —\u003e 必胜态 $$ $$a_1 XOR a_2 XOR … XOR a_n == 0 —\u003e 必败态 $$ 其中 XOR 表示异或。 ","date":"2022-04-02","objectID":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/:2:2","tags":["算法","双博弈论"],"title":"博弈论","uri":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/"},{"categories":["算法"],"content":"参考 博弈论 挑战程序设计竞赛 蓝桥杯2021年第十二届省赛真题-异或数列 ","date":"2022-04-02","objectID":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/:3:0","tags":["算法","双博弈论"],"title":"博弈论","uri":"/posts/%E5%8D%9A%E5%BC%88%E8%AE%BA.html/"},{"categories":["Java 基础"],"content":"Comparator类的compare方法重写","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["Java 基础"],"content":"前言 做算法题时，经常遇到需要对某些数据结构的 compare 方法重写，比如 PriorityQueue，但 Java 默认实现的优先队列为小顶堆，即最小的优先选择。但有的时候需要大顶堆或者其他数据类型比较，比如数组，类等，所以，必须对 Comparator 的 compare 方法进行重写 ","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/:1:0","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["Java 基础"],"content":"基本步骤 以下都以 PriorityQueue 优先队列实现作为参考，其他数据结构类似 ","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/:2:0","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["Java 基础"],"content":"基本数据类型 当对基本数据类型重写时，只需要对方法简单重写即可。重写方法有创建 Comparator 的子类、匿名类或者 Lambda 表达式。以下均为改写为升序优先队列，即大顶堆实现方式。 子类 继承 Comparator 子类并重写父类的方法，是最基本的实现方式 class Main{ public static void main(String[] args){ PriorityQueue\u003cInteger\u003e numbers = new PriorityQueue\u003c\u003e(new myComparator()); } } class MyComparator implements Comparator\u003cInteger\u003e { @Override public int compare(Integer number1, Integer number2) { return number2 - number1; } } 匿名类 为了减少创建不必要的类，可以直接使用匿名类完成 class Main{ public static void main(String[] args){ PriorityQueue\u003cInteger\u003e numbers = new PriorityQueue\u003c\u003e(new Comparator(){ @Override public int compare(Integer number1, Integer number2) { return number2 - number1; } }); } } Lambda 表达式 为了减少使用匿名类的代码，可以直接使用 Lambda 表达式 class Main{ public static void main(String[] args){ PriorityQueue\u003cInteger\u003e numbers = new PriorityQueue\u003c\u003e((a, b) -\u003e b - a); } } ","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/:2:1","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["Java 基础"],"content":"数组 数组重写方法基本与基本数据类似，只以匿名类写法作为参考 class Main{ public static void main(String[] args){ PriorityQueue\u003cint[]\u003e numbers = new PriorityQueue\u003c\u003e(new Comparator\u003cint[]\u003e(){ @Override public int compare(int[] o1, int[] o2){ return o1[1] - o2[1]; } }); } } 该优先队列存储数据结构类型为 int 数组，且以下数组的索引 1 为对应数据降序排序 ","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/:2:2","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["Java 基础"],"content":"二维数组 有的时候需要对二维数组的某一维度进行排序，比如需要调用 Arrays.sort() 方法对二维数组排序，但原生排序只支持一维数组，故需要重写，例如对二维数组的第一维度进行升序排序 Arrays.sort(intervals, new Comparator\u003cint[]\u003e() { @Override public int compare(int[] o1 , int[] o2){ return o1[0] - o2[0]; } }); ","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/:2:3","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["Java 基础"],"content":"参考资料 Java PriorityQueue 1606. 找到处理最多请求的服务器 ","date":"2022-03-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/:3:0","tags":["优先队列","数据结构"],"title":"数据结构中自定义排列顺序","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F.html/"},{"categories":["深度学习"],"content":"Pytorch 常用api记录","date":"2022-03-29","objectID":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/","tags":["pytorch","基础"],"title":"Pytorch 常用api","uri":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/"},{"categories":["深度学习"],"content":"前言 Pytorch 是研究生阶段深度学习常用的工具。在学习深度学习的过程中，记录一下使用 Pytorch 经常遇到 api。 ","date":"2022-03-29","objectID":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/:1:0","tags":["pytorch","基础"],"title":"Pytorch 常用api","uri":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/"},{"categories":["深度学习"],"content":"常用 API ","date":"2022-03-29","objectID":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/:2:0","tags":["pytorch","基础"],"title":"Pytorch 常用api","uri":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/"},{"categories":["深度学习"],"content":"Tensor.repeat(*sizes) -\u003e Tensor 沿指定维度重复张量 sizes 次数，可以同时指定多个维度，例如 \u003e\u003e\u003e x = torch.tensor([1, 2, 3]) \u003e\u003e\u003e x.repeat(4, 2) tensor([[ 1, 2, 3, 1, 2, 3], [ 1, 2, 3, 1, 2, 3], [ 1, 2, 3, 1, 2, 3], [ 1, 2, 3, 1, 2, 3]]) \u003e\u003e\u003e x.repeat(4, 2, 1).size() torch.Size([4, 2, 3]) 上述表达式为在第 0 维度重复四次，在第 1 维度重复两次 ","date":"2022-03-29","objectID":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/:2:1","tags":["pytorch","基础"],"title":"Pytorch 常用api","uri":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/"},{"categories":["深度学习"],"content":"torch.permute(input, dims) -\u003e Tensor 按所给顺序交换张量各个维度 \u003e\u003e\u003e x = torch.randn(2, 3, 5) \u003e\u003e\u003e x.size() torch.Size([2, 3, 5]) \u003e\u003e\u003e torch.permute(x, (2, 0, 1)).size() torch.Size([5, 2, 3]) 默认顺序从 0 开始，上述表达式为各个维度向右移动一位。 ","date":"2022-03-29","objectID":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/:2:2","tags":["pytorch","基础"],"title":"Pytorch 常用api","uri":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/"},{"categories":["深度学习"],"content":"torch.empty(size…)→ Tensor 安装所给的维度，初始化一个张量，但张量内数据未初始化（随机） \u003e\u003e\u003e torch.empty((2,3), dtype=torch.int64) tensor([[ 9.4064e+13, 2.8000e+01, 9.3493e+13], [ 7.5751e+18, 7.1428e+18, 7.5955e+18]]) ","date":"2022-03-29","objectID":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/:2:3","tags":["pytorch","基础"],"title":"Pytorch 常用api","uri":"/posts/pytorch-%E5%B8%B8%E7%94%A8api.html/"},{"categories":["深度学习"],"content":"Transformer 代码分析","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"前言 Transformer 是 2017 年 Google 团队提出的新的一种 NLP 模型，采用 Encoder-Decoder （编码器-解码器）架构，使用 self-attention 机制。 其在 seq2seq 上表现出非常鲁棒的性能，并且在 Transformer 基础上，提出了众多变种类型，比较知名的有 Bert 和 GPT 。以上模型，在 github 中都有实现 State-of-the-art Machine Learning for JAX, PyTorch and TensorFlow Transformer 模型框架)\" Transformer 模型框架) ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:1:0","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"基本结构 为了更好的理解和运用 Transformer ，应理解 Transformer 代码实现过程 以下代码来自 动手学深度学习 PyTorch版 ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:2:0","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"导包 因为在如下部分代码中使用了动手学深度学习 PyTorch版 使用了自身提供的库，需要将他们的库导入 import math import pandas as pd import torch from torch import nn from d2l import torch as d2l ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:2:1","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"逐位前馈网络 逐位前馈网络 实质就是一个 MLP 网络，含有两个 全连接层 ，和一个 ReLU 层。 class PositionWiseFFN(nn.Module): \"\"\"基于位置的前馈网络\"\"\" def __init__(self, ffn_num_input, ffn_num_hiddens, ffn_num_outputs, **kwargs): super(PositionWiseFFN, self).__init__(**kwargs) self.dense1 = nn.Linear(ffn_num_input, ffn_num_hiddens) self.relu = nn.ReLU() self.dense2 = nn.Linear(ffn_num_hiddens, ffn_num_outputs) def forward(self, X): return self.dense2(self.relu(self.dense1(X))) ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:2:2","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"残差和层规范化 和 RNN 类似，残差在 Transformer 中，使用的是 batch normlization ，而不是常用的 layer normlization #@save class AddNorm(nn.Module): \"\"\"残差连接后进行层规范化\"\"\" def __init__(self, normalized_shape, dropout, **kwargs): super(AddNorm, self).__init__(**kwargs) self.dropout = nn.Dropout(dropout) self.ln = nn.LayerNorm(normalized_shape) def forward(self, X, Y): return self.ln(self.dropout(Y) + X) ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:2:3","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"编码块 Transformer 中含有 6 层 编码块和 6 层 解码 块。在每个编码块中包含有一个注意力层、两个批量规范层和一个逐位前馈网络层，在每个批量规范层中都使用了残差连接 class EncoderBlock(nn.Module): \"\"\"transformer编码器块\"\"\" def __init__(self, key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, dropout, use_bias=False, **kwargs): super(EncoderBlock, self).__init__(**kwargs) self.attention = d2l.MultiHeadAttention( key_size, query_size, value_size, num_hiddens, num_heads, dropout, use_bias) self.addnorm1 = AddNorm(norm_shape, dropout) self.ffn = PositionWiseFFN( ffn_num_input, ffn_num_hiddens, num_hiddens) self.addnorm2 = AddNorm(norm_shape, dropout) def forward(self, X, valid_lens): Y = self.addnorm1(X, self.attention(X, X, X, valid_lens)) return self.addnorm2(Y, self.ffn(Y)) ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:2:4","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"解码块 与编码块不同的是，在解码块中使用了两个注意力层，第一个注意层用来生成 Query，并将编码器的结果作为 Key 和 Value ，送入第二个注意层学习。在使用多头注意力机制时，将每个头的结果矩阵拼接起来，最后在传入全连接层计算。 class DecoderBlock(nn.Module): \"\"\"解码器中第 i 个块\"\"\" def __init__(self, key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, dropout, i, **kwargs): super(DecoderBlock, self).__init__(**kwargs) self.i = i self.attention1 = d2l.MultiHeadAttention( key_size, query_size, value_size, num_hiddens, num_heads, dropout) self.addnorm1 = AddNorm(norm_shape, dropout) self.attention2 = d2l.MultiHeadAttention( key_size, query_size, value_size, num_hiddens, num_heads, dropout) self.addnorm2 = AddNorm(norm_shape, dropout) self.ffn = PositionWiseFFN(ffn_num_input, ffn_num_hiddens, num_hiddens) self.addnorm3 = AddNorm(norm_shape, dropout) def forward(self, X, state): enc_outputs, enc_valid_lens = state[0], state[1] # 训练阶段，输出序列的所有词元都在同一时间处理， # 因此 `state[2][self.i]` 初始化为 `None`。 # 预测阶段，输出序列是通过词元一个接着一个解码的， # 因此 `state[2][self.i]` 包含着直到当前时间步第 `i` 个块解码的输出表示 if state[2][self.i] is None: key_values = X else: key_values = torch.cat((state[2][self.i], X), axis=1) state[2][self.i] = key_values if self.training: batch_size, num_steps, _ = X.shape # `dec_valid_lens` 的开头: (`batch_size`, `num_steps`), # 其中每一行是 [1, 2, ..., `num_steps`] dec_valid_lens = torch.arange( 1, num_steps + 1, device=X.device).repeat(batch_size, 1) else: dec_valid_lens = None # 自注意力 X2 = self.attention1(X, key_values, key_values, dec_valid_lens) Y = self.addnorm1(X, X2) # 编码器－解码器注意力。 # `enc_outputs` 的开头: (`batch_size`, `num_steps`, `num_hiddens`) Y2 = self.attention2(Y, enc_outputs, enc_outputs, enc_valid_lens) Z = self.addnorm2(Y, Y2) return self.addnorm3(Z, self.ffn(Z)), state ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:2:5","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"实现代码 Transformer 模型分为两大部分，编码器和解码器，根据上述基本结构，就可以实现这两大部分 ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:3:0","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"编码器 在 Transformer 的编码器包含了多个编码块。可以使用 nn.Sequential() 生成多个编码块，构成编码器 class TransformerEncoder(d2l.Encoder): \"\"\"transformer编码器\"\"\" def __init__(self, vocab_size, key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, num_layers, dropout, use_bias=False, **kwargs): super(TransformerEncoder, self).__init__(**kwargs) self.num_hiddens = num_hiddens self.embedding = nn.Embedding(vocab_size, num_hiddens) self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout) self.blks = nn.Sequential() for i in range(num_layers): self.blks.add_module(\"block\"+str(i), EncoderBlock(key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, dropout, use_bias)) def forward(self, X, valid_lens, *args): # 因为位置编码值在 -1 和 1 之间， # 因此嵌入值乘以嵌入维度的平方根进行缩放， # 然后再与位置编码相加。 X = self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens)) self.attention_weights = [None] * len(self.blks) for i, blk in enumerate(self.blks): X = blk(X, valid_lens) self.attention_weights[ i] = blk.attention.attention.attention_weights return X ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:3:1","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"解码器 同编码器一样，使用使用 nn.Sequential() 生成多个解码块，构成解码器 class TransformerDecoder(d2l.AttentionDecoder): def __init__(self, vocab_size, key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, num_layers, dropout, **kwargs): super(TransformerDecoder, self).__init__(**kwargs) self.num_hiddens = num_hiddens self.num_layers = num_layers self.embedding = nn.Embedding(vocab_size, num_hiddens) self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout) self.blks = nn.Sequential() for i in range(num_layers): self.blks.add_module(\"block\"+str(i), DecoderBlock(key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, dropout, i)) self.dense = nn.Linear(num_hiddens, vocab_size) def init_state(self, enc_outputs, enc_valid_lens, *args): return [enc_outputs, enc_valid_lens, [None] * self.num_layers] def forward(self, X, state): X = self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens)) self._attention_weights = [[None] * len(self.blks) for _ in range (2)] for i, blk in enumerate(self.blks): X, state = blk(X, state) # 解码器自注意力权重 self._attention_weights[0][ i] = blk.attention1.attention.attention_weights # “编码器－解码器”自注意力权重 self._attention_weights[1][ i] = blk.attention2.attention.attention_weights return self.dense(X), state @property def attention_weights(self): return self._attention_weights ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:3:2","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["深度学习"],"content":"训练与预测 # 训练 num_hiddens, num_layers, dropout, batch_size, num_steps = 32, 2, 0.1, 64, 10 lr, num_epochs, device = 0.005, 200, d2l.try_gpu() ffn_num_input, ffn_num_hiddens, num_heads = 32, 64, 4 key_size, query_size, value_size = 32, 32, 32 norm_shape = [32] train_iter, src_vocab, tgt_vocab = d2l.load_data_nmt(batch_size, num_steps) encoder = TransformerEncoder( len(src_vocab), key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, num_layers, dropout) decoder = TransformerDecoder( len(tgt_vocab), key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, num_layers, dropout) net = d2l.EncoderDecoder(encoder, decoder) d2l.train_seq2seq(net, train_iter, lr, num_epochs, tgt_vocab, device) # 预测 engs = ['go .', \"i lost .\", 'he\\'s calm .', 'i\\'m home .'] fras = ['va !', 'j\\'ai perdu .', 'il est calme .', 'je suis chez moi .'] for eng, fra in zip(engs, fras): translation, dec_attention_weight_seq = d2l.predict_seq2seq( net, eng, src_vocab, tgt_vocab, num_steps, device, True) print(f'{eng}=\u003e {translation}, ', f'bleu {d2l.bleu(translation, fra, k=2):.3f}') ","date":"2022-03-26","objectID":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/:3:3","tags":["深度学习","Transformer"],"title":"Transformer 代码解析","uri":"/posts/transformer-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html/"},{"categories":["算法"],"content":"计算质因子个数","date":"2022-03-25","objectID":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/","tags":["算法","质因子"],"title":"质因子个数计算","uri":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/"},{"categories":["算法"],"content":"前言 172. 阶乘后的零 该题中计算阶乘结果 0 的个数，可转换为计算 n 中含有 5 质因子的个数问题 ","date":"2022-03-25","objectID":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/:1:0","tags":["算法","质因子"],"title":"质因子个数计算","uri":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/"},{"categories":["算法"],"content":"算法思想 [1,n] 中 p 的倍数有 $n_1 = \\lfloor \\frac{n}{p} \\rfloor$ ，以此类推可以得到 $n_i = \\lfloor \\frac{n}{p^i} \\rfloor$ 可以得到 $p^i$ 质因子的个数。又因为若 n 是 $p^i$ 的倍数，则 n 必定也是 $n^{i-1}$ 的倍数，故 [1, n]的中的 p 的质因子个数为 $\\sum \\lfloor \\frac{n}{p^i} \\rfloor$ 计算结果的 0 的个数即统计 10 因子的个数，质因素分解为 2 和 5 ，根据上述公式，可以知道 2 的 个数多余 5 的个数，故只要计算 5 的质因子个数。 ","date":"2022-03-25","objectID":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/:2:0","tags":["算法","质因子"],"title":"质因子个数计算","uri":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/"},{"categories":["算法"],"content":"代码 class Solution { public int trailingZeroes(int n) { int res = 0; while(n \u003e= 5){ res += n / 5; n /= 5; } return res; } } ","date":"2022-03-25","objectID":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/:3:0","tags":["算法","质因子"],"title":"质因子个数计算","uri":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/"},{"categories":["算法"],"content":"参考资料 阶乘后的零 ","date":"2022-03-25","objectID":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/:4:0","tags":["算法","质因子"],"title":"质因子个数计算","uri":"/posts/%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97.html/"},{"categories":["Java 基础"],"content":"Java 的常用数据结构","date":"2022-03-24","objectID":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/","tags":["数据结构"],"title":"Java 常用数据结构","uri":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Java 基础"],"content":"LinkedList LinkedList 链表，除了 队列 接口，还实现了 双端队列 void add(int index, E element) : 在特定位置位置插入元素 boolean add(E e) ： 在链表尾部加入元素 E remove(int index) ： 删除链表给定序号的元素 E removeLast() : 删除链表尾部元素 ","date":"2022-03-24","objectID":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:1:0","tags":["数据结构"],"title":"Java 常用数据结构","uri":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Java 基础"],"content":"HashMap HashMap 哈希表，可以存 空值 ，不保证映射后的遍历顺序，也不保证该顺序会随着时间变化而保持，迭代方式 键值迭代 import java.util.HashMap; import java.util.Map; public class Test { public static void main(String[] args) throws IOException { Map\u003cInteger, Integer\u003e map = new HashMap\u003cInteger, Integer\u003e(); map.put(1, 10); map.put(2, 20); // Iterating entries using a For Each loop for (Map.Entry\u003cInteger, Integer\u003e entry : map.entrySet()) { System.out.println(\"Key = \" + entry.getKey() + \", Value = \" + entry.getValue()); } } } 键迭代 import java.util.HashMap; import java.util.Map; public class Test { public static void main(String[] args) throws IOException { Map\u003cInteger, Integer\u003e map = new HashMap\u003cInteger, Integer\u003e(); map.put(1, 10); map.put(2, 20); // 迭代键 for (Integer key : map.keySet()) { System.out.println(\"Key = \" + key); } // 迭代值 for (Integer value : map.values()) { System.out.println(\"Value = \" + value); } } } boolean isEmpty() : 判断哈希表是否为空 boolean containsKet(Object Key) : 查询哈希表是否存在 Key ，存在返回 true Set\u003cMap.Entry \u003cK, V\u003e\u003e entrySet() ： 获取 HashMap 的迭代器，可以同时获得 Key 和 Value Set\u003cK\u003e keySet ：获取哈希表的 Key 的迭代器 V remove(Object Key) : 溢出哈希表的 Key和对于的 Value int size() : 获取哈希标的实际大小 ","date":"2022-03-24","objectID":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:2:0","tags":["数据结构"],"title":"Java 常用数据结构","uri":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Java 基础"],"content":"LinkedHashMap LinkedHashMap 与 HashMap 不同的是，该哈希表可以预测迭代顺序，因为实现了双向链表，该链表定义了迭代顺序，api 同上 ","date":"2022-03-24","objectID":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:3:0","tags":["数据结构"],"title":"Java 常用数据结构","uri":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Java 基础"],"content":"TreeSet TreeSet 为有序集合，实现了 NavigableSet 接口，默认排序顺序为升序排序，内部结构为平衡二叉树(红黑树)。可以在 O(h) 的时间复杂度完成查找、增加、删除操作。由于实现了 NavigableSet 接口，可以实现查找小于、大于某元素的结果，如没有找到则返回 null 。所以，需要使用包装类接受返回值，而不能使用基本类型接受返回数据。 E ceiling(E e) : 返回此集合中大于或等于给定元素的最小元素，如果没有这样的元素，则返回 null E floor(E e) : 返回此集合中小于或等于给定元素的最大元素，如果没有这样的元素，则返回 null E greater(E e) : 返回此集合中严格大于给定元素的最小元素，如果没有这样的元素，则返回 null E lower(E e) : 返回此集合中严格小于给定元素的最小元素，如果没有这样的元素，则返回 null boolean contains(Object o) : 查询元素是否存在有序集合当中 ","date":"2022-03-24","objectID":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:4:0","tags":["数据结构"],"title":"Java 常用数据结构","uri":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["Java 基础"],"content":"PriorityQueue PriorityQueue 默认实现为小顶堆，与C++ 的优先队列默认为大顶堆不一样。 E peek() : 查看堆顶元素 E poll() : 删除顶堆元素 ","date":"2022-03-24","objectID":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/:4:1","tags":["数据结构"],"title":"Java 常用数据结构","uri":"/posts/java-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html/"},{"categories":["算法"],"content":"变位词匹配 算法","date":"2022-03-24","objectID":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/","tags":["算法","变位词"],"title":"变位词","uri":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/"},{"categories":["算法"],"content":"前言 变位词 是指字符串更改字符顺序后相等的字符串（即字符串内各个字符出现的次数相等）。变位词 匹配就是将字符串数组中所有相同的变位词找出。 剑指 Offer II 033. 变位词组 ","date":"2022-03-24","objectID":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/:1:0","tags":["算法","变位词"],"title":"变位词","uri":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/"},{"categories":["算法"],"content":"算法思想 暴力求解 ：将两个字符串的各个字符查询统计并比较，这种算法的时间复杂度为 O(m*n) ，且难适用于多个字符串同时进行匹配分组 计数拼接 ： 将各个字符统计并计数，最后将各个字符与对应的次数进行拼接起来，比如 leetcode，计算得到的字符为 c1d1e3l1o1t1，接着将结果作为哈希 Key ， 该字符的索引作为 Value ，使用哈希匹配分组 素数求积 ： 将各个字符映射为一个素数，同时求得字符串的累积，并将结果作为哈希的 Key ，字符串的索引作为 Value ，使用哈希匹配分组。该思路需要考虑 大数 问题，若基本数据会溢出的话，可以使用 mod 求余，但这也需要考虑哈希冲突 ","date":"2022-03-24","objectID":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/:2:0","tags":["算法","变位词"],"title":"变位词","uri":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/"},{"categories":["算法"],"content":"代码 计数拼接代码，参考自 字母异位词分组 class Solution { public List\u003cList\u003cString\u003e\u003e groupAnagrams(String[] strs) { Map\u003cString, List\u003cString\u003e\u003e map = new HashMap\u003cString, List\u003cString\u003e\u003e(); for (String str : strs) { int[] counts = new int[26]; int length = str.length(); for (int i = 0; i \u003c length; i++) { counts[str.charAt(i) - 'a']++; } // 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键 StringBuffer sb = new StringBuffer(); for (int i = 0; i \u003c 26; i++) { if (counts[i] != 0) { sb.append((char) ('a' + i)); sb.append(counts[i]); } } String key = sb.toString(); List\u003cString\u003e list = map.getOrDefault(key, new ArrayList\u003cString\u003e()); list.add(str); map.put(key, list); } return new ArrayList\u003cList\u003cString\u003e\u003e(map.values()); } } 素数求积。根据题目所给要求，判断不会溢出，故没有取余 class Solution { public List\u003cList\u003cString\u003e\u003e groupAnagrams(String[] strs) { List\u003cList\u003cString\u003e\u003e res = new ArrayList\u003c\u003e(); Map\u003cLong, Integer\u003e map = new HashMap\u003c\u003e(); int[] primeNum = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47, 53,59,61,67,71,73,79,83,89,97,101}; long product = 1; String temp; int index; for(int i = 0; i \u003c strs.length; i++){ temp = strs[i]; product = 1; for(int j = 0; j \u003c temp.length(); j++){ product *= primeNum[temp.charAt(j) - 'a']; } if(map.containsKey(product)){ index = map.get(product); res.get(index).add(temp); }else{ List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(temp); res.add(list); map.put(product, res.size()-1); } } return res; } } ","date":"2022-03-24","objectID":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/:3:0","tags":["算法","变位词"],"title":"变位词","uri":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/"},{"categories":["算法"],"content":"参考资料 变位词问题 ","date":"2022-03-24","objectID":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/:4:0","tags":["算法","变位词"],"title":"变位词","uri":"/posts/%E5%8F%98%E4%BD%8D%E8%AF%8D.html/"},{"categories":["深度学习"],"content":"机器学习的常用缩写","date":"2022-03-23","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/","tags":["机器学习"],"title":"机器学习中常用缩写汇总","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/"},{"categories":["深度学习"],"content":"前言 阅读论文经常遇到各种缩写形式，为了方便论文阅读，故将论文常用的缩写记录下来 ","date":"2022-03-23","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/:1:0","tags":["机器学习"],"title":"机器学习中常用缩写汇总","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/"},{"categories":["深度学习"],"content":"机器学习 ","date":"2022-03-23","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/:2:0","tags":["机器学习"],"title":"机器学习中常用缩写汇总","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/"},{"categories":["深度学习"],"content":"深度学习 DNN ：Deep Neural Networks，深度神经网络，深度学习的基础 ReLU ：Rectified Linear Unit ，常用的激活函数 GMM ：Gaussian Mixture Model ，高斯混合模型，单一高斯概率密度函数的延伸，就是用多个高斯概率密度函数（正态分布曲线）精确地量化变量分布，是将变量分布分解为若干基于高斯概率密度函数（正态分布曲线）分布的统计模型。 HMM : Hidden Markov Model ，隐马尔可夫模型，用来描述一个含有隐含未知参数的马尔可夫过程 MAP ： Maximum APosteriori ，最大后验概率 MLLR ： Maximum Likelihood Linear Regression ，最大似然回归 DBN ： Deep Belief Networks ，深度置信网络 CD ： Context Dependent ，上下文相关 MFCC : Mel Frequency Cepstral Coeffcients ，梅尔倒谱系数，对语音进行编码 FBK ：Filter Bank Feature ，滤波器组特征，用于语音编码 PLP ： Perceptual Linear Prediction ，感知线性预测系数，用于语音编码 ","date":"2022-03-23","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/:3:0","tags":["机器学习"],"title":"机器学习中常用缩写汇总","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB.html/"},{"categories":["算法"],"content":"字典树的基本原理","date":"2022-03-23","objectID":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/","tags":["算法","字典树"],"title":"字典树","uri":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/"},{"categories":["算法"],"content":"前言 字典树 ，是一种空间换时间的数据结构，又称 Trie 树、前缀树 ，是一种树形结构(字典树是一种数据结构)，用于统计、排序、和保存大量字符串 ","date":"2022-03-23","objectID":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/:1:0","tags":["算法","字典树"],"title":"字典树","uri":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/"},{"categories":["算法"],"content":"算法思想 按照题目所给的 字典序 要求，生成相应的 字典树 结构。后续查找通过公共前缀来减少查找时间，降低查找时间复杂度 字典树 的三个重要性质： 根节点不包含字符，除了根节点每个节点都只包含一个字符。root节点不含字符这样做的目的是为了能够包括所有字符串。 从根节点到某一个节点，路过字符串起来就是该节点对应的字符串。（也可以直接在该节点保存字符连接后的结果） 每个节点的子节点字符不同，也就是找到对应单词、字符是唯一的。 ","date":"2022-03-23","objectID":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/:2:0","tags":["算法","字典树"],"title":"字典树","uri":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/"},{"categories":["算法"],"content":"在优化 字典树 的空间复杂度为 O(N) ，可以根据 前序 结果推导出 后序 结果，可以不创建 字典树 ，直接使用 前序 进行迭代，相应的空间复杂度可降低至 O(1) 。例如 440. 字典序的第K小数字 ","date":"2022-03-23","objectID":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/:3:0","tags":["算法","字典树"],"title":"字典树","uri":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/"},{"categories":["算法"],"content":"代码 字典树 的实现 public class TrieNode { int count; int prefix; TrieNode[] nextNode=new TrieNode[26]; public TrieNode(){ count=0; prefix=0; } } //插入一个新单词 public static void insert(TrieNode root,String str){ if(root==null||str.length()==0){ return; } char[] c=str.toCharArray(); for(int i=0;i\u003cstr.length();i++){ //如果该分支不存在，创建一个新节点 if(root.nextNode[c[i]-'a']==null){ root.nextNode[c[i]-'a']=new TrieNode(); } root=root.nextNode[c[i]-'a']; root.prefix++;//注意，应该加在后面 } //以该节点结尾的单词数+1 root.count++; } //查找该单词是否存在，如果存在返回数量，不存在返回-1 public static int search(TrieNode root,String str){ if(root==null||str.length()==0){ return -1; } char[] c=str.toCharArray(); for(int i=0;i\u003cstr.length();i++){ //如果该分支不存在，表名该单词不存在 if(root.nextNode[c[i]-'a']==null){ return -1; } //如果存在，则继续向下遍历 root=root.nextNode[c[i]-'a']; } //如果count==0,也说明该单词不存在 if(root.count==0){ return -1; } return root.count; } //查询以str为前缀的单词数量 public static int searchPrefix(TrieNode root,String str){ if(root==null||str.length()==0){ return -1; } char[] c=str.toCharArray(); for(int i=0;i\u003cstr.length();i++){ //如果该分支不存在，表名该单词不存在 if(root.nextNode[c[i]-'a']==null){ return -1; } //如果存在，则继续向下遍历 root=root.nextNode[c[i]-'a']; } return root.prefix; } 440. 字典序的第K小数字 代码实现 class Solution { public int findKthNumber(int n, int k) { int pos = 1; k--; int step; while(k \u003e 0){ step = getStep(pos, n); if(step \u003e k){ pos *= 10; k--; }else{ k -= step; pos++; } } return pos; } public int getStep(int pos, int n){ long first = pos; long last = pos; int step = 0; while(first \u003c= n){ step += Math.min(last, n) - first + 1; first = first * 10; last = last * 10 + 9; } return step; } } ","date":"2022-03-23","objectID":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/:4:0","tags":["算法","字典树"],"title":"字典树","uri":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/"},{"categories":["算法"],"content":"参考资料 字典树 (Trie) 数据结构与算法：字典树（前缀树） 一文搞懂字典树 ","date":"2022-03-23","objectID":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/:5:0","tags":["算法","字典树"],"title":"字典树","uri":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91.html/"},{"categories":["算法"],"content":"双指针 算法","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"前言 双指针主要用来在序列中进行遍历，其中常用方式有 快慢指针 、 对撞指针 和 滑动窗口 。可以从将暴力求解的时间复杂度 O(n^2) 降低至 O(n) ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:1:0","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"算法思想 ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:2:0","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"快慢指针 快慢指针 是指两个指针的速度移动不一致。比如一个循环内一个指针移动一位，另一个移动两位，这样在循环结束时，两个指针的移动的距离之比则是固定倍数。 快慢指针 一般用来求序列的中间位置、序列是否成环（进一步也可也求成环的初始位置），例题参考如下 剑指 Offer II 022. 链表中环的入口节点 剑指 Offer II 027. 回文链表 ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:2:1","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"对撞指针 对撞指针 是指两个指针初始在序列的不同端，并且不断的向中心进行寻找 对撞指针 一般用来求解序列两数之 ”和“（广义上指两元素之间关系） 是否满足某一条件，通常该序列一般经过特殊处理过，比如升序排列，也可以对字符串进行翻转。例题参考如下 344. 反转字符串 ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:2:2","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"滑动窗口 滑动窗口 两个指针分别为窗口的左端和右端，并按一定的条件进行有移动。 滑动窗口 按照题目的要求，可以使用固定宽度和动态宽度。该方法一般用来求解连续序列问题 ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:2:3","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"代码 快慢指针 代码参考如下 public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head; ListNode fast = head; ListNode p = head; while(fast != null){ fast = fast.next; if(fast == null){ return null; } // System.out.println(fast.val); fast = fast.next; if(fast == null){ return null; } slow = slow.next; if(fast == slow){ break; } } while(p != slow){ p = p.next; slow = slow.next; } return p; } } 对撞指针代码参考如下： class Solution { public void reverseString(char[] s) { int i=0; int j=s.length-1; while(i\u003cj){ char tmp = s[i]; s[i] = s[j]; s[j] = tmp; i++; j--; } } } 滑动窗口参考代码如下： class Solution { public int minSubArrayLen(int s, int[] nums) { int n = nums.length; if (n == 0) { return 0; } int ans = Integer.MAX_VALUE; int start = 0, end = 0; int sum = 0; while (end \u003c n) { sum += nums[end]; while (sum \u003e= s) { ans = Math.min(ans, end - start + 1); sum -= nums[start]; start++; } end++; } return ans == Integer.MAX_VALUE ? 0 : ans; } } ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:3:0","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["算法"],"content":"参考资料 和大于等于 target 的最短子数组 算法一招鲜——双指针问题 ","date":"2022-03-22","objectID":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/:4:0","tags":["算法","双指针"],"title":"双指针","uri":"/posts/%E5%8F%8C%E6%8C%87%E9%92%88.html/"},{"categories":["Java 基础"],"content":"Java 一些基本优化","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java 基础"],"content":"前言 主要总结一些 java 的基本使用 持续总结中 ing ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:1:0","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java 基础"],"content":"内容 ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:0","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java 基础"],"content":"字符串拼接 字符串的拼接优先使用StringBuilder和StringBuffer类，同时在使用拼接的过程中，尽量使用一个一个的字符串进行 append ，而不是将某些字符串拼接后再 append ，例如 int n = 100; StringBuilder sb = new StringBuilder(); for(int i = 0; i \u003c n; i++){ # sb.append(i + \"#\"); sb.append(i); sb.append(\"#\"); } 不要将 i + \"#\" 拼接好后在 append ，字符串拼接后会产生的新的字符串从而产生更多的开销 ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:1","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java 基础"],"content":"Comparator类的compare方法重写 当需要在某数组某区间进行排序并且需要逆序是，则可以重写 static \u003cT\u003e void sort(T[] a, int fromIndex, int toIndex, Comparator\u003c? super T\u003e c) 方法，该方法返回类型为泛型，所以不能使用基本类型数组进行接受（数组泛型不会自动解包操作），需要使用包装类完成类型接受。 public static void mySort(Integer[] nums, int idx) { Arrays.sort(nums, 0, idx, (a, b) -\u003e Integer.compare(b, a)); } ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:2","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["Java 基础"],"content":"数组填充 int double long 数组的默认初始化是 0， boolean 数组默认初始化为 false ，类的数组初始化为 null。 若需要对数组全部进行填充时，可以使用Arrays api完成，比如将 int 数组 arr 初始化为 -1。 Arrays.fill(arr, -1) ","date":"2022-03-21","objectID":"/posts/java-%E5%9F%BA%E7%A1%80.html/:2:3","tags":["java"],"title":"Java 基础","uri":"/posts/java-%E5%9F%BA%E7%A1%80.html/"},{"categories":["算法"],"content":"Manacher 算法","date":"2022-03-21","objectID":"/posts/manacher-%E7%AE%97%E6%B3%95.html/","tags":["算法","Manacher"],"title":"Manacher 算法","uri":"/posts/manacher-%E7%AE%97%E6%B3%95.html/"},{"categories":["算法"],"content":"前言 检查字符串是否为回文序列，常用方法有 中心扩展 和 Manacher 。前者的时间复杂度为 O(n^2) ，后者算法的时间复杂度为 O(n) ，可以在线性时间的完成回文序列的判断 参考例题 剑指 Offer II 020. 回文子字符串的个数 ","date":"2022-03-21","objectID":"/posts/manacher-%E7%AE%97%E6%B3%95.html/:1:0","tags":["算法","Manacher"],"title":"Manacher 算法","uri":"/posts/manacher-%E7%AE%97%E6%B3%95.html/"},{"categories":["算法"],"content":"算法思想 Manacher 算法的主题思路是利用保存前字符串序列的最大回文半径来减少后续字符串回文与否的判定。 算法过程如下： 先将初始字符串在每个字符间增加一个间隔符号，比如 # （也包括在字符串的开头和字符串的结尾），该步骤主要是为了将偶数回文序列和奇数回文序列合并在一起进行判断。同时在字符串的开头分别加上两个不同的特殊符号，比如开头增加 $ ，结尾增加 ^ ，这两个字符充当哨兵作用 \"abab\" ---\u003e \"$#a#b#a#b$^\" 创建上述字符串的半径数组，从左往右依次计算各序号的半径，同时记录当前的字符串回文的最大右边界 rmax 和对于的序号 maxi，计算过程如下： 当该序号 i 小于等于保存的最大的右边界 rmax 时，则将当前序号的半径初始化为 r = max(rmax - i + 1, 2 * maxi - i) 反之，则直接初始化为 1 再使用 中心扩展法 判断当前半径是否为最大回文序列半径，若不是，则递增继续判断（在上一步骤中，若得到的r + i 小于最大右边界时，则 r即为当前序号的最大半径；若等于最大右边界时，则需要该步骤进行判断） 从上述步骤看，该算法是通过记录当前序号的最大半径 r 和最大右边界 rmax，减少后续序号最大半径的搜索范围，从而将时间复杂度从 O(n^2) 降低至 O(n) 。（中心扩展法 默认都是从半径为 1 依次进行判断），该算法思想与字符串KMP算法思想类似 ","date":"2022-03-21","objectID":"/posts/manacher-%E7%AE%97%E6%B3%95.html/:2:0","tags":["算法","Manacher"],"title":"Manacher 算法","uri":"/posts/manacher-%E7%AE%97%E6%B3%95.html/"},{"categories":["算法"],"content":"代码 class Solution { public int countSubstrings(String s) { int res = 0; StringBuilder sb = new StringBuilder(); sb.append(\"$#\"); for(int i = 0; i \u003c s.length(); i++){ sb.append(s.charAt(i)); sb.append(\"#\"); } sb.append('^'); int[] r = new int[sb.length()]; r[0] = 1; int max = r[0]; int maxi = 0; for(int i = 1; i \u003c r.length - 1; i++){ r[i] = i \u003c max ? Math.min(max - i + 1, r[2 * maxi - i]) : 1; while(sb.charAt(i - r[i]) == sb.charAt(i + r[i])){ r[i]++; } if(i + r[i] - 1 \u003e= max){ max = i + r[i] - 1; maxi = i; } res += r[i] / 2; } return res; } } ","date":"2022-03-21","objectID":"/posts/manacher-%E7%AE%97%E6%B3%95.html/:3:0","tags":["算法","Manacher"],"title":"Manacher 算法","uri":"/posts/manacher-%E7%AE%97%E6%B3%95.html/"},{"categories":["算法"],"content":"参考链接 Manacher 算法 回文子字符串的个数 ","date":"2022-03-21","objectID":"/posts/manacher-%E7%AE%97%E6%B3%95.html/:4:0","tags":["算法","Manacher"],"title":"Manacher 算法","uri":"/posts/manacher-%E7%AE%97%E6%B3%95.html/"},{"categories":["算法"],"content":"前缀和的原理和基本应用场景","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"前言 382. 链表随机节点 给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 被选中的概率一样 。 实现 Solution 类： Solution(ListNode head) 使用整数数组初始化对象。 int getRandom() 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。 ","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/:1:0","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"算法思想 以下内容摘自蓄水池抽样算法（Reservoir Sampling） 给定一个数据流，数据流长度N很大，且N直到处理完所有数据之前都不可知，请问如何在只遍历一遍数据（O(N)）的情况下，能够随机选取出m个不重复的数据。 ","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/:2:0","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"原理 第i个接收到的数据最后能够留在蓄水池中的概率=*第i个数据进入过蓄水池的概率***之后第i个数据不被替换的概率（第i+1到第N次处理数据都不会被替换）。 当i\u003c=m时，数据直接放进蓄水池，所以第i个数据进入过蓄水池的概率=1。 当i\u003em时，在[1,i]内选取随机数d，如果d\u003c=m，则使用第i个数据替换蓄水池中第d个数据，因此第i个数据进入过蓄水池的概率=m/i。 当i\u003c=m时，程序从接收到第m+1个数据时开始执行替换操作，第m+1次处理会替换池中数据的为m/(m+1)，会替换掉第i个数据的概率为1/m，则第m+1次处理替换掉第i个数据的概率为(m/(m+1))(1/m)=1/(m+1)，不被替换的概率为1-1/(m+1)=m/(m+1)。依次，第m+2次处理不替换掉第i个数据概率为(m+1)/(m+2)…第N次处理不替换掉第i个数据的概率为(N-1)/N。所以，之后**第i个数据不被替换的概率=m/(m+1)(m+1)/(m+2)…(N-1)/N=m/N**。 当i\u003em时，程序从接收到第i+1个数据时开始有可能替换第i个数据。则参考上述第3点，之后第i个数据不被替换的概率=i/N。 结合第1点和第3点可知，当i\u003c=m时，第i个接收到的数据最后留在蓄水池中的概率=1m/N=m/N。结合第2点和第4点可知，当i\u003em时，第i个接收到的数据留在蓄水池中的概率=m/ii/N=m/N。综上可知，每个数据最后被选中留在蓄水池中的概率为m/N。 ","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/:2:1","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"拓展 假设有K台机器，将大数据集分成K个数据流，每台机器使用单机版蓄水池抽样处理一个数据流，抽样m个数据，并最后记录处理的数据量为N1, N2, …, Nk, …, NK(假设m\u003cNk)。N1+N2+…+NK=N。 取[1, N]一个随机数d，若d\u003cN1，则在第一台机器的蓄水池中等概率不放回地（1/m）选取一个数据；若N1\u003c=d\u003c(N1+N2)，则在第二台机器的蓄水池中等概率不放回地选取一个数据；一次类推，重复m次，则最终从N大数据集中选出m个数据。 验证如下： 第k台机器中的蓄水池数据被选取的概率为m/Nk。 从第k台机器的蓄水池中选取一个数据放进最终蓄水池的概率为Nk/N。 第k台机器蓄水池的一个数据被选中的概率为1/m。（不放回选取时等概率的） 重复m次选取，则每个数据被选中的概率为m*(m/Nk*Nk/N*1/m)=m/N ","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/:3:0","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"代码 class Solution { ListNode head; Random random; public Solution(ListNode head) { this.head = head; random = new Random(); } public int getRandom() { int i = 1, ans = 0; for (ListNode node = head; node != null; node = node.next) { if (random.nextInt(i) == 0) { // 1/i 的概率选中（替换为答案） ans = node.val; } ++i; } return ans; } } ","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/:4:0","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"参考链接 蓄水池抽样算法（Reservoir Sampling） 382. 链表随机节点 ","date":"2022-03-18","objectID":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/:5:0","tags":["算法","蓄水池抽样"],"title":"蓄水池抽样法","uri":"/posts/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E6%B3%95.html/"},{"categories":["算法"],"content":"前缀和的原理和基本应用场景","date":"2022-03-18","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/","tags":["算法","前缀和"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/"},{"categories":["算法"],"content":"前言 在算法中，如果需要求一些连续数组成的集合，可以使用前缀和对结果进行存储，从而避免暴力搜索，利用空间复杂度换取时间复杂度 例如leetcode中的 剑指 Offer II 008. 和大于等于 target 的最短子数组 ","date":"2022-03-18","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/:1:0","tags":["算法","前缀和"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/"},{"categories":["算法"],"content":"算法思想 创建一个前缀数组 pre[n] ，其中 pre[i] 表示前 i 个数组所构成的数据结果，例如对于 剑指 Offer II 008. 和大于等于 target 的最短子数组 题目，则可以表示为前 i 个元素和。因为是求连续数组，则可以通过 pre[j] - pre[i] 表示任意第 i 个元素到第 j 个元素的的连续数组，即使用前缀和来减少暴力搜索的时间复杂度，这样算法的时间复杂度为O(N^2)，空间复杂度为 O(N) ","date":"2022-03-18","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/:2:0","tags":["算法","前缀和"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/"},{"categories":["算法"],"content":"再优化 尽管使用了前缀和思想，可以将时间复杂度降至O(N^2)，但在 n足够大时，仍然会出现超时情况。为此，可以根据题目的不同要求，在求前缀和的过程中，使用其他数据结构将所需要的数据进行保存，比如使用 HashMap 。这在后续求解时，可以使用 O(1) 的时间复杂度进行求解，例如在 剑指 Offer II 011. 0 和 1 个数相同的子数组 题目当中，使用 Key 将结果作为索引 ，位置信息作为 Value 进行保存 ","date":"2022-03-18","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/:3:0","tags":["算法","前缀和"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/"},{"categories":["算法"],"content":"代码 剑指 Offer II 008. 和大于等于 target 的最短子数组 示例参考代码如下 class Solution { public int minSubArrayLen(int s, int[] nums) { int n = nums.length; if (n == 0) { return 0; } int ans = Integer.MAX_VALUE; int[] sums = new int[n + 1]; // 为了方便计算，令 size = n + 1 // sums[0] = 0 意味着前 0 个元素的前缀和为 0 // sums[1] = A[0] 前 1 个元素的前缀和为 A[0] // 以此类推 for (int i = 1; i \u003c= n; i++) { sums[i] = sums[i - 1] + nums[i - 1]; } for (int i = 1; i \u003c= n; i++) { int target = s + sums[i - 1]; int bound = Arrays.binarySearch(sums, target); if (bound \u003c 0) { bound = -bound - 1; } if (bound \u003c= n) { ans = Math.min(ans, bound - (i - 1)); } } return ans == Integer.MAX_VALUE ? 0 : ans; } } ","date":"2022-03-18","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/:4:0","tags":["算法","前缀和"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/"},{"categories":["算法"],"content":"参考链接 剑指 Offer II 008. 和大于等于 target 的最短子数组 ","date":"2022-03-18","objectID":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/:5:0","tags":["算法","前缀和"],"title":"前缀和","uri":"/posts/%E5%89%8D%E7%BC%80%E5%92%8C.html/"},{"categories":["常用软件"],"content":"aria2 的基本安装和使用","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["常用软件"],"content":"前言 最近节点也不知道怎么了，从谷歌云盘下载东西时，经常因为断流而导致下载中断，导致我的大文件几乎就下不下来，网上找了下解决方法，最后选择aria2，一个支持断点续传的软件 aria2 是一个轻量级的多协议和多源命令行下载实用程序。它支持 HTTP/HTTPS、FTP、BitTorrent 和 Metalink。 aria2 可以通过内置的 JSON-RPC 和 XML-RPC 接口进行操作。 ","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/:1:0","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["常用软件"],"content":"安装 aria2 可以在Arch的官方仓库找到 sudo pacman -S aria2 同时 archlinuxcn 源和 AUR 仓库都存在对原版 aria2 补丁的 aria2-fast，原版设置了16线程的上线，该补丁版本最多可以设置为128线程 yay -S aria2-fast ","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/:2:0","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["常用软件"],"content":"配置 aria2 默认配置文件位于 $HOME/.aria2/aria2.conf ，具体配置内容可以参考arch wiki 或者 P3TERX 大佬的 注意：若开启了 session,需要手动创建对应的 aria2.session 文件，否则 daemon 启动不了 ","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/:3:0","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["常用软件"],"content":"设置daemon 一般情况下，aria2 下载完成后便会退出，因此我们可以使用守护单元，在开机后自动在后台保持允许即可 用户级别的 systemd unit 位于 $HOME/.config/systemd/usr 目录下，系统级别的在 /etc/systemd/system 目录下，根据自己情况选择。本教程采用用户级别 编辑对应目下的aria2.service，配置内容如下 [Unit] Description=aria2 Daemon [Service] Type=simple ExecStart=/usr/bin/aria2c --conf-path=${HOME}/.config/aria2/aria2.conf [Install] WantedBy=default.target 接着设置后台自启并立即启动 systemctl enable --user now aria2.service ","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/:4:0","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["常用软件"],"content":"浏览器配置 AriaNG 是较为主流的 aria2 前端，其中有第三方在此基础之上实现的浏览器插件，比如 Chrome和 Firefox 根据配置文件的设置的RPC服务器的密码，在插件中配置好相应的 rpc-secret，同时可以在扩展选项中设置对浏览器的下载进行拦截，统一交给 aria2 服务进行下载 插件设置内容如下图所示 }} -- 至此，完成了 aria2 的基本设置 ","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/:5:0","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["常用软件"],"content":"参考资料 Archlinux aria2 Aria2 前端面板 ( GUI、WebUI ) AriaNg 使用教程 Arch Linux 的 Aria2 食用指南 ","date":"2022-03-08","objectID":"/posts/aria2%E9%85%8D%E7%BD%AE.html/:6:0","tags":["aria2"],"title":"Aria2的基本配置","uri":"/posts/aria2%E9%85%8D%E7%BD%AE.html/"},{"categories":["Linux"],"content":"Archlinux 开机磁盘自动解密","date":"2022-03-08","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/","tags":["archlinux","LUKS"],"title":"Archlinux自动解密磁盘","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"前言 由于我的Archlinux使用了LUKS进行磁盘加密，所以在启动系统时，必须输入两次密码，一次是加密磁盘的密码，另一次是用户密码 为了减少每次进入输入系统输入两次密码的麻烦，可以设置开机后自动解锁磁盘 ","date":"2022-03-08","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:1:0","tags":["archlinux","LUKS"],"title":"Archlinux自动解密磁盘","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"加密磁盘 加密磁盘操作具体可以参照Archlinux基础系统安装 ","date":"2022-03-08","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:2:0","tags":["archlinux","LUKS"],"title":"Archlinux自动解密磁盘","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"开机磁盘解密 ","date":"2022-03-08","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:3:0","tags":["archlinux","LUKS"],"title":"Archlinux自动解密磁盘","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"配置开机钩子 开机解密，需要配置开机的钩子(Hook)，根据解密钩子的方式可以分为encrypt hook和sd-encrypt hook，其中后者特性更多，因此采用后者进行解密。编辑/etc/mkinitcpio.conf文件 ，将udev更换为systemd，并添加sd-vconsole和sd-encrypt 修改前 HOOKS=(base udev autodetect keyboard modconf block filesystems fsck) 修改后为 HOOKS=(base systemd autodetect keyboard sd-vconsole modconf block sd-encrypt filesystems fsck) 在FILES=()这一栏中添加开机解密密钥的文件所在的位置 FILES=(/path/to/keyfile) 配置完后，重新生成mkinitcpio配置文件 mkinitcpio -P ","date":"2022-03-08","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:3:1","tags":["archlinux","LUKS"],"title":"Archlinux自动解密磁盘","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"配置内核参数 开机解密磁盘需要告诉内核加密磁盘所在的位置，所以需要配置对应的内核参数，编辑/etc/default/grub文件，在GRUB_CMDLINE_LINUX_DEFAULT或者GRUB_CMDLINE_LINUX参数栏中增加需要添加的内核参数，前者在每次开机都会进行加载，而后者在紧急启动进入系统时则不会加载，所以建议添加在前者栏中 rd.luks.uuid=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX，使用此标志指定要在启动时解密的设备的UUID rd.luks.name=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX=name，指定加密磁盘的UUID和解密后的磁盘名，使用了该内核参数，则可以省略上面的uuid参数 rd.luks.key=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX=/path/to/keyfile，使用keyfile进行系统解密，并传入keyfile的文件位置 rd.luks.options=options，设置解密参数，可选设置。如果是SSD，可以使用discard参数提供TRIM功能 root=/dev/mapper/cryptroot: 指定解密设备，该参数不管是encrypt还是sd-crypt，都必须要设置 其中UUID获取指令如下，获取的是解密前的磁盘UUID，而不是解密后的磁盘UUID lsblk -f └─nvme0n1p2 crypto 2 a0ea985c-f2c0-4c6c-af66-2bc10a158b0a └─cryptroot ext4 1.0 96055a51-9138-431a-8976-845ca1d09e20 上述查询结果中，a0ea985c-f2c0-4c6c-af66-2bc10a158b0a才是我们需要的UUID参数 注意：这和休眠设置的UUID参数不同，休眠需要的是解密后的UUID 如下示例: GRUB_CMDLINE_LINUX_DEFAULT=\"rd.luks.name=a0ea985c-f2c0-4c6c-af66-2bc10a158b0a=cryptroot rd.luks.options=timeout=10s,discard rd.luks.key=a0ea985c-f2c0-4c6c-af66-2bc10a158b0a=/etc/mykeyfile root=/dev/mapper/cryptroot\" 修改后，重新生成grub的配置文件 grub-mkconfig -o /boot/grub/grub.cfg 至此，重启开机便可以自动使用密钥进行解锁，而需要手动输入密码进行解锁磁盘了。 ","date":"2022-03-08","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:3:2","tags":["archlinux","LUKS"],"title":"Archlinux自动解密磁盘","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"参考资料 dm-crypt/System configuration 让系统更安全 - 系统分区加密 (Btrfs on LUKS) 操作实录 ","date":"2022-03-08","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:4:0","tags":["archlinux","LUKS"],"title":"Archlinux自动解密磁盘","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["常用软件"],"content":"Yadm 对 dotfiles 文件的基本使用方法","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"前言 在linux系统下，配置文件一般都是以.符号开头的，因此也被称为 dotfles。github有他人分享的配置，我们可以从中找到适合自己的配置文件 为了方便管理自己系统系统的配置文件，可以使用工具来对这些 dotfiles 进行统一管理。根据 arch wiki，常用的管理方式主要分为两种，软链接和git跟踪点文件，以下是 github 仓库中用的较多的工具 stow: GNU产品，使用软链进行管理，arch的farseerfc大佬就是使用该工具进行管理，具体介绍可以参照他的博客使用GNU stow 管理你的点文件 git bare: 使用git bare裸仓库进行管理 yadm: Yet Another Dotfiles Manager，一个git的wrapper，底层仍然是使用git来进行管理，方法使用和git没有区别，可以对特定文件加密 chezmoi: 和git用法差不多，但是会将需要跟踪的点文件冗余存储在chezmoi特定的本地仓库，可以对特定文件加密 为了保持和 git 的使用习惯，最后选择yadm作为点文件的管理工具，yadm默认相对位置为自己的家目录($HOME) ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:1:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"安装 Archlinux sudo pacman -S yadm Ubuntu/Debian sudo apt install -y yadm OSX brew install yadm ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:2:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"仓库初始化 ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:3:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"初始化本地仓库 如果一开始没有远程的 dotfiles 仓库，则需要先初始化本地仓库 yadm init yadm add \u003cimportant file\u003e yadm commit 再将本地仓库与远程仓库进行同步 yadm remote add origin \u003curl\u003e yadm push -u origin main ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:3:1","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"同步远程仓库 若一开始就有远程仓库，或使用他人的 yadm 的远程仓库时，则将远程仓库克隆下来即可 yadm clone \u003curl\u003e yadm status ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:3:2","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"基本使用 ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:4:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"添加需要跟踪的配置文件 使用 add 方法，将 dotfile 添加至 yadm 跟踪 list 当中 yadm add /path/to/dotfile ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:4:1","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"跟踪列表查看 使用 list 方法，查看当前路径下的跟踪文件，使用 -a 参数(Optional)，可以查看所有跟踪文件 yadm list \u003c-a\u003e ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:4:2","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"推送至远程仓库 使用commit和push方法，将变化文件推送至远程仓库 git commit -m \"commit word\" git push -u origin main ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:4:3","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"文件加密和解密 在$HOME/.config/yadm/encrypt文件中设置需要加密的文件，支持正则表达式，默认文件的起始地址为%HOME目录下，$HOME/.config/yadm/encrypt参考格式如下 .ssh/*.key yadm支持gpg的对称加密和非对称加密，默认加密方式为gpg的对称加密，加密后的文件存储于 $HOME/.local/share/yadm/archive 文件当中， yadm add $HOME/.config/yadm/encrypt yadm add $HOME/.local/share/yadm/archive 也可以通过 yadm config yadm.gpg-recipient \u003crecipient-address\u003e 指令指定使用非对称加密 yadm config yadm.gpg-recipient \u003crecipient-address\u003e chezmoi 不同的是，yadm 需要将文件手动进行解密，若使用对称加密，则按提示输入密码既可进行解密 注：系统没有 gunpg 则，则无法解密 yadm decrypt ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:5:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"引导程序 yadm 支持在初始化仓库时，自动调用 Bootstrap 程序执行初始化，该文件默认位置为$HOME/.config/yadm/bootstrap，且该文件必须为可执行程序 在初始化时，如果系统本身就含有 yadm 仓库对应的点文件时，yadm 默认是不会处理该文件，即不会覆盖，需要用户自己手动处理该冲突，对于引导程序，除了初始化执行时，也可以手动执行引导程序，来进行引导程序的调试 yadm bootstrap ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:6:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"参考资料 Archlinux Dotfiles Yet Another Dotfiles Manager 使用Yadm来管理我的配置 使用GNU stow 管理你的点文件 ","date":"2022-03-08","objectID":"/posts/yadm%E4%BD%BF%E7%94%A8.html/:7:0","tags":["YADM"],"title":"Yadm的基本使用","uri":"/posts/yadm%E4%BD%BF%E7%94%A8.html/"},{"categories":["常用软件"],"content":"Clash 在 linux 下的的基本安装和使用","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/","tags":["Clash"],"title":"Clash安装与使用","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["常用软件"],"content":"前言 Clash 是一个跨平台、支持 SS/V2ray 等协议、基于规则的网络代理软件 Clash 只是一个内核，为开源软件，而 Clash-premium 是闭源软件，后者多了scripts，rule-set和tun(windows只能使用该功能实现全局代理) 从clash的内核衍生了众多版本，用的最多的有 Clash for windows (简称 cfw )，Open Clash，Clashx。其中cfw不仅支持windows，还支持macos和linux，open Clash只支持路由器的openwrt系统，Clashx只支持macos ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:1:0","tags":["Clash"],"title":"Clash安装与使用","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["常用软件"],"content":"安装 在 arch 的官方仓库当中有根据 clash 内核打包好的组件，aur社区有打包好的 cfw 和 clash-user。其中cfw有ui界面，与 windows 上设置没有什么区别，而 clash-user 自带 clash 用户，可以根据用户的 uid 来设置防止流量回环 由于 linux 可以使用 tproxy 实现全局代理，可以直接使用官方仓库的 clash (或者 aur 的 clash-user ），来减少 clash 的资源占用( cfw 的 gui 需要占用资源) sudo pacman -S clash 使用yacd面板对Clash管理和流量监控 yay -S yacd ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:2:0","tags":["Clash"],"title":"Clash安装与使用","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["常用软件"],"content":"文件配置 clash 默认的配置文件位于用户目录下，而 clash-user 的配置位于/etc/clash目录下 配置中主要参数解释： port: http(s)代理端口 socks-port: socks5代理端口 redir-port: redir tcp代理端口 tproxy-port: tproxy udp(tcp)代理端口 mode: 代理方式，有全局代理(gloable)、规则代理(rule)和直连(direct)。其rle根据配置所提供的规则流量代理 external-controller: clash提供的api控制地址 external-ui: 外部控制ui地址 profile: clash部分存储设置模块 store-selected: 策略组节点选择后，是否需要存储选择记录，默认不存储(false) store-fake-ip: 设置为 true 是，将 fake-ip 与真实 dns 的 ip 对应记录存储在本地，以达到持久存储 dns 记录，加快 dns 解析速度 dns: clash的dns模块 enable: 设置为 true 时开启 clash 内置的dns模块 listen: dns 的监听端口 enhanced-mode: clash 提供两种 dns 查询模式，一种为正常 redir 转发模式，另一种为 fake-ip 模式，每次应用 dns 请求时，clash 将返回一个 fake 的 ip 地址，来达到加速建立 tcp 连接需求，但也会导致得到的 ip 不是真实的 ip，从而对某些网络调试带来麻烦 nameserver: dns 查询服务器，可以设置为 doh，tls 等dns查询方式。具体可以根根据个人习惯设置 fake-ip-filter: 过滤不使用 fake-ip 查来询dns的地址 proxies: 代理节点设置模块，请根据官方要求进行设置 proxy-groups: clash 的策略组，与 surge 类似。包含 relay(轮询)，url-test(ping最低优先)，load-balance(负载均衡)，fallback(按节点顺序优先使用可用节点)，select(手动选择节点) proxy-providers: 节点提供模块，一次可以提供多个级诶但，clash的1.9.0中增加了filter用来过滤节点 type: 节点组提供的类型，可选 http (远程提供)和 file (本地文件提供) filter: 节点过滤方式，支持正则 rules: 规则模块，以下是官方提供的说明，可以根据需要进行规则设置 DOMAIN: 规则会匹配与请求完全相同的地址 DOMAIN-SUFFIX: 规则会匹配与请求与主域名相同的地址，比如，google.com匹配www.google.com, mail.google.com和google.com本身，但不会匹配content-google.com DOMAIN-KEYWORD: 规则会匹配包含相应关键字的域名，除了 “apple” 会匹配 www.apple.com，“app” 同样也会匹配到 GEOIP: 规则会匹配相应国家和地区的 IP 地址 IP-CIDR: 规则会匹配规则范围内请求的 IP 地址 IP-CIDR6: 规则会匹配规则范围内请求的 IPv6 地址 SRC-IP-CIDR: 规则会匹配源 IP 地址 SRC-PORT: 规则会匹配源端口地址 DST-PORT: 规则会匹配目的地端口地址 PROCESS-NAME: 规则会匹配这个进程名的程序 MATCH: 将其余数据包路由到策略。此规则是必需的 以下为本人根据 clash 提供的官方配置进行更改的自用配置。dns 设置为 fake-ip 模式，dns 服务器均采用 doh，防止国内而 dns 污染，并使用 yacd 模块。因为 clash 开源版不支持rule-set模块(clash-premium支持)，所以不能像 surge 一样简洁书写规则，嫌规则冗长的可以使用 clash-premium 闭源软件书写，其他模块书写规则一致 mixed-port:7890allow-lan:truemode:Rulelog-level:warningexternal-controller:127.0.0.1:9090socks-port:7891redir-port:7892tproxy-port:7893ipv6:falseexternal-ui:'/usr/share/yacd'profile:store-selected:falsestore-fake-ip:truedns:enable:truelisten:0.0.0.0:1053enhanced-mode:fake-ipfake-ip-range:198.18.0.1/16nameserver:- https://223.5.5.5/dns-query- https://doh.pub/dns-query#- 114.114.114.114#- 223.5.5.5fallback:- https://1.1.1.1/dns-query- https://1.0.0.1/dns-query- https://8.8.8.8/dns-queryfallback-filter:geoip:truegeoip-code:CNfake-ip-filter:- '*.lan'- '*.localhost'- '*.local'- 'lens.l.google.com'- 'stun.l.google.com'- '*.gitbook.io'proxy-providers:HK_LOW:type:filepath:./cordcloud.yamlinterval:3600filter:'长沙联通转香港|广东移动转香港'health-check:enable:trueurl:http://wifi.vivo.com.cn/generate_204interval:600HK:type:filepath:./cordcloud.yamlinterval:3600filter:'深港专线'health-check:enable:trueurl:http://wifi.vivo.com.cn/generate_204interval:600TW:type:filepath:./cordcloud.yamlinterval:3600filter:'台湾'health-check:enable:trueurl:http://wifi.vivo.com.cn/generate_204interval:600JP:type:filepath:./cordcloud.yamlinterval:3600filter:'日本'health-check:enable:trueurl:http://wifi.vivo.com.cn/generate_204interval:600SG:type:filepath:./cordcloud.yamlinterval:3600filter:'新加坡'health-check:enable:trueurl:http://wifi.vivo.com.cn/generate_204interval:600US:type:filepath:./cordcloud.yamlinterval:3600filter:'美国'health-check:enable:trueurl:http://wifi.vivo.com.cn/generate_204interval:600proxy-groups:- name:Finaltype:selectproxies:- Proxies- DIRECT- name:Proxiestype:selectproxies:- load_balance- hk_urltest- tw_urltest- sg_urltest- us_urltest- name:StreamSEtype:selectproxies:- load_balance- hk_urltest- tw_urltest- sg_urltest- us_urltest- name:Googletype:selectproxies:- hk_fallback- hk_urltest- tw_urltest- sg_urltest- Proxies- name:Telegramtype:selectproxies:- sg_urltest- hk_urltest- tw_urltest- Proxies- name:load_balancetype:load-balanceurl:http://wifi.vivo.com.cn/generate_204interval:300proxies:use:- HK_LOW- name:hk_urltesttype:url-testurl:http://wifi.vivo.com.cn/generate_204interval:300proxies:use:- HK_LOW- name:hk_fallbacktype:fallbackurl:http://wifi.vivo.com.cn/generate_204interval:300proxies:use:- HK- name:us_urltesttype:url-testurl:http://wifi.vivo.com.cn/generate_204in","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:3:0","tags":["Clash"],"title":"Clash安装与使用","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["常用软件"],"content":"TProxy代理设置 采用clash官方推荐的wiki的防火墙设置，来拦截流量，由于udp不支持redir，所以tcp采用redir，udp采用tproxy(也都可以采用tproxy)，dns拦截端口为上述文件设置的1053，将dns的udp查询均转发至1053端口 为了防止clash代理自身流量，有两种常用方式避免流量回环，cgroup和uid。第一种方式将clash加入特定cgroup足，比如自定义的noproxy组，第二种方式为使用clash用户来启动clash进程。接着使用iptables来匹配对于流量 官方推荐wiki的iptables规则如下 #tcp iptables -t nat -N clash iptables -t nat -A clash -d 0.0.0.0/8 -j RETURN iptables -t nat -A clash -d 10.0.0.0/8 -j RETURN iptables -t nat -A clash -d 127.0.0.0/8 -j RETURN iptables -t nat -A clash -d 169.254.0.0/16 -j RETURN iptables -t nat -A clash -d 172.16.0.0/12 -j RETURN iptables -t nat -A clash -d 192.168.0.0/16 -j RETURN iptables -t nat -A clash -d 224.0.0.0/4 -j RETURN iptables -t nat -A clash -d 240.0.0.0/4 -j RETURN iptables -t nat -A clash -p tcp -j REDIRECT --to-port 7892 iptables -t nat -I PREROUTING -p tcp -d 8.8.8.8 -j REDIRECT --to-port 7892 iptables -t nat -I PREROUTING -p tcp -d 8.8.4.4 -j REDIRECT --to-port 7892 iptables -t nat -A PREROUTING -p tcp -j clash iptables -t nat -A OUTPUT -p tcp -d 198.18.0.0/16 -j REDIRECT --to-port 7892 #udp ip rule add fwmark 1 table 100 ip route add local default dev lo table 100 iptables -t mangle -N clash iptables -t mangle -A clash -d 0.0.0.0/8 -j RETURN iptables -t mangle -A clash -d 10.0.0.0/8 -j RETURN iptables -t mangle -A clash -d 127.0.0.0/8 -j RETURN iptables -t mangle -A clash -d 169.254.0.0/16 -j RETURN iptables -t mangle -A clash -d 172.16.0.0/12 -j RETURN iptables -t mangle -A clash -d 192.168.0.0/16 -j RETURN iptables -t mangle -A clash -d 224.0.0.0/4 -j RETURN iptables -t mangle -A clash -d 240.0.0.0/4 -j RETURN iptables -t mangle -A clash -p udp -j TPROXY --on-port 7893 --tproxy-mark 1 iptables -t mangle -A OUTPUT -p udp -d 198.18.0.0/16 -j MARK --set-mark 1 iptables -t mangle -A PREROUTING -p udp -j clash iptables -t nat -N CLASH_DNS iptables -t nat -F CLASH_DNS iptables -t nat -A CLASH_DNS -p udp -j REDIRECT --to-port 1053 iptables -t nat -I OUTPUT -p udp --dport 53 -j CLASH_DNS iptables -t nat -I PREROUTING -p udp --dport 53 -j REDIRECT --to 1053 # 以下二选一 # 使用noproxy的cgroup组来防止流量回环 iptables -t mangle -A OUTPUT -m cgroup --path \"noproxy.slice\" -j RETURN # 使用uid来防止流量回环 # iptables -t mangle -A clash-self -m owner --uid-owner clash -j RETURN ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:4:0","tags":["Clash"],"title":"Clash安装与使用","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["常用软件"],"content":"iptables规则持久化 iptables 规则在每次系统重启后，都会进行复原，因此如果设置错误导致无法上网时，可以删除防火墙对应规则或直接重启电脑解决 为了让iptables规则持久化，可以设置一个开机自启服务，自动运行对应脚本以设置防火墙。将上述 iptables 规则保存为为 iptables.sh ，并创建 /etc/systemd/system/tproxy.service，编辑设置内容如下 [Unit] Description=Setup ip-rule and ip-route for tproxy local network traffic. Before=network-pre.target Wants=network-pre.target [Service] Type=oneshot ExecStart=/bin/bash /path/to/iptables.sh RemainAfterExit=yes [Install] WantedBy=multi-user.target 设置服务开机自启 sudo systemctl enable tproxy.service ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:5:0","tags":["Clash"],"title":"Clash安装与使用","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["常用软件"],"content":"启动服务 clash 需要部分网络代理能力，编辑 clash@ 服务文件，添加 clash 的 capability 能力， sudo systemctl edit clash@.service 添加如下内容 CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW 让应用可以处理 TProxy 带来的流量 CAP_NET_BIND_SERVICE 允许应用绑定 1000 以下的端口 如果采用 cgroup 防止流量回环，还需要设置该服务所对应的 Slice，采用 UID 识别的话，则需要设置该服务的启动 USER，二选一即可，也可以同时都设置。若设置 UID 时，必须保证系统存在相应用户名 # cgroup Slice = noproxy.slice # UID User = username 同时设置 clash@$USER 服务后台自动，并立即启动 sudo systemctl enable --now clash@$USER.service ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:6:0","tags":["Clash"],"title":"Clash安装与使用","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["常用软件"],"content":"docker流量问题解决 为了解决 cgproxy 代理 bridge 联网的 docker 无法联网问题，需要进行如下而外设置 sysctl -w net.bridge.bridge-nf-call-iptables=0 sysctl -w net.bridge.bridge-nf-call-ip6tables=0 sysctl -w net.bridge.bridge-nf-call-arptables=0 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:7:0","tags":["Clash"],"title":"Clash安装与使用","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["常用软件"],"content":"参考资料 Clash github Wik Unofficial Clash Wiki clash-win-docs-new 容器(docker)桥接(bridge)模式时的代理问题 如何使用 Clash 的 TPROXY 功能进行透明代理 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:8:0","tags":["Clash"],"title":"Clash安装与使用","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"Archlinux 的KDE桌面系统安装","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"前言 作为主力系统，自然需要桌面系统(DE)。主流DE有KDE和GNOME等，根据个人习惯选择系统。本文主要介绍KDE桌面系统的安装 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:1:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"联网 由于桌面系统还没有安装完成，所以采用iwd和dhcpcd进行网络连接，首先启动iwd和dhcpcd，在使用iwd连接无限网络。iwd参照基础系统安装教程 systemctl start iwd systemctl start dhcpcd ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:2:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"准备普通用户 由于桌面系统需要普通用户，故先添加普通用户，并配置相应的权限 useradd -m -G wheel -s /bin/bash username passwd username 配置sudo权限 EDITOR=vim visudo 找到下面该行，并取消注释 #%wheel ALL=(ALL) ALL ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:3:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"安装KDE环境 KDE安装有三个包组，plasma-meta、plasma和plasma-desktop。其中plasma和plasma-meta区别为，kde后续增加软件包时，plasma-meta会自动安装，而plasma不会，剩下plasma-desktop只有kde能跑起来最少的软件。推荐使用plasma-meta，防止后续缺少组件。konsole和dolphin分别为kde的常用终端和文件管理 pacman -S plasma-meta konsole dolphin ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:4:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"启用DM kde默认自带sddm，可以根据需要更换 systemctl enable sddm ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:5:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"启用网络管理组件 kde和gnome桌面系统一般采用NetworkManager进行网络管理 systemctl enable NetworkManager ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:6:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"重启进入桌面系统 自此，基本的桌面系统已经安装完成，可以重启进入桌面系统 reboot ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:7:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"AUR Helper安装 yay和paru是较为常用的aur helper组件，根据个人习惯进行选择 注：由于安装需要从github拉取文件，需要配置代理才可以进行 git clone https://aur.archlinux.org/yay.git cd yay makepkg -si ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:8:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"输入法安装 facitx5为社区推荐输入法，安装facitx5 sudo pacman -S fcitx5-im sudo pacman -S fcitx5-chinese-addons fcitx5-pinyin-zhwiki fcitx5-material-colo 配置环境，konsole和dolphin需要环境变量的支持才可以使用输入法，使用EDITOR=vim sudoedit /etc/environment进行添加环境变量 GTK_IM_MODULE=fcitx QT_IM_MODULE=fcitx XMODIFIERS=@im=fcitx SDL_IM_MODULE=fcitx ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:9:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"配置默认编辑器 arch默认编辑器为vi，一般使用vim，使用EDITOR=vim sudoedit /etc/profile配置环境变量 export EDITOR='vim' ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:10:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"蓝牙配置 安装并配置蓝牙 sudo pacman -S bluez bluez-utils pulseaudio-bluetooth pavucontrol pulseaudio-alsa yay -S bluez-firmware sudo systemctl enable bluetooth.service sudo systemctl start bluetooth.service pulseaudio -k pulseaudio --start sudo usermod -a -G lp $USER 设置蓝牙自启，编辑/etc/bluetooth/main.conf文件，更改AutoEnable的值为true sudo vim /etc/bluetooth/main.conf ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:11:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"KDE安装完成 自此，arch的KDE系统基本完成安装。 KDE是可以根据自己的需要进行高度定制化，可以根据自己的需要进行定制化 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:12:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"参考资料 Archlinux Installation guide Arch Linux 安装使用教程 - ArchTutorial - Arch Linux Studio 2021 Archlinux双系统安装教程（超详细） Arch Linux Monthly Install: January 2022 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:13:0","tags":["archlinux"],"title":"Archlinux桌面系统安装","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"Archlinux 的基本安装","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"前言 第一次使用linux系统，查询linux各个版本的区别，最后看上了arch的aur，故选择arch作为主力linux系统(人的生命在于折腾，折腾就完事了) 这篇主要记录了基本系统的安装，不包含桌面系统 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:1:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"EFI模式验证 首先确认安装模式是否为EFI模式 ls /sys/firmware/efi/efivars ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:2:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"系统时钟校正 timedatectl set-ntp true ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:3:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"进行网络连接 arch系统网络连接方式主要有两种，有线连接和无线连接 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:4:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"有线连接 可以使用手机线与电脑进行连接，进行网络共享 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:4:1","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"无线连接 arch live系统默认为开启iwd,使用iwd进行无线网络连接 iwctl device list station wlan0 get-networks station waln0 connect WIFI-NAME 首先进入iwctl模式，查询当前设备无线网卡设备名,比如wlan0），再使用网卡查询当前wifi网络情况，最后对目标WIFI-NAME进行连接，提示输入密码进行确认 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:4:2","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"数据分区及格式化 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:5:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"分区 常见分区工具有cfdisk,gdisk等。为了方便，可以使用GUI的cfdisk进行分区 为了防止某些异常，优先对efi进行分区，大小500M～1G即可 剩下分区方式根据个人习惯进行。 比以将home分区单独分区，缺点是home分区和其他分区大小需要控制好，防止某分区空间爆满而需要对文件系统挪动， 将剩余分区大小划分为一个分区，缺点是重装系统麻烦 为了节省存储空间，故采用第二种方式。分区完成后，对主分区进行加密(Optional) ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:5:1","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"加密(可选) 为了保证自己的数据安全，可以对主要分区内容进行加密，防止他人挂载直接进入系统读取文件。 使用LUKS对主分区进行加密，没有特殊要求采用默认参数即可 默认使用手动输入密码对文件进行加密 cryptsetup -y -v luksFormat /path/to/device 使用keyfile对文件进行加密 首先生成所需要的keyfile文件，根据生成keyfile文件的类型不同，可以分为密码方式和随机字符或二进制。 为了简便，采用密码对文件进行加密，并将密码制作为keyfile,用作开机自动解密。 echo -n 'your_passphrase' \u003e /etc/keyfile chown root:root /etc/keyfile; chmod 400 /etc/keyfile 解密分区 cryptroot 为解密后对应的文件名，可以自定义 cryptsetup open /path/to/device/ cryptroot ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:5:2","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"格式化 efi分区采用mkfs.fat进行格式化。主分区根据不同的文件类型特性进行选择格式化，比如mkfs.ext4格式化为ext4,mkfs.btrfs格式化为btrfs，其中ext4速度整体快于btrfs,而btrfs存在快照等特性。 mkfs.fat -F 32 /path/to/efi mkfs.ext4 /path/to/device ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:5:3","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"挂载分区，并安装基本软件 先挂载/mnt分区，在创建/mnt/boot分区，并挂载(也可以创建/mnt/efi分区并进行挂载，二者不同之处可以查看archwiki) mount /dev/mapper/cryptroot /mnt mount /path/to/efi /mnt/boot 其中cryptroot为解密后分区所对应的名字，挂载时需要选择解密后的分区名 使用pacstarp在/mnt分区中安装基本软件，并生成分区文件，最后进入安装系统(根据电脑CPU类型安装所需要的微码，intel的cpu安装intel-ucode，amd的安装amd-ucode) pacstarp /mnt base base-devel linux linux-headers linux-firmware sudo amd-ucode genfstab -U /mnt \u003e\u003e /mnt/etc/fstab arch-chroot /mnt ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:6:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"更改镜像源并启用32位库 由于国外镜像站网速限制，可以使用国内教育镜像站进行加速，镜像配置文件为/etc/pacman.d/mirrorlist，可以设置多个镜像站 Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch 由于部分软件需要32位库，比如wine,而默认32位库是注释掉了，需要取消注释才能启用，不需要32位软件的可以不进行该操作。pacman的默认库文件位/etc/pacman.conf，取消注释multilib库 [multilib] Server = /etc/pacman.d/mirrorlist ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:7:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"修改密码 修改root的密码 passwd ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:8:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"基础软件安装 安装基础软件，比如网络，编辑器等 pacman -S networkmanager vim git wget curl dhcpcd iwd bash-completion dialog wpa_supplicant ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:9:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"时区和区域设置 使用软链设置时区，比如设置位亚洲的上海时区，并同步 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc 区域设置，对应文件位/etc/locale.gen，编辑并取消所需要的区域设置，并生成对应文件 vim /etc/locale.gen # 取消en_US.UTF-8和zh_CN.UTF-8的注销 locale-gen 向/etc/locale.conf导入本地语言设置，防止乱码 echo 'LANG=en_US.UTF-8' \u003e /etc/locale.conf ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:10:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"主机名设置 编辑/etc/hostname，设置主机名，比如arch，并根据主机名设置host文件 echo arch \u003e /etc/hostname cat \u003e /etc/hosts \u003c\u003cEOF 127.0.0.1 localhost ::1 localhost 127.0.1.1 arch.localdomain arch EOF ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:11:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"安装引导文件 引导文件有grub和system-boot，system-boot需要手动写入启动文件，grub指令可以直接生成，较为方便，故采用grub(若efi分区挂载为/mnt/efi，则将efi-directory更改为/efi) pacman -S grub efibootmgr grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB grub-mkconfig -o /boot/grub/grub.cfg ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:12:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"解密参数配置(可选) 如果对磁盘设置了加密，必须设置一些hook和内核参数来告诉内核加密磁盘的位置 具体操作可以参见Archlinux自动解密磁盘 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:13:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"完成安装 基本系统已经完成安装，退出系统，并取消文件挂载，重启既可以进入安装好的系统 exit umount -a reboot ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:14:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":["Linux"],"content":"参考资料 Archlinux Installation guide dm-crypt/Encrypting an entire system Arch Linux 安装使用教程 - ArchTutorial - Arch Linux Studio Arch Linux 搭建 java 开发环境 2021 Archlinux双系统安装教程（超详细） Arch Linux Monthly Install: January 2022 ","date":"2022-03-07","objectID":"/posts/archlinux%E5%AE%89%E8%A3%85.html/:15:0","tags":["archlinux"],"title":"Archlinux的基础系统安装流程","uri":"/posts/archlinux%E5%AE%89%E8%A3%85.html/"},{"categories":null,"content":"游戏规则 点击小圆点，围住小猫。 你点击一次，小猫走一次。 直到你把小猫围住（赢），或者小猫走到边界并逃跑（输）。 ","date":"0001-01-01","objectID":"/catch-the-cat/:1:0","tags":null,"title":"逮住那只猫!","uri":"/catch-the-cat/"}]