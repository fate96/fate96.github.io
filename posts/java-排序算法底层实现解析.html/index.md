# Java 排序算法底层实现解析


## 前言

排序算法是算法中的基础，也是集合和数组中最为常用的操作之一

## Arrays.sort 排序算法

### 基本数据类型

对于基本数据类型来说，底层实现都是通过双轴快速排序类的排序实现。虽然类叫双轴快速排序，但根据数组的长度，分别使用不同的排序算法。

![image-20220516164453883](/images/arrays_sort.png)

- 当 **int、long** 类型数组长度小于 `INSERTION_SORT_THRESHOLD` (47) 长度时，使用插入排序，大于 47 但小于 `QUICKSORT_THRESHOLD` (286) 长度时，使用双轴快速排序。当长度大于 286 时，则根据数组情况判断是否进行双轴快速排序还是 `TimeSort` 归并排序。
- **byte、short、char** 他们的取值范围有限，使用计数排序占用的空间也不过256/65536个单位，只要排序的数量不是特别少（有一个计数排序阈值，低于这个阈值的话就没有不要用空间换时间了），都应使用计数排序
- **float double** 则还需要根据数值情况进行数据选择

#### 引用类型

若是引用类型，包括包装类型，都采用 `ComparableTimSort.sort` 排序（如果配置了 `Arrays.LegacyMergeSort.userRequested` 则使用传统的归并排序）。

`ComparableTimSort.sort` 排序数组长如小于 32 时，则使用二分查找优化版的插入排序 `binarySort` ，否则则使用插入排序和归并排序（优化版的归并排序）的结合体 `TimeSort` 排序，二者算法都可以保证排序是稳定的。

## Collection.sort(Comparator<? super E> c)

集合都继承并实现了 sort 方法，因为集合存储的元素都是引用类型，故需要提供比较方法进行排序。

该方法首先将集合通过 `toArray(T[])` 将集合转换为数组，在调用 `Arrays.sort` 进行排序，最后将排序好的数据t通过迭代器一一复制给集合。

## 为什么采用多种排序算法

对于基本数据类型，稳定性没有意义，所以它可以使用不稳定的快排（当然它也使用了归并排序）

而对于对象类型，稳定性是比较重要的，因为对象相等的判断比较复杂，我们无法寄希望于每个程序员都会重写准确的equal方法，故而稳妥起见，最好相等对象尽量保持排序前的顺序，故而我们使用都是稳定算法的**归并排序和插入排序结合而成的TimSort算法**。

另外一个原因是归并排序的比较次数比快排少，移动（对象引用的移动）次数比快排多，而对于对象来说，比较是相对耗时的操作，所以它不适合使用快排。

## 参考资料

[让面试官满意的排序算法（图文解析）](https://segmentfault.com/a/1190000021503321) 

[Collections.sort()源码分析(基于JAVA8)](https://www.imooc.com/article/257268) 

[JAVA内置排序Arrays.sort实现简述](https://cherish-ls.github.io/2020/10/14/JAVA%E5%86%85%E7%BD%AE%E6%8E%92%E5%BA%8FArrays-sort%E5%AE%9E%E7%8E%B0%E7%AE%80%E8%BF%B0/) 

