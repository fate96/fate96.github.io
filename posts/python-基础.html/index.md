# Python 基础


## 前言

记录一些 python 的基础使用

## 内容

### 常用的魔法方法

- `__len__()` :  当使用 `len` 函数时，会自动调用该方法，若类没有使用该方法，则抛出异常
- `__getitem__()` : 当使用切片、索引、for-in 循环时候，会自动调用该方法，若类实现了该方法，则可以使用索引、切片对访问类中的元素
- `__iter__()` : 使用 for-in 循环会自动调用该方法，若类实现了该方法，则表明该类是可以迭代的
- `__abs__()` : 使用 `abs` 函数会自动调用该方法
- `__add__()` : 对类对象使用 ”+“ 运算符，会自动调用该方法，返回一个新的对象
- `__mul__()` : 对类对象使用 "*" 运算符，会自动调用该方法，返回一个新的对象
- `__repr__()` : 在终端直接输出对象时，调用该方法
- `__str__()` : 使用 print 打印对象时，调用该方法。如果没有，则使用 `__repr__ ` 方法进行替代
- `__bool__()` ：使用 `bool` 函数时，会自动调用该方法，使用 if 、while 语句时，也会自动调用该方法，因为判断对象是否为真会调用 `bool` 函数。如果 `__bool__` 方法不存在时，则调用 `__len__ ` 方法进行判断，长度为 0 为假。**默认对象都是为真** 。
- `__iadd__()` : 自增运算，当使用 += 运算符操作对象时，会自动调用该方法。若没有该方法，则会后退调用 `__add__` 方法。
- `__call__()` : 实现了该方法的类的对象，它的实例可以作为函数进行调用。

### 自增赋值

使用 += 等自增运算符时，表示原地自增。而使用 + 运算符，则生成了新的对象，并赋值。比如 a += b，则在 a 的基础上直接增加，不会生成新的变量。而 a = a + b ，则表示 a + b 生成新的对象，并将该对象的引用赋值给 a 。一般可变序列都实现了 `__iadd__` 等自增运算符，不可变序列则不支持该方法。 

### 序列的拼接

python 中两个列表相加时，是将两个列表合并为一个列表，合并顺序与相加顺序一致。这与 pytorch 的向量相加不一样，pytorch 两个向量相加则是对应位置值相加（按照广播原则进行）。

```python
arr = [1, 2]
out = [3] + arr
print(out)
## [3, 1, 2]
```

使用 $*$ 运算符进行序列拼接时，若元素为引用对象的引用的话，则拼接的多个序列都指向一个对象。若发生修改，则都进行修改。

```python
weird_board = [['_'] * 3] * 3 
weird_board[1][2] = 'O'
# [['_', '_', 'O'], ['_', '_', 'O'], ['_', '_', 'O']]
```

此时，需要使用列表推导式进行生成

```python
board = [['_'] * 3 for i in range(3)] 
```

### 除法运算

python3 中 `/` 除法，两个操作数会转换为 float 类型，结果而已为 float 类型，如果需保持整数类型是，需要使用 `//` 运算符。

```python
a = 10

# 死循环
while a > 10:
    a /= 10
```

#### 四舍五入

使用 round 方法对结果四舍五入

```python
print(round(10 / 3))
# 3
```

#### 取整数

舍去小数部分，只留整数部分

```python
print(int (-7 / 6))
# 0
pirnt(round(-7 / 6))
# -1
```

#### 向上取整

使用 math 库中的 ceil 方法，对结果向上取整

```python
import math
print(math.ceil(10 / 3))
# 4
```

#### 取整数和小数部分

使用 math 库中的 modf 方法，取结果的整数和小数部分，结果为二元组。

```python
import math
print(math.modf(10 / 3))
# (0.3333333333333335, 3.0)
```

参考： [Python除法：四舍五入，地板除，取整，取小数](http://www.juzicode.com/python-note-divide/) 

### nolocal 关键字

函数嵌套定义时，内部函数变量默认为局部变量，外部函数无法访问，即内部函数调用完成后销毁。若需要将内部变量提供给外部函数时，可以使用关键字 `nolocal` 关键字修饰

```python
def myfunc1():
  x = "John"
  def myfunc2():
    nonlocal x
    x = "hello"
  myfunc2()
  return x

print(myfunc1())
```

### 列表推导式的作用域

在 python2.* 版本中，列表推导式的变量会影响外部变量，但在 python3 中，列表推导式为局部作用域，不会影响外部变量

```python
x = 2
dummy = [x for x in 'abc']
print(x)
# 2
```

### 列表推导式的嵌套

列表推导式的 for 循环嵌套与书写顺序一致，生成相应的笛卡尔积结果

```python
product = [(x, y) for x in range(3) for y in range(3,5)]
# (0, 3) (0, 4) ...
```

### 切片赋值

如果把切片放在赋值语句的左边,或把它作为 del 操作的对象,我们就可以对序列进行嫁接、切除或就地修改操作。如果赋值的对象是一个切片，那么赋值语句的右侧必须是可以迭代的对象。**赋值的长度不需要一致**

### 元组自增

元组是不支持自增运算的，但是元组内部的若含有可变对象时，则可以进行自增，但是自增之后因为于元组内数据发生变化，则会抛出异常。（说明自增运算不是原子操作，普通 + 则直接抛出异常，且数据不会发生变更）

```python
t = (1, 2, [30, 40])
t[2] += [50, 60] # 抛出异常，但 t 已经发生变化
print(t) # t = (1, 2, [30, 40, 50, 60])
```

所以，元组内不应该放置可变元素

### 序列排序

`list.sort()` 会对序列原地排序，所以返回结果为 None，而内置的函数 `sorted()` 则会返回排序好的序列，该方法需要序列可以进行迭代，且两个方法都有两个关键字：

1. reverse：为 True 时，进行逆序排列。
2. key： 一个只有一个参数的函数，该函数会应用到所有元素上，并使用结果进行排序，默认恒等函数。

