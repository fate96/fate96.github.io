# 分布式事务的基本实现方式


## 前言

事务的几个特性：原子性(Atomicity )、一致性( Consistency )、隔离性或独立性( Isolation) 和持久性(Durabilily)，简称就是 ACID

Spring Boot 原生提供的的事务为本地事务，使用注解 `@Transactional` 来配置事务方法。但在分布式应用情况下，存在远程调用，并不能达到分布式事务的效果。比如远程调用完成后，本地服务出现异常，远程服务不会回滚，导致结果异常。因此在分布式应用中，需要使用分布式事务。

## 分布式事务

### CAP 定理

CAP 原则又称 CAP 定理，指的是在一个分布式系统中

- 一致性（Consistency）：在分布式系统中的所有数据备份，在同一时刻是否同样的值
- 可用性（Availability）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求
- 分区容错性（Partition tolerance）：大多数分布式系统都分布在多个子网络。

CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。

### BASE 理论

是对 CAP 理论的延伸，思想是即使无法做到强一致性（CAP 的一致性就是强一致性），但可以采用适当的采取弱一致性，即最终一致性

BASE 是指：

- BA：Basically Available 基本可用：基本可用是指分布式系统在出现故障的时候，允许损失部分可用功能上的可用性），允许损失部分可用性。
- S：Soft State 软状态：软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。
- E：Eventual Consistency 最终一致性：最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。

### 分布式的事务实现方案

1. 2PC（2 phase commit ）二阶提交，又叫做 XA Transactions。

![image-20230426104853604](https://raw.githubusercontent.com/luckyouo/pictures/main/image-20230426104853604.png)

第一阶段：事务协调器要求每个涉及到事务的数据库预提交（precommit）此操作，并反映是 否可以提交

第二阶段：事务协调器要求每个数据库提交数据

存在的问题：

- 同步阻塞：当参与事务者存在占用公共资源的情况，其中一个占用了资源，其他事务参与者就只能阻塞等待资源释放，处于阻塞状态
- 单点故障：一旦事务管理器出现故障，整个系统不可用
- 数据不一致：在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常，那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。
- 不确定性：当协事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。

	2. TCC（Try-Confirm-Cancel） 事务补偿型方案

刚性事务：遵循 ACID 原则，强一致性。

柔性事务：遵循 BASE 理论，最终一致性

TCC（Try-Confirm-Cancel）：

- Try 阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）
- Confirm 阶段：确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作满足幂等性。要求具备幂等设计，Confirm 失败后需要进行重试。
- Cancel 阶段：取消执行，释放 Try 阶段预留的业务资源 Cancel 操作满足幂等性 Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致。

TCC 事务机制相比于上面介绍的 XA，解决了其几个缺点：

1. 解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群
2. 同步阻塞：引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。
3. 数据一致性，有了补偿机制之后，由业务活动管理器控制一致性

缺点：基于 TCC 实现分布式事务，会将原来只需要一个接口就可以实现的逻辑拆分为 Try、Confirm、Cancel 三个接口，所以代码实现复杂度相对较高。

3. 最大努力通知型方案

最大努力通知是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果不影响主动方的处理结果。

大致流程：

- 系统 A 本地事务执行完之后，发送个消息到 MQ
- 有个专门消费 MQ 的服务，这个服务会消费 MQ 并调用系统 B 的接口；
- 要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B, 反复 N 次，最后还是不行就放弃。

4. 本地消息表

该方案中会有消息生产者与消费者两个角色，假设系统 A 是消息生产者，系统 B 是消息消费者，其大致流程如下：

![image-20230426104807576](https://raw.githubusercontent.com/luckyouo/pictures/main/image-20230426104807576.png)

大致流程：

- 当系统 A 被其他系统调用发生数据库表更操作，首先会更新数据库的业务表，其次会往相同数据库的消息表中插入一条数据，两个操作发生在同一个事务中
- 系统 A 的脚本定期轮询本地消息往 mq 中写入一条消息，如果消息发送失败会进行重试
- 系统 B 消费 mq 中的消息，并处理业务逻辑。如果本地事务处理失败，会在继续消费 mq 中的消息进行重试，如果业务上的失败，可以通知系统 A 进行回滚操作

5. 可靠消息最终一致性

实现：业务处理服务在业务事务提交之前，向实时消息服务请求发送消息，实时消息服务只记录消息数据，而不是真正的发送。业务处理服务在业务事务提交之后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。

![image-20230426104830079](https://raw.githubusercontent.com/luckyouo/pictures/main/image-20230426104830079.png)

大致流程：

- A 系统先向 mq 发送一条 prepare 消息，如果 prepare 消息发送失败，则直接取消操作
- 如果消息发送成功，则执行本地事务
- 如果本地事务执行成功，则想 mq 发送一条 confirm 消息，如果发送失败，则发送回滚消息
- B 系统定期消费 mq 中的 confirm 消息，执行本地事务，并发送 ack 消息。如果 B 系统中的本地事务失败，会一直不断重试，如果是业务失败，会向 A 系统发起回滚请求

## 参考资料

[分布式事务，这一篇就够了](https://xiaomi-info.github.io/2020/01/02/distributed-transaction/)

[Java项目《谷粒商城》Java架构师 | 微服务 | 大型电商项目](https://www.bilibili.com/video/BV1np4y1C7Yf?p=1&vd_source=b6eb6fd64ed675d7acddef5b0467fac9)

